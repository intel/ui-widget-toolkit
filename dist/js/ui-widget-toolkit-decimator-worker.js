(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("d3"));
	else if(typeof define === 'function' && define.amd)
		define("UWT", ["d3"], factory);
	else if(typeof exports === 'object')
		exports["UWT"] = factory(require("d3"));
	else
		root["UWT"] = factory(root["d3"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_d3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/core/cartesian/decimator/worker.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/core/cartesian/decimator/decimator.ts":
/*!***************************************************!*\
  !*** ./src/core/cartesian/decimator/decimator.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar data_1 = __webpack_require__(/*! ../../data */ \"./src/core/data.ts\");\nvar utilities_1 = __webpack_require__(/*! ../../utilities */ \"./src/core/utilities.ts\");\nexports.findFirstInsertionIdx = utilities_1.bisectBuffer(function (xy) { return xy.x; }).left;\nexports.findLastInsertionIdx = utilities_1.bisectBuffer(function (xy) { return xy.x; }).right;\n/**\n * this class allows a decimation function to be passed in to allow for\n * generic decimation\n */\nvar CustomPointXYDecimator = /** @class */ (function () {\n    function CustomPointXYDecimator() {\n        this._name = 'Simple Unimplemented Decimator';\n    }\n    /**\n     * construct a generic decimator using a custom user function\n     *\n     * @param xValueToCoord converts the x value to a GUI x coordinate\n     * @param yValueToCoord converts the y value to a GUI y coordinate\n     * @param decimationFunc convert a list of data to a for rendering smaller list\n     */\n    CustomPointXYDecimator.prototype.initialize = function (xValueToCoord, xCoordToValue, yValueToCoord) {\n        this._xValueToCoord = xValueToCoord;\n        this._xCoordToValue = xCoordToValue;\n        this._yValueToCoord = yValueToCoord;\n    };\n    /**\n     * Returns the key of this decimator\n     */\n    CustomPointXYDecimator.prototype.getKey = function () {\n        return this._key;\n    };\n    /**\n     * Returns the name of this decimator\n     */\n    CustomPointXYDecimator.prototype.getName = function () {\n        return this._name;\n    };\n    /**\n     * Returns the decimated list of buckets\n     */\n    CustomPointXYDecimator.prototype.getValues = function () {\n        return this._decimatedValues;\n    };\n    /**\n     * Values to be decimated\n     *\n     * @param xStart - start time of the region\n     * @param xEnd - start time of the region\n     * @param values - Values to be decimated.\n     */\n    CustomPointXYDecimator.prototype.decimateValues = function (xStart, xEnd, inputValues) {\n        // loop over the data samples\n        this._decimatedValues = [];\n        if (inputValues.length() === 0) {\n            return this._decimatedValues;\n        }\n        var left = exports.findFirstInsertionIdx(inputValues, xStart);\n        var right = exports.findLastInsertionIdx(inputValues, xEnd);\n        if (left > 0) {\n            --left;\n        }\n        if (right < inputValues.length()) {\n            ++right;\n        }\n        var xStartCoord;\n        if (xStart) {\n            xStartCoord = Math.floor(this._xValueToCoord(xStart));\n        }\n        else {\n            xStartCoord = Math.floor(this._xValueToCoord(inputValues.get(left).x));\n        }\n        var startIdx = left;\n        for (var index = left; index < right; ++index) {\n            var inputValue = inputValues.get(index);\n            var xEndCoord = Math.floor(this._xValueToCoord(inputValue.x));\n            var endIdx = index;\n            if (endIdx === right - 1 || xEndCoord !== xStartCoord &&\n                (xEnd === undefined || (inputValue.x < xEnd && inputValue.x > xStart))) {\n                this._decimatedValues = this._decimatedValues.concat(this._customFunc(inputValues, startIdx, endIdx, this._yValueToCoord, this._xValueToCoord, this._xCoordToValue(xStartCoord), this._xCoordToValue(xEndCoord)));\n                xStartCoord = xEndCoord;\n                startIdx = endIdx;\n            }\n        }\n        return this._decimatedValues;\n    };\n    return CustomPointXYDecimator;\n}());\nexports.CustomPointXYDecimator = CustomPointXYDecimator;\n/** used to compute the min values for a set of data */\nvar MinPointDecimator = /** @class */ (function (_super) {\n    __extends(MinPointDecimator, _super);\n    function MinPointDecimator() {\n        var _this = _super.call(this) || this;\n        _this._key = MinPointDecimator.KEY;\n        _this._name = 'Min';\n        _this._customFunc = function (values, startIdx, endIdx, yValueToCoord) {\n            if (values.length() > 0 && startIdx !== endIdx) {\n                var minY = Number.MAX_VALUE;\n                var minValue = void 0;\n                for (var i = startIdx; i < endIdx; ++i) {\n                    var value = values.get(i);\n                    var y = value.y;\n                    if (y < minY) {\n                        minValue = value;\n                        minY = y;\n                    }\n                }\n                return [minValue];\n            }\n            return [];\n        };\n        return _this;\n    }\n    MinPointDecimator.KEY = 'MinPointDecimator';\n    return MinPointDecimator;\n}(CustomPointXYDecimator));\nexports.MinPointDecimator = MinPointDecimator;\n;\nfunction computeAvg(values, startIdx, endIdx, yValueToCoord) {\n    if (values.length() > 0 && startIdx !== endIdx) {\n        var total = 0;\n        for (var i = startIdx; i < endIdx; ++i) {\n            var value = values.get(i);\n            total += value.y;\n        }\n        return [new data_1.XYValue(values.get(endIdx - 1).x, total / (endIdx - startIdx))];\n    }\n    return [];\n}\n/** used to compute the avg values for a set of data */\nvar AvgPointDecimator = /** @class */ (function (_super) {\n    __extends(AvgPointDecimator, _super);\n    function AvgPointDecimator() {\n        var _this = _super.call(this) || this;\n        _this._key = AvgPointDecimator.KEY;\n        _this._name = 'Avg';\n        _this._customFunc = computeAvg;\n        return _this;\n    }\n    AvgPointDecimator.KEY = 'AvgPointDecimator';\n    return AvgPointDecimator;\n}(CustomPointXYDecimator));\nexports.AvgPointDecimator = AvgPointDecimator;\n;\n/** used to compute the min values for a set of data */\nvar MaxPointDecimator = /** @class */ (function (_super) {\n    __extends(MaxPointDecimator, _super);\n    function MaxPointDecimator() {\n        var _this = _super.call(this) || this;\n        _this._key = MaxPointDecimator.KEY;\n        _this._name = 'Max';\n        _this._customFunc = function (values, startIdx, endIdx, yValueToCoord) {\n            if (values.length() > 0 && startIdx !== endIdx) {\n                var maxY = -Number.MAX_VALUE;\n                var maxValue = void 0;\n                for (var i = startIdx; i < endIdx; ++i) {\n                    var value = values.get(i);\n                    var y = value.y;\n                    if (y > maxY) {\n                        maxValue = value;\n                        maxY = y;\n                    }\n                }\n                return [maxValue];\n            }\n            return [];\n        };\n        return _this;\n    }\n    MaxPointDecimator.KEY = 'MaxPointDecimator';\n    return MaxPointDecimator;\n}(CustomPointXYDecimator));\nexports.MaxPointDecimator = MaxPointDecimator;\n;\n/**\n * Data decimation to fit information to onto the graph.\n *\n * This class divides the x-Axis time range into a set of buckets.  Each\n * bucket provides the average of the values, the minimum & maximum\n * values, and the values upon entry & exit.\n * It assumes that the DB values are increase over the time.\n */\nvar XYPointDecimator = /** @class */ (function (_super) {\n    __extends(XYPointDecimator, _super);\n    function XYPointDecimator() {\n        var _this = _super.call(this) || this;\n        _this._key = XYPointDecimator.KEY;\n        _this._name = 'XYPointDecimator';\n        _this._customFunc = function (values, startIdx, endIdx, yValueToCoord) {\n            var yMap = {};\n            var reducedValues = [];\n            for (var i = startIdx; i < endIdx; ++i) {\n                var value = values.get(i);\n                var yCoord = Math.floor(yValueToCoord(value.y));\n                if (!yMap.hasOwnProperty(yCoord.toString())) {\n                    reducedValues.push(value);\n                    yMap[yCoord] = true;\n                }\n            }\n            return reducedValues;\n        };\n        return _this;\n    }\n    XYPointDecimator.KEY = 'XYPointDecimator';\n    return XYPointDecimator;\n}(CustomPointXYDecimator)); // class VerticalDecimator\nexports.XYPointDecimator = XYPointDecimator;\n/**\n * this class allows a decimation function to be passed in to allow for\n * generic decimation\n */\nvar CustomContinuousXYDecimator = /** @class */ (function () {\n    function CustomContinuousXYDecimator() {\n        this._name = 'Simple Unimplemented Decimator';\n    }\n    /**\n     * construct a generic decimator using a custom user function\n     *\n     * @param xValueToCoord converts the x value to a GUI x coordinate\n     * @param yValueToCoord converts the y value to a GUI y coordinate\n     * @param decimationFunc convert a list of data to a for rendering smaller list\n     */\n    CustomContinuousXYDecimator.prototype.initialize = function (xValueToCoord, xCoordToValue, yValueToCoord) {\n        this._xValueToCoord = xValueToCoord;\n        this._xCoordToValue = xCoordToValue;\n        this._yValueToCoord = yValueToCoord;\n    };\n    /**\n     * Returns the key of this decimator\n     */\n    CustomContinuousXYDecimator.prototype.getKey = function () {\n        return this._key;\n    };\n    /**\n     * Returns the name of this decimator\n     */\n    CustomContinuousXYDecimator.prototype.getName = function () {\n        return this._name;\n    };\n    /**\n     * Returns the decimated list of buckets\n     */\n    CustomContinuousXYDecimator.prototype.getValues = function () {\n        return this._decimatedValues;\n    };\n    /**\n     * Values to be decimated\n     *\n     * @param xStart - start time of the region\n     * @param xEnd - start time of the region\n     * @param values - Values to be decimated.\n     */\n    CustomContinuousXYDecimator.prototype.decimateValues = function (xStart, xEnd, inputValues) {\n        // loop over the data samples\n        this._decimatedValues = [];\n        if (inputValues.length() === 0) {\n            return this._decimatedValues;\n        }\n        var left = exports.findFirstInsertionIdx(inputValues, xStart);\n        var right = exports.findLastInsertionIdx(inputValues, xEnd);\n        if (left > 0) {\n            --left;\n        }\n        if (right < inputValues.length()) {\n            ++right;\n        }\n        var lastX;\n        if (left < inputValues.length()) {\n            lastX = Math.floor(this._xValueToCoord(inputValues.get(left).x));\n            --lastX;\n        }\n        var xStartCoord;\n        if (xStart) {\n            xStartCoord = this._xValueToCoord(xStart);\n        }\n        else {\n            xStartCoord = left;\n        }\n        var lastIdx = left;\n        for (var index = left; index < right; ++index) {\n            var inputValue = inputValues.get(index);\n            var xEndCoord = Math.floor(this._xValueToCoord(inputValue.x));\n            var endIdx = index + 1;\n            if (xEndCoord !== lastX) {\n                this._decimatedValues = this._decimatedValues.concat(this._customFunc(inputValues, lastIdx, endIdx, this._yValueToCoord, this._xValueToCoord, this._xCoordToValue(xStartCoord), this._xCoordToValue(xEndCoord)));\n                xStartCoord = xEndCoord;\n                lastX = xEndCoord;\n                lastIdx = endIdx;\n            }\n        }\n        if (lastIdx !== inputValues.length()) {\n            this._decimatedValues = this._decimatedValues.concat(this._customFunc(inputValues, lastIdx, lastIdx + 1, this._yValueToCoord, this._xValueToCoord, this._xCoordToValue(xStartCoord), Number.MAX_VALUE));\n        }\n        return this._decimatedValues;\n    };\n    return CustomContinuousXYDecimator;\n}());\nexports.CustomContinuousXYDecimator = CustomContinuousXYDecimator;\n/** used to compute the avg values for a set of data */\nvar AvgContinuousDecimator = /** @class */ (function (_super) {\n    __extends(AvgContinuousDecimator, _super);\n    function AvgContinuousDecimator() {\n        var _this = _super.call(this) || this;\n        _this._key = AvgContinuousDecimator.KEY;\n        _this._name = 'Avg';\n        _this._customFunc = computeAvg;\n        return _this;\n    }\n    AvgContinuousDecimator.KEY = 'AvgContinuousDecimator';\n    return AvgContinuousDecimator;\n}(CustomContinuousXYDecimator));\nexports.AvgContinuousDecimator = AvgContinuousDecimator;\n;\n/** this is a helper function class that computes the summed values for each\n * Y state per each X bucket\n */\nfunction sumMultiXYSeriesValues(_xValueToCoord, _xCoordToValue, _yValueToCoord, xStart, xEnd, values) {\n    var ret = [];\n    // first this is total weighted sum per x, then used to store percentage per x\n    var tempValues = [];\n    var globalStartBucket = 0;\n    var globalEndBucket = Math.ceil(_xValueToCoord(Number.MAX_VALUE));\n    if (globalEndBucket < globalStartBucket) {\n        return undefined;\n    }\n    // NOTE: I do this up here so I can cheat and use the x values here\n    // so later I don't keep calling _xCoordToValue\n    var xBucketValues = [];\n    for (var bucket = 0; bucket <= globalEndBucket + 1; ++bucket) {\n        xBucketValues.push(_xCoordToValue(bucket));\n    }\n    // for a series get the weighted sum for the number of buckets xStart to xEnd\n    for (var stateIdx = 0; stateIdx < values.length; ++stateIdx) {\n        var perStateData = values[stateIdx];\n        var value = void 0;\n        var nextValue = void 0;\n        var start = exports.findFirstInsertionIdx(values[stateIdx], xStart);\n        var end = exports.findLastInsertionIdx(values[stateIdx], xEnd);\n        if (start > 0) {\n            --start;\n        }\n        // the last element would be caught by the algorithm already\n        if (end === perStateData.length()) {\n            --end;\n        }\n        // pad endBucket + 1 so we get data past the last point in the bucket\n        // so we can graph to the first value in the next bucket\n        tempValues[stateIdx] = Array.apply(null, Array(globalEndBucket)).\n            map(Number.prototype.valueOf, 0);\n        // get weighted sum of the values for each bucket\n        for (var rawDataIdx = start; rawDataIdx < end; ++rawDataIdx) {\n            value = perStateData.get(rawDataIdx);\n            nextValue = perStateData.get(rawDataIdx + 1);\n            var startBucket = Math.floor(_xValueToCoord(value.x));\n            var endBucket = Math.floor(_xValueToCoord(nextValue.x));\n            var totalX = (nextValue.x - value.x);\n            var valuePerX = totalX === 0 ? 0 : nextValue.y / totalX;\n            if (startBucket === endBucket) {\n                if (xStart === undefined || (value.x > xStart && nextValue.x < xEnd)) {\n                    // here it's all in the existing bucket\n                    tempValues[stateIdx][startBucket] += valuePerX;\n                }\n                else {\n                    var bucketScalar = 1 / (xBucketValues[startBucket + 1] - xBucketValues[startBucket]);\n                    if (nextValue.x < xEnd) {\n                        // here the back half is in the bucket\n                        tempValues[stateIdx][startBucket] +=\n                            (nextValue.x - xBucketValues[startBucket]) * valuePerX * bucketScalar;\n                    }\n                    else {\n                        // here the front half is in the bucket\n                        tempValues[stateIdx][startBucket] +=\n                            (xBucketValues[startBucket + 1] - value.x) * valuePerX * bucketScalar;\n                    }\n                }\n            }\n            else {\n                var bucketScalar = 1 / (xBucketValues[startBucket + 1] - xBucketValues[startBucket]);\n                var startX = xStart ? Math.max(xStart, value.x) : value.x;\n                var endStartBucket = xBucketValues[startBucket + 1];\n                tempValues[stateIdx][startBucket] +=\n                    (endStartBucket - startX) * valuePerX * bucketScalar;\n                // add in all the bucket values in between\n                for (var currBucket = startBucket + 1; currBucket < endBucket; ++currBucket) {\n                    tempValues[stateIdx][currBucket] += valuePerX;\n                }\n                // add in end bucket amount\n                bucketScalar = 1 / (xBucketValues[endBucket] - xBucketValues[endBucket - 1]);\n                var endX = xEnd ? Math.min(xEnd, nextValue.x) : nextValue.x;\n                var startEndBucket = xBucketValues[endBucket];\n                tempValues[stateIdx][endBucket] +=\n                    (endX - startEndBucket) * valuePerX * bucketScalar;\n            }\n        }\n        ret[stateIdx] = [];\n        var buckets = tempValues[stateIdx];\n        for (var bucket = 0; bucket < buckets.length; ++bucket) {\n            ret[stateIdx][bucket] = {\n                x: xBucketValues[bucket],\n                y: tempValues[stateIdx][bucket]\n            };\n        }\n    }\n    return ret;\n}\nexports.sumMultiXYSeriesValues = sumMultiXYSeriesValues;\n/** class that computes the summed values for each Y state per each X bucket */\nvar SummedValueMultiXYSeriesDecimator = /** @class */ (function () {\n    function SummedValueMultiXYSeriesDecimator() {\n    }\n    /**\n     * construct a generic decimator using a custom user function\n     *\n     * @param xValueToCoord converts the x value to a GUI x coordinate\n     * @param yValueToCoord converts the y value to a GUI y coordinate\n     * @param decimationFunc convert a list of data to a for rendering smaller list\n     */\n    SummedValueMultiXYSeriesDecimator.prototype.initialize = function (xValueToCoord, xCoordToValue, yValueToCoord) {\n        this._xValueToCoord = xValueToCoord;\n        this._xCoordToValue = xCoordToValue;\n        this._yValueToCoord = yValueToCoord;\n    };\n    /**\n     * Returns the key of this decimator\n     */\n    SummedValueMultiXYSeriesDecimator.prototype.getKey = function () {\n        return SummedValueMultiXYSeriesDecimator.KEY;\n    };\n    /**\n     * Returns the decimated list of buckets\n     */\n    SummedValueMultiXYSeriesDecimator.prototype.getName = function () {\n        return '';\n    };\n    /**\n     * Returns the decimated list of buckets\n     */\n    SummedValueMultiXYSeriesDecimator.prototype.getValues = function () {\n        return this._decimatedValues;\n    };\n    /**\n     * Values to be decimated\n     *\n     * @param xStart - start time of the region\n     * @param xEnd - start time of the region\n     * @param values - Values to be decimated.\n     */\n    SummedValueMultiXYSeriesDecimator.prototype.decimateValues = function (xStart, xEnd, values) {\n        this._decimatedValues = sumMultiXYSeriesValues(this._xValueToCoord, this._xCoordToValue, this._yValueToCoord, xStart, xEnd, values);\n        return this._decimatedValues;\n    };\n    SummedValueMultiXYSeriesDecimator.KEY = 'SummedValueMultiXYSeriesDecimator';\n    return SummedValueMultiXYSeriesDecimator;\n}());\nexports.SummedValueMultiXYSeriesDecimator = SummedValueMultiXYSeriesDecimator;\n;\n/** class that computes the residency values for each Y state per each X bucket.\n * This means the sum of all values within an output bucket is 100.\n*/\nvar ResidencyDecimator = /** @class */ (function (_super) {\n    __extends(ResidencyDecimator, _super);\n    function ResidencyDecimator() {\n        return _super.call(this) || this;\n    }\n    /**\n     * Returns the key of this decimator\n     */\n    ResidencyDecimator.prototype.getKey = function () {\n        return ResidencyDecimator.KEY;\n    };\n    /**\n     * Returns the decimated list of buckets\n     */\n    ResidencyDecimator.prototype.getName = function () {\n        return '';\n    };\n    /**\n     * Values to be decimated\n     *\n     * @param xStart - start time of the region\n     * @param xEnd - start time of the region\n     * @param values - Values to be decimated.\n     */\n    ResidencyDecimator.prototype.decimateValues = function (xStart, xEnd, values) {\n        this._decimatedValues = sumMultiXYSeriesValues(this._xValueToCoord, this._xCoordToValue, this._yValueToCoord, xStart, xEnd, values);\n        // normalize all values to 100%\n        for (var bucket = 0; bucket < this._decimatedValues[0].length; ++bucket) {\n            var total = 0;\n            for (var stateIdx = 0; stateIdx < this._decimatedValues.length; ++stateIdx) {\n                if (this._decimatedValues[stateIdx][bucket].y) {\n                    total += this._decimatedValues[stateIdx][bucket].y;\n                }\n            }\n            if (total > 0) {\n                var scalar = 100 / total;\n                for (var stateIdx = 0; stateIdx < values.length; ++stateIdx) {\n                    if (this._decimatedValues[stateIdx][bucket].y) {\n                        this._decimatedValues[stateIdx][bucket].y =\n                            this._decimatedValues[stateIdx][bucket].y * scalar;\n                    }\n                }\n            }\n        }\n        return this._decimatedValues;\n    };\n    ResidencyDecimator.KEY = 'ResidencyDecimator';\n    return ResidencyDecimator;\n}(SummedValueMultiXYSeriesDecimator));\nexports.ResidencyDecimator = ResidencyDecimator;\n;\n/** class that computes the summed Y value per each X bucket */\nvar SummedValueXYSeriesDecimator = /** @class */ (function () {\n    function SummedValueXYSeriesDecimator() {\n    }\n    /**\n     * construct a generic decimator using a custom user function\n     *\n     * @param xValueToCoord converts the x value to a GUI x coordinate\n     * @param yValueToCoord converts the y value to a GUI y coordinate\n     * @param decimationFunc convert a list of data to a for rendering smaller list\n     */\n    SummedValueXYSeriesDecimator.prototype.initialize = function (xValueToCoord, xCoordToValue, yValueToCoord) {\n        this._xValueToCoord = xValueToCoord;\n        this._xCoordToValue = xCoordToValue;\n        this._yValueToCoord = yValueToCoord;\n    };\n    /**\n     * Returns the name of this decimator\n     */\n    SummedValueXYSeriesDecimator.prototype.getKey = function () {\n        return SummedValueXYSeriesDecimator.KEY;\n    };\n    /**\n     * Returns the name of this decimator\n     */\n    SummedValueXYSeriesDecimator.prototype.getName = function () {\n        return '';\n    };\n    /**\n     * Returns the decimated list of buckets\n     */\n    SummedValueXYSeriesDecimator.prototype.getValues = function () {\n        return this._decimatedValues;\n    };\n    /**\n     * Values to be decimated\n     *\n     * @param xStart - start time of the region\n     * @param xEnd - start time of the region\n     * @param values - Values to be decimated.\n     */\n    SummedValueXYSeriesDecimator.prototype.decimateValues = function (xStart, xEnd, values) {\n        this._decimatedValues = sumMultiXYSeriesValues(this._xValueToCoord, this._xCoordToValue, this._yValueToCoord, xStart, xEnd, [values])[0];\n        return this._decimatedValues;\n    };\n    SummedValueXYSeriesDecimator.KEY = 'SummedValueXYSeriesDecimator';\n    return SummedValueXYSeriesDecimator;\n}());\nexports.SummedValueXYSeriesDecimator = SummedValueXYSeriesDecimator;\n/*************************************************************\n * NEWS (Min/Max/Entry/Exit) CHART DECIMATORS\n */\n/**\n * Internally used class for the array of values\n */\nvar NEWSDecimationValue = /** @class */ (function (_super) {\n    __extends(NEWSDecimationValue, _super);\n    /**\n     * Construct a DecimationValue instance\n     *\n     * @param value - an XYValue to initialize the decimation value\n     */\n    function NEWSDecimationValue() {\n        var _this = _super.call(this, undefined, undefined, undefined, undefined, undefined) || this;\n        _this._bucketPts = 0;\n        return _this;\n    } // constructor\n    return NEWSDecimationValue;\n}(data_1.CandlestickValue)); // class DecimationValue\nexports.NEWSDecimationValue = NEWSDecimationValue;\n/**\n * Data decimation to fit information to onto the graph.\n *\n * This class divides the x-Axis time range into a set of buckets.  Each\n * bucket provides the average of the values, the minimum & maximum\n * values, and the values upon entry & exit.\n * It assumes that the DB values are increase over the time.\n */\nvar NEWSBaseDecimator = /** @class */ (function () {\n    function NEWSBaseDecimator() {\n    }\n    NEWSBaseDecimator.prototype.initialize = function (xValueToCoord, xCoordToValue, yValueToCoord) {\n        this._xValueToCoord = xValueToCoord;\n        this._xCoordToValue = xCoordToValue;\n        this._yValueToCoord = yValueToCoord;\n    };\n    /**\n     * Returns the key of this decimator\n     */\n    NEWSBaseDecimator.prototype.getKey = function () {\n        return this._key;\n    };\n    NEWSBaseDecimator.prototype.getName = function () {\n        return '';\n    };\n    /**\n     * Get the accumulated buckets\n     *\n     * @returns the accumulated buckets\n     */\n    NEWSBaseDecimator.prototype.getValues = function () {\n        return this._buckets;\n    };\n    /**\n     * Bucket dumper\n     */\n    NEWSBaseDecimator.prototype._dumpBucket = function (firstTimeStamp, bucket, valuesInBucket) {\n        var details = \"valuesInBucket = \" + valuesInBucket.toFixed(0) + \", \";\n        details += \"([avg]Time delta, avgValue) = (\" +\n            (bucket.x - firstTimeStamp).toFixed(2) + \", \" + bucket.y.toFixed(2) + \"), \";\n        details += \"(entry, min, max, exit) = (\" + (bucket.entry).toFixed(2) + \", \" +\n            (bucket.min).toFixed(2) + \", \" + (bucket.max).toFixed(2) + \", \" +\n            (bucket.exit).toFixed(2) + \")\";\n        return details;\n    };\n    /**\n     * Values to be decimated\n     *\n     * @param xStart - start time of the region\n     * @param xEnd - start time of the region\n     * @param values - Values to be decimated.\n     */\n    NEWSBaseDecimator.prototype.decimateValues = function (xStart, xEnd, inputValues) {\n        throw 'Error need to implement decimate code';\n    };\n    return NEWSBaseDecimator;\n}());\nexports.NEWSBaseDecimator = NEWSBaseDecimator;\n/** this class takes a series x, y points and using for each X bucket provides\n * the Y entry/exit/min/max/average for that X bucket\n */\nvar NEWSPointDecimator = /** @class */ (function (_super) {\n    __extends(NEWSPointDecimator, _super);\n    function NEWSPointDecimator() {\n        var _this = _super.call(this) || this;\n        _this._key = NEWSPointDecimator.KEY;\n        return _this;\n    }\n    NEWSPointDecimator.prototype.createNewBucket = function (decimatedValue, value) {\n        decimatedValue.entry = value.y;\n        decimatedValue.exit = value.y;\n        decimatedValue.min = value.y;\n        decimatedValue.max = value.y;\n        decimatedValue.x = 0;\n        decimatedValue.y = 0;\n        decimatedValue._bucketPts = 0;\n        this.addToBucket(decimatedValue, value);\n    };\n    /**\n     * Add an x/y value pair to this value. Both the time (x) and\n     * value (y) are added to this point/bucket\n     *\n     * @param dbPoint - The x/y value pair to add to this value.\n    */\n    NEWSPointDecimator.prototype.addToBucket = function (decimatedValue, value) {\n        decimatedValue.x += value.x;\n        decimatedValue.y += value.y;\n        decimatedValue.min = Math.min(decimatedValue.min, value.y);\n        decimatedValue.max = Math.max(decimatedValue.max, value.y);\n        decimatedValue.exit = value.y;\n        decimatedValue._bucketPts++;\n    };\n    NEWSPointDecimator.prototype.finalizeBucket = function (decimatedValue, pointsInBucket) {\n        if (undefined !== pointsInBucket) {\n            if (pointsInBucket !== decimatedValue._bucketPts) {\n                console.log(\"AverageTime: mismatching pt calculation\");\n            }\n        }\n        if (decimatedValue._bucketPts === 0) {\n            console.log(\"AverageTime: 0 points\");\n        }\n        decimatedValue.x = decimatedValue.x / decimatedValue._bucketPts;\n        decimatedValue.y = decimatedValue.y / decimatedValue._bucketPts;\n    };\n    /**\n     * Values to be decimated\n     *\n     * @param xStart - start time of the region\n     * @param xEnd - start time of the region\n     * @param values - Values to be decimated.\n     */\n    NEWSPointDecimator.prototype.decimateValues = function (xStart, xEnd, inputValues) {\n        // loop over the data samples\n        this._buckets = [];\n        if (inputValues.length() === 0) {\n            return this._buckets;\n        }\n        var currentPoint;\n        var left = exports.findFirstInsertionIdx(inputValues, xStart);\n        var right = exports.findLastInsertionIdx(inputValues, xEnd);\n        if (left > 0) {\n            --left;\n        }\n        if (right < inputValues.length()) {\n            ++right;\n        }\n        var lastX = 0;\n        if (left < inputValues.length()) {\n            lastX = Math.floor(this._xValueToCoord(inputValues.get(left).x));\n            --lastX;\n        }\n        for (var index = left; index < right; ++index) {\n            var inputValue = inputValues.get(index);\n            var xCoord = Math.floor(this._xValueToCoord(inputValue.x));\n            if (xCoord !== lastX) {\n                if (currentPoint) {\n                    this.finalizeBucket(currentPoint);\n                    this._buckets.push(currentPoint);\n                }\n                currentPoint = new NEWSDecimationValue();\n                this.createNewBucket(currentPoint, inputValue);\n                lastX = xCoord;\n            }\n            else {\n                this.addToBucket(currentPoint, inputValue);\n            }\n        }\n        if (currentPoint) {\n            this.finalizeBucket(currentPoint);\n            this._buckets.push(currentPoint);\n        }\n        return this._buckets;\n    }; // decimateValues()\n    NEWSPointDecimator.KEY = 'NEWSPointDecimator';\n    return NEWSPointDecimator;\n}(NEWSBaseDecimator)); // class NEWSDecimator\nexports.NEWSPointDecimator = NEWSPointDecimator;\n/** this class takes a series x, y points and using for each X bucket provides\n * the Y entry/exit/min/max/average for that X bucket\n */\nvar NEWSStateDecimator = /** @class */ (function (_super) {\n    __extends(NEWSStateDecimator, _super);\n    function NEWSStateDecimator(states) {\n        var _this = _super.call(this) || this;\n        _this._weightedSums = {};\n        _this._prevX = 0;\n        _this._prevX = 0;\n        _this._key = NEWSStateDecimator.KEY;\n        if (states) {\n            _this._states = states;\n        }\n        return _this;\n    }\n    NEWSStateDecimator.prototype.createNewBucket = function (decimatedValue, value) {\n        this._weightedSums = {};\n        decimatedValue._bucketPts = 0;\n        var defaultValue;\n        if (!this._isYObject) {\n            defaultValue = value.y;\n            decimatedValue.y = defaultValue;\n            decimatedValue.entry = defaultValue;\n            decimatedValue.exit = defaultValue;\n            decimatedValue.min = defaultValue;\n            decimatedValue.max = defaultValue;\n        }\n        this.addToBucket(decimatedValue, value);\n    };\n    ;\n    NEWSStateDecimator.prototype.addToStateValueToBucket = function (state, value) {\n        if (value === 0) {\n            return;\n        }\n        if (!this._weightedSums[state]) {\n            this._weightedSums[state] = 0;\n        }\n        this._weightedSums[state] += value;\n    };\n    NEWSStateDecimator.prototype.addToBucket = function (decimatedValue, value) {\n        if (this._isYObject) {\n            if (this._states) {\n                // take prevX and currentX\n                for (var stateKey in value.y) {\n                    this.addToStateValueToBucket(this._states[stateKey], (value.x - this._prevX) * value.y[stateKey]);\n                }\n            }\n            else {\n                // take prevX and currentX\n                for (var state in value.y) {\n                    this.addToStateValueToBucket(state, (value.x - this._prevX) * value.y[state]);\n                }\n            }\n        }\n        else {\n            var state = void 0;\n            if (this._states) {\n                state = this._states[value.y];\n            }\n            else {\n                state = value.y;\n            }\n            decimatedValue.exit = state;\n            this.addToStateValueToBucket(state, (value.x - this._prevX));\n        }\n        decimatedValue.x += value.x;\n        decimatedValue._bucketPts++;\n        this._prevX = value.x;\n    };\n    NEWSStateDecimator.prototype.finalizeBucket = function (decimatedValue, pointsInBucket) {\n        if (undefined !== pointsInBucket) {\n            if (pointsInBucket !== decimatedValue._bucketPts) {\n                console.log(\"AverageTime: mismatching pt calculation\");\n            }\n        }\n        if (decimatedValue._bucketPts === 0) {\n            console.log(\"AverageTime: 0 points\");\n        }\n        decimatedValue.x = decimatedValue.x / decimatedValue._bucketPts;\n        // find the maximum value by weightedSums\n        var maxWeightedKey;\n        var maxWeightValue = -Number.MAX_VALUE;\n        var minState = -Number.MAX_VALUE;\n        var maxState = Number.MAX_VALUE;\n        for (var state in this._weightedSums) {\n            if (this._weightedSums[state] !== undefined) {\n                var stateWeight = this._weightedSums[state];\n                if (stateWeight > maxWeightValue) {\n                    maxWeightedKey = state;\n                    maxWeightValue = stateWeight;\n                }\n            }\n            // min is bigger since Y values increase as you go down the axis\n            var yOffset = this._yValueToCoord(state);\n            if (yOffset > minState) {\n                decimatedValue.min = state;\n                minState = yOffset;\n            }\n            if (yOffset < maxState) {\n                decimatedValue.max = state;\n                maxState = yOffset;\n            }\n        }\n        var hasValues = maxWeightedKey !== undefined;\n        if (hasValues) {\n            decimatedValue.y = maxWeightedKey;\n        }\n        else {\n            // no values so set a default a y value\n            if (!this._isYObject) {\n                decimatedValue.min = decimatedValue.y;\n                decimatedValue.max = decimatedValue.y;\n            }\n        }\n    }; // finalize );\n    /**\n     * Values to be decimated\n     *\n     * @param xStart - start time of the region\n     * @param xEnd - start time of the region\n     * @param values - Values to be decimated.\n     */\n    NEWSStateDecimator.prototype.decimateValues = function (xStart, xEnd, inputValues) {\n        // loop over the data samples\n        this._buckets = [];\n        if (inputValues.length() === 0) {\n            return this._buckets;\n        }\n        var currentPoint;\n        var left = exports.findFirstInsertionIdx(inputValues, xStart);\n        var right = exports.findLastInsertionIdx(inputValues, xEnd);\n        if (left > 0) {\n            --left;\n        }\n        if (right < inputValues.length()) {\n            ++right;\n        }\n        var lastX = 0;\n        if (left < inputValues.length()) {\n            this._isYObject = typeof (inputValues.get(left).y) === 'object';\n            lastX = Math.floor(this._xValueToCoord(inputValues.get(left).x));\n            --lastX;\n        }\n        for (var index = left; index < right; ++index) {\n            var inputValue = inputValues.get(index);\n            var xCoord = Math.floor(this._xValueToCoord(inputValue.x));\n            if (xCoord !== lastX) {\n                if (currentPoint) {\n                    this.finalizeBucket(currentPoint);\n                    this._buckets.push(currentPoint);\n                }\n                // add in buckets between the previous bucket and the new bucket since\n                // the state spans the whole time\n                if (lastX + 1 < xCoord) {\n                    var point = new NEWSDecimationValue();\n                    this.createNewBucket(point, inputValue);\n                    this.finalizeBucket(point);\n                    point.x = this._xCoordToValue(xCoord - 1);\n                    this._buckets.push(point);\n                    this._prevX = point.x;\n                }\n                currentPoint = new NEWSDecimationValue();\n                this.createNewBucket(currentPoint, inputValue);\n                lastX = xCoord;\n            }\n            else {\n                this.addToBucket(currentPoint, inputValue);\n            }\n        }\n        if (currentPoint) {\n            this.finalizeBucket(currentPoint);\n            this._buckets.push(currentPoint);\n        }\n        return this._buckets;\n    }; // decimateValues()\n    NEWSStateDecimator.KEY = 'NEWSStateDecimator';\n    return NEWSStateDecimator;\n}(NEWSBaseDecimator));\nexports.NEWSStateDecimator = NEWSStateDecimator;\n;\nvar FlameChartRectLimitDecimator = /** @class */ (function () {\n    function FlameChartRectLimitDecimator() {\n    }\n    FlameChartRectLimitDecimator.prototype.initialize = function (xValueToCoord, xCoordToValue, yValueToCoord) {\n        this._data = [];\n        this._xValueToCoord = xValueToCoord;\n        this._xCoordToValue = xCoordToValue;\n        this._yValueToCoord = yValueToCoord;\n    };\n    /**\n     * Returns the key of this decimator\n     */\n    FlameChartRectLimitDecimator.prototype.getKey = function () {\n        return FlameChartRectLimitDecimator.KEY;\n    };\n    /**\n     * the name of this decimation scheme\n     */\n    FlameChartRectLimitDecimator.prototype.getName = function () {\n        return '';\n    };\n    /**\n     * Returns the decimated list of data\n     */\n    FlameChartRectLimitDecimator.prototype.getValues = function () {\n        return this._data;\n    };\n    FlameChartRectLimitDecimator.prototype.setRectLimit = function (rectLimit) {\n        this._rectLimit = rectLimit;\n        return this;\n    };\n    /**\n     * Values to be decimated\n     *\n     * @param xStart - start time of the region\n     * @param xEnd - start time of the region\n     * @param values - Values to be decimated.\n     */\n    FlameChartRectLimitDecimator.prototype.decimateValues = function (xStart, xEnd, values) {\n        // using the whole view\n        this._data = values.getData();\n        if (this._rectLimit) {\n            this._data.sort(function (a, b) {\n                if (a.traceValue.dx > b.traceValue.dx) {\n                    return -1;\n                }\n                if (a.traceValue.dx < b.traceValue.dx) {\n                    return 1;\n                }\n                return 0;\n            });\n            this._data = this._data.splice(0, this._rectLimit);\n        }\n        return this._data;\n    };\n    FlameChartRectLimitDecimator.KEY = 'FlameChartRectLimitDecimator';\n    return FlameChartRectLimitDecimator;\n}());\nexports.FlameChartRectLimitDecimator = FlameChartRectLimitDecimator;\n;\n/** this decimator merges the rectangles in a flame chart to combine\n * identical rectangles that are touching on a left/right pixel basis so\n * we can merge them for rendering\n */\nvar FlameChartMergeRectDecimator = /** @class */ (function () {\n    function FlameChartMergeRectDecimator() {\n        this._minRectDelta = 1;\n    }\n    FlameChartMergeRectDecimator.prototype.initialize = function (xValueToCoord, xCoordToValue, yValueToCoord) {\n        this._data = [];\n        this._xValueToCoord = xValueToCoord;\n        this._xCoordToValue = xCoordToValue;\n        this._yValueToCoord = yValueToCoord;\n    };\n    /**\n     * Returns the key of this decimator\n     */\n    FlameChartMergeRectDecimator.prototype.getKey = function () {\n        return FlameChartMergeRectDecimator.KEY;\n    };\n    /**\n     * the name of this decimation scheme\n     */\n    FlameChartMergeRectDecimator.prototype.getName = function () {\n        return '';\n    };\n    /**\n     * Returns the decimated list of data\n     */\n    FlameChartMergeRectDecimator.prototype.getValues = function () {\n        return this._data;\n    };\n    FlameChartMergeRectDecimator.prototype.setPixelWidth = function (width) {\n        this._minRectDelta = width - 1;\n        return this;\n    };\n    /**\n     * used to generate a list of all rects that could be drawn sorted by duration\n     */\n    FlameChartMergeRectDecimator.prototype.mergeRects = function (values) {\n        var len = values.length;\n        var ret = [];\n        var prevValueByDepth = [];\n        var prevXCoordbyDepth = [];\n        // compute rects\n        for (var i = 0; i < len; i++) {\n            var value = values[i];\n            if (prevValueByDepth.length < value.depth) {\n                prevValueByDepth.length = value.depth;\n                prevXCoordbyDepth.length = value.depth;\n            }\n            // first check if you need to merge with a previous rectangle of this depth\n            var prevValue = prevValueByDepth[value.depth];\n            if (prevValue && prevValue.traceValue.key === value.traceValue.key &&\n                prevValue.traceValue.x + prevValue.traceValue.dx === value.traceValue.x) {\n                prevValue.traceValue.dx += value.traceValue.dx;\n            }\n            else {\n                // might have to merge things with subpixel accuracy\n                var startTime = values[i].traceValue.x;\n                var subpixelMap = {};\n                var valueList = [];\n                // before adding the next item iterate to a point where the next\n                // value starts in the next pixel for the given depth`\n                for (; i < len; ++i) {\n                    value = values[i];\n                    valueList.push(value.traceValue);\n                    if (prevValueByDepth.length <= value.depth) {\n                        prevValueByDepth.length = value.depth + 1;\n                        prevXCoordbyDepth.length = value.depth + 1;\n                        break;\n                    }\n                    else {\n                        var endCurrX = Math.round(this._xValueToCoord(value.traceValue.x + value.traceValue.dx));\n                        if (endCurrX > prevXCoordbyDepth[value.depth] + this._minRectDelta) {\n                            break;\n                        }\n                        else {\n                            // if we have multiple items in the end pixel add up the\n                            // the durations and find the one with the most weight\n                            if (!subpixelMap.hasOwnProperty[value.traceValue.name]) {\n                                subpixelMap[value.traceValue.name] = 0;\n                            }\n                            subpixelMap[value.traceValue.name] += value.traceValue.dx;\n                            // update the previous value as we iterate\n                            prevValue = value;\n                        }\n                    }\n                }\n                var fcValue = void 0;\n                if (Object.keys(subpixelMap).length === 0) {\n                    // if we have just one item just add it to the trace\n                    fcValue = {\n                        traceValue: {\n                            x: value.traceValue.x,\n                            dx: value.traceValue.dx,\n                            key: value.traceValue.key,\n                            name: value.traceValue.name,\n                            desc: value.traceValue.desc,\n                        },\n                        decimatedValues: valueList,\n                        depth: value.depth\n                    };\n                }\n                else {\n                    // find the subpixel value with the most weight\n                    var pixelName = void 0;\n                    var max = 0;\n                    for (var name_1 in subpixelMap) {\n                        var groupWeight = subpixelMap[name_1];\n                        if (groupWeight > max) {\n                            pixelName = name_1;\n                            max = groupWeight;\n                        }\n                    }\n                    fcValue = {\n                        traceValue: {\n                            x: startTime,\n                            dx: prevValue.traceValue.x + prevValue.traceValue.dx - startTime,\n                            key: 'merged',\n                            name: pixelName,\n                            desc: prevValue.traceValue.desc,\n                        },\n                        decimatedValues: valueList,\n                        depth: value.depth\n                    };\n                    // we back up to the last item tthat broke the subpixel iteration loop\n                    --i;\n                }\n                ret.push(fcValue);\n                // update the last value for this level\n                var lastX = Math.round(this._xValueToCoord(fcValue.traceValue.x + fcValue.traceValue.dx));\n                prevValueByDepth[value.depth] = fcValue;\n                prevXCoordbyDepth[value.depth] = lastX;\n            }\n        }\n        return ret;\n    };\n    /**\n     * Values to be decimated\n     *\n     * @param xStart - start time of the region\n     * @param xEnd - start time of the region\n     * @param values - Values to be decimated.\n     */\n    FlameChartMergeRectDecimator.prototype.decimateValues = function (xStart, xEnd, values) {\n        var allData = values.getData();\n        // using the whole view\n        if (xStart !== undefined && xEnd !== undefined) {\n            var filteredData = [];\n            for (var i = 0; i < allData.length; ++i) {\n                var fcValue = allData[i];\n                var rectEnd = fcValue.traceValue.x + fcValue.traceValue.dx;\n                if (rectEnd > xStart && fcValue.traceValue.x < xEnd) {\n                    filteredData.push(fcValue);\n                }\n            }\n            this._data = this.mergeRects(filteredData);\n        }\n        else {\n            this._data = this.mergeRects(allData);\n        }\n        return this._data;\n    };\n    FlameChartMergeRectDecimator.KEY = 'FlameChartMergeRectDecimator';\n    return FlameChartMergeRectDecimator;\n}());\nexports.FlameChartMergeRectDecimator = FlameChartMergeRectDecimator;\n;\n/**\n * Takes ITraceValue data and for each bucket returns a residency value\n * by ITracevalue.name. This means the sum of all values within an output bucket is 100.\n */\nvar TraceResidencyDecimator = /** @class */ (function () {\n    function TraceResidencyDecimator() {\n    }\n    TraceResidencyDecimator.prototype.initialize = function (xValueToCoord, xCoordToValue, yValueToCoord, states) {\n        this._decimatedValues = [];\n        this._xValueToCoord = xValueToCoord;\n        this._xCoordToValue = xCoordToValue;\n        this._yValueToCoord = yValueToCoord;\n        this._states = states;\n    };\n    /**\n     * Returns the key of this decimator\n     */\n    TraceResidencyDecimator.prototype.getKey = function () {\n        return TraceResidencyDecimator.KEY;\n    };\n    /**\n     * the name of this decimation scheme\n     */\n    TraceResidencyDecimator.prototype.getName = function () {\n        return '';\n    };\n    /**\n     * Returns the decimated list of data\n     */\n    TraceResidencyDecimator.prototype.getValues = function () {\n        return this._decimatedValues;\n    };\n    /**\n   * Values to be decimated\n   *\n   * @param xStart - start time of the region\n   * @param xEnd - start time of the region\n   * @param values - Values to be decimated.\n   */\n    TraceResidencyDecimator.prototype.decimateValues = function (xStart, xEnd, values) {\n        this._decimatedValues = new Array(this._states.length).fill(0).map(function () { return new Array(); });\n        var globalStartBucket = 0;\n        var globalEndBucket = Math.ceil(this._xValueToCoord(Number.MAX_VALUE));\n        if (globalEndBucket < globalStartBucket) {\n            return undefined;\n        }\n        // this is total weighted sum for each state per x, then used to store percentage per x\n        var tempValues = {};\n        // map states to return index\n        var stateMap = {};\n        this._states.forEach(function (state, index) {\n            stateMap[state] = index;\n            tempValues[state] = Array.apply(null, Array(globalEndBucket)).\n                map(Number.prototype.valueOf, 0);\n        });\n        // set up the values for iteration\n        // for a series get the weighted sum for the number of buckets xStart to xEnd\n        var value;\n        var traceEndX;\n        var start = exports.findFirstInsertionIdx(values, xStart);\n        var end = exports.findLastInsertionIdx(values, xEnd);\n        if (start > 0) {\n            --start;\n        }\n        // the last element would be caught by the algorithm already\n        if (end === values.length()) {\n            --end;\n        }\n        // NOTE: I do this up here so I can cheat and use the x values here\n        // so later I don't keep calling this._xCoordToValue\n        var xBucketValues = [];\n        for (var bucket = 0; bucket <= globalEndBucket; ++bucket) {\n            xBucketValues.push(this._xCoordToValue(bucket));\n        }\n        // this is the amount of x values within a given bucket\n        var bucketScalar = 1 / (xBucketValues[globalStartBucket + 1] - xBucketValues[globalStartBucket]);\n        // get weighted sum of the values for each bucket\n        // note this is forward looking data unlike most of our data so\n        // the algorithm is a little different\n        for (var rawDataIdx = start; rawDataIdx < end; ++rawDataIdx) {\n            value = values.get(rawDataIdx);\n            traceEndX = value.x + value.dx;\n            var startBucket = Math.floor(this._xValueToCoord(value.x));\n            var endBucket = Math.floor(this._xValueToCoord(traceEndX));\n            if (startBucket === endBucket) {\n                tempValues[value.name][startBucket] += value.dx * bucketScalar;\n                // TODO consider we should/can fix this corner case\n                // Code below is technically more correct as it handles some edge cases\n                // but it's about 3x slower?\n                // if (xStart === undefined || (value.x > xStart && traceEndX < xEnd)) {\n                //     // here it's all in the existing bucket\n                //     tempValues[value.name][startBucket] += value.dx * bucketScalar;\n                // } else if (traceEndX > xStart) {\n                //     if (traceEndX < xEnd) {\n                //         // here the back half is in the bucket\n                //         tempValues[value.name][startBucket] += (traceEndX - xStart) * bucketScalar;\n                //     } else {\n                //         // here the front half is in the bucket\n                //         tempValues[value.name][startBucket] += (xEnd - value.x) * bucketScalar;\n                //     }\n                // }\n            }\n            else {\n                // add in start bucket amount\n                var startX = xStart ? Math.max(xStart, value.x) : value.x;\n                var endStartBucket = xBucketValues[startBucket + 1];\n                tempValues[value.name][startBucket] = (endStartBucket - startX) * bucketScalar;\n                // add in all the bucket values in between\n                for (var currBucket = startBucket + 1; currBucket < endBucket - 1; ++currBucket) {\n                    tempValues[value.name][currBucket] += 1;\n                }\n                // add in end bucket amount\n                var endX = xEnd ? Math.min(xEnd, traceEndX) : traceEndX;\n                var startEndBucket = xBucketValues[endBucket];\n                tempValues[value.name][endBucket - 1] = (endX - startEndBucket) * bucketScalar;\n            }\n        }\n        // create an array that is used when this state wasn't seen at\n        // all in the time region.\n        var emptyArray = [];\n        for (var bucket = 0; bucket < globalEndBucket; ++bucket) {\n            emptyArray[bucket] = {\n                x: xBucketValues[bucket],\n                y: 0\n            };\n        }\n        for (var stateIdx = 0; stateIdx < this._states.length; ++stateIdx) {\n            var buckets = tempValues[this._states[stateIdx]];\n            if (buckets) {\n                for (var bucket = 0; bucket < buckets.length; ++bucket) {\n                    this._decimatedValues[stateIdx][bucket] = {\n                        x: xBucketValues[bucket],\n                        y: tempValues[this._states[stateIdx]][bucket] * 100\n                    };\n                }\n            }\n            else {\n                this._decimatedValues[stateIdx] = emptyArray;\n            }\n        }\n        return this._decimatedValues;\n    };\n    TraceResidencyDecimator.KEY = 'TraceResidencyDecimator';\n    return TraceResidencyDecimator;\n}());\nexports.TraceResidencyDecimator = TraceResidencyDecimator;\n;\n/**\n* Takes ITraceValue data and for each bucket returns a sum by ITracevalue.name.\n* This means the sum of all values within an output bucket is 100.\n*/\nvar TraceStateDecimator = /** @class */ (function () {\n    function TraceStateDecimator() {\n    }\n    TraceStateDecimator.prototype.initialize = function (xValueToCoord, xCoordToValue, yValueToCoord, states) {\n        this._decimatedValues = [];\n        this._xValueToCoord = xValueToCoord;\n        this._xCoordToValue = xCoordToValue;\n        this._yValueToCoord = yValueToCoord;\n        this._states = states;\n    };\n    /**\n     * Returns the key of this decimator\n     */\n    TraceStateDecimator.prototype.getKey = function () {\n        return TraceResidencyDecimator.KEY;\n    };\n    /**\n     * the name of this decimation scheme\n     */\n    TraceStateDecimator.prototype.getName = function () {\n        return '';\n    };\n    /**\n     * Returns the decimated list of data\n     */\n    TraceStateDecimator.prototype.getValues = function () {\n        return this._decimatedValues;\n    };\n    /**\n   * Values to be decimated\n   *\n   * @param xStart - start time of the region\n   * @param xEnd - start time of the region\n   * @param values - Values to be decimated.\n   */\n    TraceStateDecimator.prototype.decimateValues = function (xStart, xEnd, values) {\n        var _this = this;\n        var globalStartBucket = 0;\n        var globalEndBucket = Math.ceil(this._xValueToCoord(Number.MAX_VALUE));\n        if (globalEndBucket < globalStartBucket) {\n            return undefined;\n        }\n        // set up the values for iteration\n        // for a series get the weighted sum for the number of buckets xStart to xEnd\n        var value;\n        var traceEndX;\n        var start = exports.findFirstInsertionIdx(values, xStart);\n        var end = exports.findLastInsertionIdx(values, xEnd);\n        if (start > 0) {\n            --start;\n        }\n        // the last element would be caught by the algorithm already\n        if (end === values.length()) {\n            --end;\n        }\n        // NOTE: I do this up here so I can cheat and use the x values here\n        // so later I don't keep calling this._xCoordToValue\n        var xBucketValues = [];\n        for (var bucket = 0; bucket <= globalEndBucket; ++bucket) {\n            xBucketValues.push(this._xCoordToValue(bucket));\n        }\n        this._decimatedValues = Array.apply(null, Array(globalEndBucket)).\n            map(function () { return new NEWSDecimationValue(); });\n        var states = {};\n        this._states.forEach(function (state, i) {\n            states[state] = i;\n        });\n        // store the entry/exit/min/max of each bucket\n        // min and max are based on the state index\n        for (var rawDataIdx = start; rawDataIdx < end; ++rawDataIdx) {\n            value = values.get(rawDataIdx);\n            traceEndX = value.x + value.dx;\n            var startBucket = Math.floor(this._xValueToCoord(value.x));\n            var endBucket = Math.floor(this._xValueToCoord(traceEndX));\n            if (!this._decimatedValues[startBucket].entry) {\n                this._decimatedValues[startBucket].x = xBucketValues[startBucket];\n                this._decimatedValues[startBucket].entry = states[value.name];\n                this._decimatedValues[startBucket].exit = states[value.name];\n                this._decimatedValues[startBucket].min = states[value.name];\n                this._decimatedValues[startBucket].max = states[value.name];\n            }\n            if (startBucket === endBucket) {\n                this._decimatedValues[startBucket].exit = states[value.name];\n                this._decimatedValues[startBucket].min =\n                    Math.min(this._decimatedValues[startBucket].min, states[value.name]);\n                this._decimatedValues[startBucket].max =\n                    Math.max(this._decimatedValues[startBucket].max, states[value.name]);\n            }\n            else {\n                // start bucket exit\n                this._decimatedValues[startBucket].exit = states[value.name];\n                this._decimatedValues[startBucket].min =\n                    Math.min(this._decimatedValues[startBucket].min, states[value.name]);\n                this._decimatedValues[startBucket].max =\n                    Math.max(this._decimatedValues[startBucket].max, states[value.name]);\n                // add in all the bucket values in between\n                if (endBucket !== globalEndBucket) {\n                    for (var currBucket = startBucket + 1; currBucket <= endBucket; ++currBucket) {\n                        this._decimatedValues[currBucket].x = xBucketValues[currBucket];\n                        this._decimatedValues[currBucket].entry = states[value.name];\n                        this._decimatedValues[currBucket].exit = states[value.name];\n                        this._decimatedValues[currBucket].min = states[value.name];\n                        this._decimatedValues[currBucket].max = states[value.name];\n                    }\n                }\n            }\n        }\n        // convert state index to actual state names for rendering\n        this._decimatedValues.forEach(function (newsValue) {\n            newsValue.entry = _this._states[newsValue.entry];\n            newsValue.exit = _this._states[newsValue.exit];\n            newsValue.min = _this._states[newsValue.min];\n            newsValue.max = _this._states[newsValue.max];\n        });\n        return this._decimatedValues;\n    };\n    TraceStateDecimator.KEY = 'TraceStateDecimator';\n    return TraceStateDecimator;\n}());\nexports.TraceStateDecimator = TraceStateDecimator;\n;\n/**\n * For a marker layer just removes markers that have the same X value\n */\nvar SimpleMarkerDecimator = /** @class */ (function () {\n    function SimpleMarkerDecimator() {\n    }\n    SimpleMarkerDecimator.prototype.initialize = function (xValueToCoord, xCoordToValue, yValueToCoord) {\n        this._data = [];\n        this._xValueToCoord = xValueToCoord;\n        this._xCoordToValue = xCoordToValue;\n        this._yValueToCoord = yValueToCoord;\n    };\n    /**\n     * Returns the key of this decimator\n     */\n    SimpleMarkerDecimator.prototype.getKey = function () {\n        return SimpleMarkerDecimator.KEY;\n    };\n    /**\n     * the name of this decimation scheme\n     */\n    SimpleMarkerDecimator.prototype.getName = function () {\n        return '';\n    };\n    /**\n     * Returns the decimated list of data\n     */\n    SimpleMarkerDecimator.prototype.getValues = function () {\n        return this._data;\n    };\n    SimpleMarkerDecimator.prototype.mergeMarkers = function (values) {\n        var _this = this;\n        var ret = [];\n        var lastCoord = -Number.MAX_VALUE;\n        values.forEach(function (value) {\n            var coord = _this._xValueToCoord(value.x);\n            if (coord !== lastCoord) {\n                ret.push(value);\n                lastCoord = coord;\n            }\n        });\n        return ret;\n    };\n    /**\n     * Values to be decimated\n     *\n     * @param xStart - start time of the region\n     * @param xEnd - start time of the region\n     * @param values - Values to be decimated.\n     */\n    SimpleMarkerDecimator.prototype.decimateValues = function (xStart, xEnd, values) {\n        var allData = values.getData();\n        // using the whole view\n        if (xStart !== undefined && xEnd !== undefined) {\n            var filteredData_1 = [];\n            allData.forEach(function (value) {\n                if (value.x < xEnd && value.x > xStart) {\n                    filteredData_1.push(value);\n                }\n                else if (value.dx && value.x + value.dx < xEnd &&\n                    value.x + value.dx > xStart) {\n                    filteredData_1.push(value);\n                }\n            });\n            this._data = this.mergeMarkers(filteredData_1);\n        }\n        else {\n            this._data = this.mergeMarkers(allData);\n        }\n        return this._data;\n    };\n    SimpleMarkerDecimator.KEY = 'SimpleMarkerDecimator';\n    return SimpleMarkerDecimator;\n}());\nexports.SimpleMarkerDecimator = SimpleMarkerDecimator;\n;\n/** */\nvar XYHeatMapDecimator = /** @class */ (function () {\n    function XYHeatMapDecimator() {\n    }\n    /**\n     * construct a generic decimator using a custom user function\n     *\n     * @param xValueToCoord converts the x value to a GUI x coordinate\n     * @param yValueToCoord converts the y value to a GUI y coordinate\n     * @param decimationFunc convert a list of data to a for rendering smaller list\n     */\n    XYHeatMapDecimator.prototype.initialize = function (xValueToCoord, xCoordToValue, yValueToCoord) {\n        this._xValueToCoord = xValueToCoord;\n        this._xCoordToValue = xCoordToValue;\n        this._yValueToCoord = yValueToCoord;\n    };\n    /**\n     * Returns the key of this decimator\n     */\n    XYHeatMapDecimator.prototype.getKey = function () {\n        return SummedValueMultiXYSeriesDecimator.KEY;\n    };\n    /**\n     * Returns the decimated list of buckets\n     */\n    XYHeatMapDecimator.prototype.getName = function () {\n        return '';\n    };\n    /**\n     * Returns the decimated list of buckets\n     */\n    XYHeatMapDecimator.prototype.getValues = function () {\n        return this._decimatedValues;\n    };\n    /**\n     * Values to be decimated\n     *\n     * @param xStart - start time of the region\n     * @param xEnd - start time of the region\n     * @param values - Values to be decimated.\n     */\n    XYHeatMapDecimator.prototype.decimateValues = function (xStart, xEnd, values) {\n        this._decimatedValues = [];\n        // first this is total weighted sum per x, then used to store percentage per x\n        var tempValues = [];\n        var globalStartBucket = 0;\n        var globalEndBucket = Math.ceil(this._xValueToCoord(Number.MAX_VALUE));\n        if (globalEndBucket < globalStartBucket) {\n            return undefined;\n        }\n        // NOTE: I do this up here so I can cheat and use the x values here\n        // so later I don't keep calling _xCoordToValue\n        var xBucketValues = [];\n        for (var bucket = 0; bucket <= globalEndBucket + 1; ++bucket) {\n            xBucketValues.push(this._xCoordToValue(bucket));\n        }\n        // for a series get the weighted sum for the number of buckets xStart to xEnd\n        for (var stateIdx = 0; stateIdx < values.length; ++stateIdx) {\n            var perStateData = values[stateIdx];\n            var value = void 0;\n            var nextValue = void 0;\n            var start = exports.findFirstInsertionIdx(values[stateIdx], xStart);\n            var end = exports.findLastInsertionIdx(values[stateIdx], xEnd);\n            if (start > 0) {\n                --start;\n            }\n            // the last element would be caught by the algorithm already\n            if (end === perStateData.length()) {\n                --end;\n            }\n            // pad endBucket + 1 so we get data past the last point in the bucket\n            // so we can graph to the first value in the next bucket\n            tempValues[stateIdx] = Array.apply(null, Array(globalEndBucket)).\n                map(Number.prototype.valueOf, 0);\n            // get weighted sum of the values for each bucket\n            for (var rawDataIdx = start; rawDataIdx < end; ++rawDataIdx) {\n                value = perStateData.get(rawDataIdx);\n                nextValue = perStateData.get(rawDataIdx + 1);\n                var startBucket = Math.floor(this._xValueToCoord(value.x));\n                var endBucket = Math.floor(this._xValueToCoord(nextValue.x));\n                var totalX = (nextValue.x - value.x);\n                var valuePerX = totalX === 0 ? 0 : nextValue.y / totalX;\n                if (startBucket === endBucket) {\n                    if (xStart === undefined || (value.x > xStart && nextValue.x < xEnd)) {\n                        // here it's all in the existing bucket\n                        tempValues[stateIdx][startBucket] += valuePerX;\n                    }\n                    else {\n                        var bucketScalar = 1 / (xBucketValues[startBucket + 1] - xBucketValues[startBucket]);\n                        if (nextValue.x < xEnd) {\n                            // here the back half is in the bucket\n                            tempValues[stateIdx][startBucket] +=\n                                (nextValue.x - xBucketValues[startBucket]) * valuePerX * bucketScalar;\n                        }\n                        else {\n                            // here the front half is in the bucket\n                            tempValues[stateIdx][startBucket] +=\n                                (xBucketValues[startBucket + 1] - value.x) * valuePerX * bucketScalar;\n                        }\n                    }\n                }\n                else {\n                    var bucketScalar = 1 / (xBucketValues[startBucket + 1] - xBucketValues[startBucket]);\n                    var startX = xStart ? Math.max(xStart, value.x) : value.x;\n                    var endStartBucket = xBucketValues[startBucket + 1];\n                    tempValues[stateIdx][startBucket] +=\n                        (endStartBucket - startX) * valuePerX * bucketScalar;\n                    // add in all the bucket values in between\n                    for (var currBucket = startBucket + 1; currBucket < endBucket; ++currBucket) {\n                        tempValues[stateIdx][currBucket] += valuePerX;\n                    }\n                    // add in end bucket amount\n                    bucketScalar = 1 / (xBucketValues[endBucket] - xBucketValues[endBucket - 1]);\n                    var endX = xEnd ? Math.min(xEnd, nextValue.x) : nextValue.x;\n                    var startEndBucket = xBucketValues[endBucket];\n                    tempValues[stateIdx][endBucket] +=\n                        (endX - startEndBucket) * valuePerX * bucketScalar;\n                }\n            }\n            this._decimatedValues[stateIdx] = [];\n            var buckets = tempValues[stateIdx];\n            for (var bucket = 0; bucket < buckets.length; ++bucket) {\n                this._decimatedValues[stateIdx][bucket] = {\n                    x: xBucketValues[bucket],\n                    y: tempValues[stateIdx][bucket]\n                };\n            }\n        }\n        return this._decimatedValues;\n    };\n    XYHeatMapDecimator.KEY = 'SummedValueMultiXYSeriesDecimator';\n    return XYHeatMapDecimator;\n}());\nexports.XYHeatMapDecimator = XYHeatMapDecimator;\n;\nvar decimatorList = [\n    new ResidencyDecimator(), new MinPointDecimator(),\n    new AvgPointDecimator(), new MaxPointDecimator(), new AvgContinuousDecimator(),\n    new FlameChartMergeRectDecimator(), new FlameChartRectLimitDecimator(),\n    new NEWSPointDecimator(), new NEWSStateDecimator(), new SimpleMarkerDecimator(),\n    new XYPointDecimator(), new SummedValueXYSeriesDecimator(),\n    new SummedValueMultiXYSeriesDecimator(), new TraceResidencyDecimator()\n];\nexports.InternalDecimatorMap = {};\ndecimatorList.forEach(function (decimator) {\n    exports.InternalDecimatorMap[decimator.getKey()] = decimator;\n});\n\n\n//# sourceURL=webpack://UWT/./src/core/cartesian/decimator/decimator.ts?");

/***/ }),

/***/ "./src/core/cartesian/decimator/worker.ts":
/*!************************************************!*\
  !*** ./src/core/cartesian/decimator/worker.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar chart_1 = __webpack_require__(/*! ../../../interface/chart/chart */ \"./src/interface/chart/chart.ts\");\nvar utilities_1 = __webpack_require__(/*! ../../utilities */ \"./src/core/utilities.ts\");\nvar decimator_1 = __webpack_require__(/*! ./decimator */ \"./src/core/cartesian/decimator/decimator.ts\");\nvar d3 = __webpack_require__(/*! d3 */ \"d3\");\n// Worker.ts\nvar ctx = self;\n// Respond to message from parent thread\nctx.addEventListener(\"message\", function (message) {\n    var xScale;\n    var yScale;\n    var def = message.data;\n    if (def.xAxis.axisDesc.scaleType === chart_1.AxisType.Ordinal) {\n        xScale = d3.scaleBand().range([0, def.xRange]).padding(0.1)\n            .align(0.5).domain(def.xDomain);\n    }\n    else {\n        if (def.xAxis.axisDesc.scaleType === chart_1.AxisType.Linear) {\n            xScale = d3.scaleLinear().domain(def.xDomain).clamp(true);\n        }\n        else if (def.xAxis.axisDesc.scaleType === chart_1.AxisType.Logarithmic) {\n            xScale = d3.scaleLog().domain(def.xDomain).clamp(true);\n        }\n        xScale.range([0, def.xRange]);\n    }\n    if (def.yAxis) {\n        if (def.yAxis.axisDesc.scaleType === chart_1.AxisType.Ordinal) {\n            yScale = d3.scaleBand().range([0, def.yRange]).padding(0.1)\n                .align(0.5).domain(def.yDomain);\n        }\n        else {\n            if (def.yAxis.axisDesc.scaleType === chart_1.AxisType.Linear) {\n                yScale = d3.scaleLinear().domain(def.yDomain).clamp(true);\n            }\n            else if (def.yAxis.axisDesc.scaleType === chart_1.AxisType.Logarithmic) {\n                yScale = d3.scaleLog().domain(def.yDomain).clamp(true);\n            }\n            yScale.range([def.yRange, 0]);\n        }\n    }\n    var decimator = decimator_1.InternalDecimatorMap[def.decimatorName];\n    decimator.initialize(xScale, xScale.invert, yScale, def.names);\n    // ugly hardcode for now\n    var values;\n    if (!def.names) {\n        values = new utilities_1.SimpleBuffer(def.values);\n    }\n    else {\n        values = [];\n        for (var i = 0; i < def.values.length; ++i) {\n            values[i] = new utilities_1.SimpleBuffer(def.values[i]);\n        }\n    }\n    var data = decimator.decimateValues(def.xStart, def.xEnd, values);\n    ctx.postMessage(data, undefined);\n});\n\n\n//# sourceURL=webpack://UWT/./src/core/cartesian/decimator/worker.ts?");

/***/ }),

/***/ "./src/core/data.ts":
/*!**************************!*\
  !*** ./src/core/data.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n* XYValue\n*\n* Class for simple data that will be rendered as part of a chart\n*/\nvar XYValue = /** @class */ (function () {\n    /**\n     * Creates a XYValue instance\n     *\n     * @param x the independent axis coordinate\n     * @param y the dependent axis coordinate\n     */\n    function XYValue(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    return XYValue;\n}()); // XYValue\nexports.XYValue = XYValue;\n/**\n * MinMaxValue\n *\n * Class for candlestick data that will be rendered as part of a chart\n */\nvar MinMaxValue = /** @class */ (function () {\n    /**\n     * Creates a MinMaxValue instance\n     *\n     * @param key - the axis co-ordinate which will be x co-ordinate\n     * @param min - the minimum value of metric for the axis co-ordinate\n     * @param max - the maximum value of metric for the axis co-ordinate\n     * @param misc - a misc value of metric for the axis co-ordinate\n     */\n    function MinMaxValue(x, min, max, misc) {\n        this.x = x;\n        this.min = min;\n        this.max = max;\n        this.y = misc;\n    }\n    return MinMaxValue;\n}()); // MinMaxValue\nexports.MinMaxValue = MinMaxValue;\n/**\n * CandlestickValue\n *\n * Class for candlestick data that will be rendered as part of a chart\n */\nvar CandlestickValue = /** @class */ (function () {\n    /**\n     * Creates a CandlestickValue instance\n     *\n     * @param x - the axis co-ordinate which will be x co-ordinate\n     * @param min - the minimum value of metric for the axis co-ordinate\n     * @param max - the maximum value of metric for the axis co-ordinate\n     * @param entry - the entry value of metric for the axis co-ordinate\n     * @param exit - the exit value of metric for the axis co-ordinate\n     */\n    function CandlestickValue(x, min, max, entry, exit) {\n        this.x = x;\n        this.min = min;\n        this.max = max;\n        this.entry = entry;\n        this.exit = exit;\n    }\n    return CandlestickValue;\n}()); // CandlestickValue\nexports.CandlestickValue = CandlestickValue;\n/**\n * SummaryValue class\n */\nvar SummaryValue = /** @class */ (function () {\n    /**\n     * SummaryValue class\n     *\n     * @param primaryKey - key for the data\n     * @param value - value for this key\n     * @param secondaryKey - optional secondary key for the data\n     */\n    function SummaryValue(key, value) {\n        if (value === void 0) { value = {}; }\n        this.key = key;\n        this.data = value;\n    }\n    /**\n     * Value getter\n     *\n     * @returns add a value to this key\n     */\n    SummaryValue.prototype.addValue = function (key, value) {\n        var data = this.data;\n        if (data.hasOwnProperty(key)) {\n            data[key] += value;\n        }\n        else {\n            data[key] = value;\n        }\n        return this;\n    };\n    return SummaryValue;\n}()); // class SummaryValue\nexports.SummaryValue = SummaryValue;\n\n\n//# sourceURL=webpack://UWT/./src/core/data.ts?");

/***/ }),

/***/ "./src/core/utilities.ts":
/*!*******************************!*\
  !*** ./src/core/utilities.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getSelectionName(className) {\n    if (typeof (className) === 'number') {\n        return 'n' + className;\n    }\n    if (!className) {\n        return '';\n    }\n    if (className.length > 0 && !isNaN(Number(className[0]))) {\n        className = 'z' + className;\n    }\n    className = className.replace(/[\\*\\%\\#\\[\\]\\/\\>\\<\\s\\+\\(\\)\\;\\@\\:\\?\\\"=.,]/g, '-');\n    return className;\n}\nexports.getSelectionName = getSelectionName;\n/**\n* detect IE\n* returns version of IE or false, if browser is not Internet Explorer\n*/\n// from https://codepen.io/gapcode/pen/vEJNZN\nfunction detectIE() {\n    var ua = window.navigator.userAgent;\n    // Test values; Uncomment to check result \n    // IE 10\n    // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n    // IE 11\n    // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n    // Edge 12 (Spartan)\n    // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n    // Edge 13\n    // ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586';\n    var msie = ua.indexOf('MSIE ');\n    if (msie > 0) {\n        // IE 10 or older => return version number\n        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n    }\n    var trident = ua.indexOf('Trident/');\n    if (trident > 0) {\n        // IE 11 => return version number\n        var rv = ua.indexOf('rv:');\n        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n    }\n    var edge = ua.indexOf('Edge/');\n    if (edge > 0) {\n        // Edge (IE 12+) => return version number\n        return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n    }\n    // other browser\n    return false;\n}\nexports.detectIE = detectIE;\n// from https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent\n// polyfill for old version of IE\nfunction useIEPolyfill(window) {\n    try {\n        new CustomEvent('test'); // No need to polyfill\n    }\n    catch (e) {\n        // Polyfills DOM4 CustomEvent\n        var MouseEvent_1 = function (eventType, params) {\n            params = params || { bubbles: false, cancelable: false };\n            var mouseEvent = document.createEvent('MouseEvent');\n            mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n            return mouseEvent;\n        };\n        MouseEvent_1.prototype = Event.prototype;\n        window.MouseEvent = MouseEvent_1;\n    }\n}\nexports.useIEPolyfill = useIEPolyfill;\nfunction removeFromList(value, arr) {\n    if (value) {\n        var index = arr.indexOf(value);\n        if (index !== -1) {\n            arr.splice(index, 1);\n        }\n    }\n}\nexports.removeFromList = removeFromList;\n/** taken from d3-array */\nfunction ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n/** taken from d3-array */\nfunction ascendingComparator(f) {\n    return function (d, x) {\n        return ascending(f(d), x);\n    };\n}\n/** modified from d3-array */\nfunction bisect(compare) {\n    if (!compare)\n        compare = ascending;\n    if (compare.length === 1)\n        compare = ascendingComparator(compare);\n    return {\n        left: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length;\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a[mid], x) < 0)\n                    lo = mid + 1;\n                else\n                    hi = mid;\n            }\n            return lo;\n        },\n        right: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length;\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a[mid], x) > 0)\n                    hi = mid;\n                else\n                    lo = mid + 1;\n            }\n            return lo;\n        }\n    };\n}\nexports.bisect = bisect;\n/** puts all raw data into buckets based on thresholds and values */\nfunction bucketData(values, thresholds, accessor) {\n    var findRight = bisect().right;\n    var buckets = [];\n    // need one less bucket than thresholds\n    for (var i = 0; i < thresholds.length - 1; ++i) {\n        buckets[i] = [];\n    }\n    var min = thresholds[0];\n    var max = thresholds[thresholds.length - 1];\n    var usedThresholds = thresholds.slice(1);\n    for (var i = 0; i < values.length; ++i) {\n        var compareValue = accessor(values[i]);\n        if (compareValue < min || compareValue > max) {\n            continue;\n        }\n        var valueIdx = findRight(usedThresholds, compareValue);\n        buckets[valueIdx].push(values[i]);\n    }\n    // name the return buckets\n    var ret = {};\n    for (var i = 0; i < thresholds.length - 1; ++i) {\n        var bucketName = thresholds[i] + '-' + thresholds[i + 1];\n        ret[bucketName] = buckets[i];\n    }\n    return ret;\n}\nexports.bucketData = bucketData;\nfunction copy(obj) {\n    var ret = {};\n    for (var key in obj) {\n        ret[key] = obj[key];\n    }\n    return ret;\n}\nexports.copy = copy;\nfunction merge(obj1, obj2) {\n    for (var key in obj2) {\n        obj1[key] = obj2[key];\n    }\n}\nexports.merge = merge;\nfunction convertTraceToTrees(input) {\n    var roots = [];\n    var stack = []; // used to represent the current stack state\n    var nodeStack = []; // used to represent the current stack state\n    for (var i = 0; i < input.length; i++) {\n        var value = input[i];\n        var parent_1 = stack[stack.length - 1];\n        // pop stuff off the stack\n        while (stack.length && value.x > parent_1.x + parent_1.dx) {\n            --stack.length;\n            --nodeStack.length;\n            parent_1 = stack[stack.length - 1];\n        }\n        var parentNode = nodeStack[nodeStack.length - 1];\n        var node = {\n            key: value.key,\n            value: value.dx,\n            children: [],\n            parent: parentNode\n        };\n        if (value.name) {\n            node.name = value.name;\n        }\n        if (parentNode) {\n            parentNode.children.push(node);\n        }\n        else {\n            roots.push(node);\n        }\n        stack.push(value);\n        nodeStack.push(node);\n    }\n    return roots;\n}\nexports.convertTraceToTrees = convertTraceToTrees;\nvar SimpleBuffer = /** @class */ (function () {\n    function SimpleBuffer(data) {\n        if (data) {\n            this._data = data;\n        }\n        else {\n            this._data = [];\n        }\n    }\n    SimpleBuffer.prototype.push = function (d) {\n        this._data.push(d);\n    };\n    SimpleBuffer.prototype.get = function (index) {\n        return this._data[index];\n    };\n    SimpleBuffer.prototype.length = function () {\n        return this._data.length;\n    };\n    SimpleBuffer.prototype.getData = function () {\n        return this._data;\n    };\n    return SimpleBuffer;\n}());\nexports.SimpleBuffer = SimpleBuffer;\nvar RingBuffer = /** @class */ (function () {\n    function RingBuffer(size) {\n        this._data = new Array(size);\n        this._startIdx = 0;\n        this._count = 0;\n        this._isRotating = false;\n    }\n    /** add a new value to the buffer */\n    RingBuffer.prototype.push = function (d) {\n        if (this._isRotating) {\n            // the buffer is rotating\n            this._data[this._startIdx] = d;\n            ++this._startIdx;\n            if (this._startIdx === this._count) {\n                this._startIdx = 0;\n            }\n            this._isRotating = true;\n        }\n        else if (this._count === this._data.length - 1) {\n            // here the buffer will start rotating as the buffer is full\n            this._data[this._count] = d;\n            ++this._count;\n            this._isRotating = true;\n        }\n        else {\n            // here the buffer has not been filled yet\n            this._data[this._count] = d;\n            ++this._count;\n        }\n    };\n    /** return the value offset index from the start index\n     * @param index the offset from the start of the buffer\n     */\n    RingBuffer.prototype.get = function (index) {\n        if (this._isRotating) {\n            // the buffer is rotating\n            index = index + this._startIdx;\n            if (index >= this._count) {\n                index = index - this._count;\n            }\n        }\n        return this._data[index];\n    };\n    /** get the number of items in the buffer */\n    RingBuffer.prototype.length = function () {\n        return this._count;\n    };\n    RingBuffer.prototype.getData = function () {\n        if (this._isRotating) {\n            // the buffer is rotating\n            var ret = [];\n            for (var i = this._startIdx; i < this._data.length; ++i) {\n                ret.push(this._data[i]);\n            }\n            for (var i = 0; i < this._startIdx; ++i) {\n                ret.push(this._data[i]);\n            }\n            return ret;\n        }\n        return this._data;\n    };\n    return RingBuffer;\n}());\nexports.RingBuffer = RingBuffer;\nfunction bisectBuffer(compare) {\n    if (!compare)\n        compare = ascending;\n    if (compare.length === 1)\n        compare = ascendingComparator(compare);\n    return {\n        left: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length();\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a.get(mid), x) < 0)\n                    lo = mid + 1;\n                else\n                    hi = mid;\n            }\n            return lo;\n        },\n        right: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length();\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a.get(mid), x) > 0)\n                    hi = mid;\n                else\n                    lo = mid + 1;\n            }\n            return lo;\n        }\n    };\n}\nexports.bisectBuffer = bisectBuffer;\nfunction transposeKeys(data) {\n    // this is used to map the keys to their indicies in the output summary data\n    var keyIdxMapping = {};\n    function transposeHelper(output, parentKeys, value, level) {\n        var myKeys = [];\n        for (var i = 0; i < parentKeys.length; ++i) {\n            myKeys[i] = parentKeys[i];\n        }\n        myKeys.push(value.key);\n        if (Array.isArray(value.data)) {\n            for (var i = 0; i < value.data.length; ++i) {\n                transposeHelper(output, myKeys, value.data[i], level + 1);\n            }\n        }\n        else {\n            var currSummaryArray = output;\n            for (var keyIdx = myKeys.length - 1; keyIdx >= 0; --keyIdx) {\n                var key = myKeys[keyIdx];\n                var dataIdx = void 0;\n                if (!keyIdxMapping.hasOwnProperty(key)) {\n                    dataIdx = currSummaryArray.length;\n                    keyIdxMapping[key] = dataIdx;\n                }\n                else {\n                    dataIdx = keyIdxMapping[key];\n                }\n                // create the summary data if it doesn't exist yet\n                if (!currSummaryArray[dataIdx]) {\n                    currSummaryArray[dataIdx] = { key: key, data: [] };\n                }\n                // if we are the leaf add the data, else just move to the next level\n                if (keyIdx === 0) {\n                    currSummaryArray[dataIdx].data = value.data;\n                }\n                else {\n                    currSummaryArray = currSummaryArray[dataIdx].data;\n                }\n            }\n        }\n    }\n    var output = [];\n    for (var i = 0; i < data.length; ++i) {\n        transposeHelper(output, [], data[i], 0);\n    }\n    return output;\n}\nexports.transposeKeys = transposeKeys;\nfunction runFunctionOnLeaf(node, func) {\n    if (node && node.children && node.children.length > 0) {\n        for (var i = 0; i < node.children.length; ++i) {\n            runFunctionOnLeaf(node.children[i], func);\n        }\n    }\n    else {\n        func(node);\n    }\n}\nexports.runFunctionOnLeaf = runFunctionOnLeaf;\n\n\n//# sourceURL=webpack://UWT/./src/core/utilities.ts?");

/***/ }),

/***/ "./src/interface/chart/chart.ts":
/*!**************************************!*\
  !*** ./src/interface/chart/chart.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * defines what type of axis scaling to use\n *\n * @enum {number}\n */\nvar AxisType;\n(function (AxisType) {\n    /** continuous axis of data with a linear scale */\n    AxisType[AxisType[\"Linear\"] = 0] = \"Linear\";\n    /** continuous axis of data with a logarithmic (base 10) scale */\n    AxisType[AxisType[\"Logarithmic\"] = 1] = \"Logarithmic\";\n    /** axis of data with discrete values that are enumerated or derived from the data */\n    AxisType[AxisType[\"Ordinal\"] = 2] = \"Ordinal\";\n})(AxisType = exports.AxisType || (exports.AxisType = {})); // enum AxisType\n/**\n * bit mask to define how to render the data.  This is an input to the RenderSeries.\n * Note Stacked can be compbined with Line/Area/Bar\n *\n * @enum {number}\n */\nvar RenderType;\n(function (RenderType) {\n    /** render the data as a line.  Supports IXYValue data */\n    RenderType[RenderType[\"Line\"] = 1] = \"Line\";\n    /** render the data as an area graph, Supports IXYValue data */\n    RenderType[RenderType[\"Area\"] = 2] = \"Area\";\n    /** render the data as a scatter plot, Supports IXYValue data */\n    RenderType[RenderType[\"Scatter\"] = 4] = \"Scatter\";\n    /** render the data as a bar chart, Supports ISummaryValue data */\n    RenderType[RenderType[\"Bar\"] = 8] = \"Bar\";\n    /** render the line/area/bar data stacked.  One data renders the Y value\n     * from 0-y1 and the next series renders from y1-y2 and so on for the data\n     */\n    RenderType[RenderType[\"Stacked\"] = 16] = \"Stacked\";\n    /** render the data as a min max value chart, Supports IMinMaxValue data */\n    RenderType[RenderType[\"MinMaxValue\"] = 32] = \"MinMaxValue\";\n    /** render the data as a flame chart, Supports ITraceValue data */\n    RenderType[RenderType[\"FlameChart\"] = 64] = \"FlameChart\";\n    /** render the data as markers, supports ITraceValue data and\n     * requires image/decimation image in series*/\n    RenderType[RenderType[\"Marker\"] = 128] = \"Marker\";\n    /** render the data as an arrow */\n    RenderType[RenderType[\"DirectionalArrow\"] = 256] = \"DirectionalArrow\";\n    /** render the data as a box plot */\n    RenderType[RenderType[\"BoxPlot\"] = 512] = \"BoxPlot\";\n    /** render the data as a heat map */\n    RenderType[RenderType[\"HeatMap\"] = 1024] = \"HeatMap\";\n})(RenderType = exports.RenderType || (exports.RenderType = {}));\n; // bitmask RenderType\n/**\n * how to render a line graph\n *\n * @enum {number}\n */\nvar InterpolateType;\n(function (InterpolateType) {\n    /** render a connected line from the previous value y to the current value y */\n    InterpolateType[InterpolateType[\"Linear\"] = 0] = \"Linear\";\n    /** render a horizontal line using the previous y value from the previous x value\n     * to the current x value and then render a vertical line from the previous value\n     * y to the current value y\n     */\n    InterpolateType[InterpolateType[\"StepBefore\"] = 1] = \"StepBefore\";\n    /** render a horizontal line using the current y value from the current x value\n     * to the next x value and then render a vertical line from the current value\n     * y to the next value y\n     */\n    InterpolateType[InterpolateType[\"StepAfter\"] = 2] = \"StepAfter\";\n})(InterpolateType = exports.InterpolateType || (exports.InterpolateType = {}));\n\n\n//# sourceURL=webpack://UWT/./src/interface/chart/chart.ts?");

/***/ }),

/***/ "d3":
/*!*********************!*\
  !*** external "d3" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_d3__;\n\n//# sourceURL=webpack://UWT/external_%22d3%22?");

/***/ })

/******/ });
});