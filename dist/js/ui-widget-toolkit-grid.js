(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("ag-grid-community"));
	else if(typeof define === 'function' && define.amd)
		define("UWT", ["ag-grid-community"], factory);
	else if(typeof exports === 'object')
		exports["UWT"] = factory(require("ag-grid-community"));
	else
		root["UWT"] = factory(root["agGrid"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_ag_grid_community__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/build/export.grid.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/build/export.grid.ts":
/*!**********************************!*\
  !*** ./src/build/export.grid.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ../interface/ui-base */ \"./src/interface/ui-base.ts\"));\n__export(__webpack_require__(/*! ../interface/grid */ \"./src/interface/grid.ts\"));\n__export(__webpack_require__(/*! ../core/element-manager */ \"./src/core/element-manager.ts\"));\n__export(__webpack_require__(/*! ../core/color-manager */ \"./src/core/color-manager.ts\"));\n__export(__webpack_require__(/*! ../core/utilities */ \"./src/core/utilities.ts\"));\n__export(__webpack_require__(/*! ../core/ag-grid/ag-grid-renderer */ \"./src/core/ag-grid/ag-grid-renderer.ts\"));\n\n\n//# sourceURL=webpack://UWT/./src/build/export.grid.ts?");

/***/ }),

/***/ "./src/core/ag-grid/ag-grid-renderer.ts":
/*!**********************************************!*\
  !*** ./src/core/ag-grid/ag-grid-renderer.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ui_base_1 = __webpack_require__(/*! ../../interface/ui-base */ \"./src/interface/ui-base.ts\");\nvar utilities_1 = __webpack_require__(/*! ../utilities */ \"./src/core/utilities.ts\");\nvar color_manager_1 = __webpack_require__(/*! ../color-manager */ \"./src/core/color-manager.ts\");\nvar context_menu_1 = __webpack_require__(/*! ../context-menu */ \"./src/core/context-menu.ts\");\nvar agGrid = __webpack_require__(/*! ag-grid-community */ \"ag-grid-community\");\n// from https://www.ag-grid.com/best-javascript-data-grid/#gsc.tab=0\nfunction percentCellRenderer(params) {\n    var value = params.value;\n    if (value === undefined || value === null) {\n        value = 0;\n    }\n    var percentBar = document.createElement('div');\n    percentBar.className = 'div-percent-bar';\n    percentBar.style.width = value + '%';\n    percentBar.style.height = '25px';\n    percentBar.style.backgroundColor = '#B3E5FC';\n    percentBar.innerHTML = value.toFixed(2) + '%';\n    return percentBar;\n}\nexports.percentCellRenderer = percentCellRenderer;\nfunction computeMaxAndPercentage(rowData, columns) {\n    var columnMax = {};\n    var total = {};\n    for (var i = 0; i < columns.length; ++i) {\n        var column = columns[i];\n        if (!columnMax[column.field]) {\n            columnMax[column.field] = 0;\n        }\n        if (!total[column.field]) {\n            total[column.field] = 0;\n        }\n        for (var j = 0; j < rowData.length; ++j) {\n            if (rowData[j][column.field]) {\n                if (rowData[j][column.field].value) {\n                    rowData[j][column.field] = rowData[j][column.field].value;\n                }\n                columnMax[column.field] = Math.max(columnMax[column.field], rowData[j][column.field]);\n                total[column.field] += rowData[j][column.field];\n            }\n        }\n    }\n    for (var i = 0; i < columns.length; ++i) {\n        var column = columns[i];\n        for (var j = 0; j < rowData.length; ++j) {\n            rowData[j][column.field] = {\n                value: rowData[j][column.field],\n                columnMax: columnMax[column.field],\n                total: total[column.field]\n            };\n        }\n    }\n}\nexports.computeMaxAndPercentage = computeMaxAndPercentage;\nfunction valueCellRenderer(params) {\n    var value = params.value;\n    value.value = value.value ? value.value : 0;\n    var percentBar = document.createElement('div');\n    var barWidth = value.columnMax ? (value.value / value.columnMax * 100) : 0;\n    var percent = value.total ? (value.value / value.total * 100) : 0;\n    percentBar.className = 'div-percent-bar';\n    percentBar.style.height = '25px';\n    percentBar.style.backgroundColor = '#B3E5FC';\n    percentBar.style.width = barWidth + '%';\n    if (params.colDef.showAsPercentage) {\n        percentBar.innerHTML = percent.toFixed(2) + '%';\n        percentBar.title = percent.toFixed(2) + '% (' + 'Value: ' + value.value + ')';\n    }\n    else {\n        percentBar.innerHTML = value.value.toFixed(2);\n        percentBar.title = 'Value: ' + value.value + ' (' + percent.toFixed(2) + '%)';\n    }\n    return percentBar;\n}\nexports.valueCellRenderer = valueCellRenderer;\nfunction valueComparator(valueA, valueB, nodeA, nodeB, isInverted) {\n    return valueA.value - valueB.value;\n}\nexports.valueComparator = valueComparator;\nexports.menuItemShowAsPercentage = {\n    title: 'Display Percentage', action: function (elem, data, index) {\n        var idx = data.colDef.contextMenuItems.indexOf(exports.menuItemShowAsPercentage);\n        data.colDef.contextMenuItems[idx] = exports.menuItemShowAsTotal;\n        data.colDef.showAsPercentage = true;\n        data.api.refreshCells({ columns: [data.colDef], force: true });\n    }\n};\nexports.menuItemShowAsTotal = {\n    title: 'Display Raw Values', action: function (elem, data, index) {\n        var idx = data.colDef.contextMenuItems.indexOf(exports.menuItemShowAsTotal);\n        data.colDef.contextMenuItems = [exports.menuItemShowAsPercentage];\n        data.colDef.showAsPercentage = false;\n        data.api.refreshCells({ columns: [data.colDef], force: true });\n    }\n};\nvar AgGrid = /** @class */ (function () {\n    /**\n     * Append the div for this graph to the parent div. The div we create\n     * will be filled when Render() is called\n     *\n     * @param parent - The div that will contain the div for this chart.\n     *\n     * @return - The chart instance\n     */\n    function AgGrid(element, renderer, parent, options) {\n        if (options === void 0) { options = {}; }\n        this._element = element;\n        this._renderer = renderer;\n        this._options = options;\n        this._disableCallbacks = false;\n        if (parent) {\n            this._div = document.querySelector(parent);\n        }\n        var self = this;\n        this.onRowSelectedDefaultCallback = function (row) {\n            if (self._disableCallbacks) {\n                return;\n            }\n            var grid = self._element;\n            var gridOptions = grid.gridOptions;\n            var selectionCallback = grid.onHover;\n            if (selectionCallback) {\n                var columns = gridOptions.columnApi.getAllColumns();\n                if (columns && columns.length > 0) {\n                    var key = columns[0].colDef.field;\n                    var selection = row.node.data[key];\n                    var event_1 = { caller: grid, selection: selection, data: { row: row } };\n                    event_1.event = row.node.isSelected() ? ui_base_1.EventType.HoverStart :\n                        ui_base_1.EventType.HoverEnd;\n                    selectionCallback(event_1);\n                }\n            }\n        };\n        this.keyboardSelectionFocus = function (params) {\n            var previousCell = params.previousCellDef;\n            var suggestedNextCell = params.nextCellDef;\n            var KEY_UP = 38;\n            var KEY_DOWN = 40;\n            var KEY_LEFT = 37;\n            var KEY_RIGHT = 39;\n            var columns = self._element.gridOptions.columnApi.getAllColumns();\n            if (columns && columns.length > 0) {\n                var selectionKey_1 = self._element.gridOptions.selectionKey ?\n                    self._element.gridOptions.selectionKey : columns[0].colDef.field;\n                var helper = function (index) {\n                    previousCell = params.previousCellDef;\n                    // set selected cell on current cell + 1\n                    self._element.gridOptions.api.forEachNode(function (node) {\n                        if (index === node.rowIndex) {\n                            node.setSelected(true);\n                        }\n                        else if (!params.event.shiftKey) {\n                            self._renderer.hover(self._element, {\n                                event: ui_base_1.EventType.HoverEnd,\n                                selection: utilities_1.getSelectionName(node.data[selectionKey_1])\n                            });\n                        }\n                    });\n                    return suggestedNextCell;\n                };\n                switch (params.key) {\n                    case KEY_DOWN:\n                        return helper(previousCell.rowIndex + 1);\n                    case KEY_UP:\n                        return helper(previousCell.rowIndex - 1);\n                    case KEY_LEFT:\n                    case KEY_RIGHT:\n                        return suggestedNextCell;\n                    default:\n                        throw \"this will never happen, navigation is always on of the 4 keys above\";\n                }\n            }\n        };\n    }\n    AgGrid.prototype.setDiv = function (div) {\n        this._div = div;\n    };\n    AgGrid.prototype.select = function (event) {\n        var self = this;\n        var selection = event.selection;\n        // make typescript happy to hardcode some things\n        var gridOptions = this._element.gridOptions;\n        var columns = gridOptions.columnApi.getAllColumns();\n        self._disableCallbacks = true;\n        if (columns && columns.length > 0) {\n            var selectionKey = gridOptions.selectionKey ? gridOptions.selectionKey :\n                columns[0].colDef.field;\n            var key_1 = event.selectionKey ? event.selectionKey : selectionKey;\n            if (event.event === ui_base_1.EventType.HoverStart) {\n                this._prevSelection = event.selection;\n                gridOptions.api.forEachNode(function (rowNode) {\n                    if (utilities_1.getSelectionName(rowNode.data[key_1]) === selection) {\n                        // select the node\n                        rowNode.setSelected(true);\n                    }\n                });\n            }\n            else if (event.event === ui_base_1.EventType.HoverClear) {\n                gridOptions.api.deselectAll();\n            }\n            else {\n                if (!event.selection) {\n                    selection = self._prevSelection;\n                }\n                gridOptions.api.forEachNode(function (rowNode) {\n                    if (utilities_1.getSelectionName(rowNode.data[key_1]) === selection) {\n                        // deselect the node\n                        rowNode.setSelected(false);\n                        // clear the previous selection if it's what we just removed\n                        if (event.selection === self._prevSelection) {\n                            self._prevSelection = undefined;\n                        }\n                    }\n                });\n            }\n        }\n        self._disableCallbacks = false;\n    };\n    AgGrid.prototype.setContextMenuItems = function (columnDefs, contextMenuItems) {\n        if (columnDefs) {\n            if (!contextMenuItems) {\n                contextMenuItems = [];\n            }\n            for (var i = 0; i < columnDefs.length; ++i) {\n                var column = columnDefs[i];\n                column.onCellContextMenu = function (cell) {\n                    context_menu_1.showContextMenu(cell.event, cell, cell.colDef.contextMenuItems ? contextMenuItems.concat(cell.colDef.contextMenuItems) : contextMenuItems);\n                };\n                if (column.children) {\n                    this.setContextMenuItems(column.children, contextMenuItems);\n                }\n            }\n        }\n    };\n    AgGrid.prototype.invalidate = function (options) {\n        if (options === void 0) { options = {}; }\n        var self = this;\n        // make typescript happy to hardcode some things\n        var gridOptions = this._element.gridOptions;\n        gridOptions.animateRows = true;\n        gridOptions.rowSelection = 'multiple';\n        gridOptions.rowDeselection = true;\n        gridOptions.suppressScrollOnNewData = true;\n        gridOptions.suppressPropertyNamesCheck = true;\n        if (!gridOptions.defaultColDef) {\n            gridOptions.defaultColDef = {};\n        }\n        gridOptions.defaultColDef.sortable = true;\n        gridOptions.defaultColDef.resizable = true;\n        gridOptions.defaultColDef.filter = true;\n        if (!gridOptions.onRowSelected) {\n            gridOptions.onRowSelected = this.onRowSelectedDefaultCallback;\n        }\n        else {\n            if (!gridOptions.userOnRowSelected) {\n                gridOptions.userOnRowSelected = gridOptions.onRowSelected;\n            }\n            gridOptions.onRowSelected = function (row) {\n                if (self._disableCallbacks) {\n                    return;\n                }\n                gridOptions.userOnRowSelected({\n                    caller: self._element,\n                    data: {\n                        row: row.node.data,\n                        isSelected: row.node.selected\n                    }\n                });\n            };\n        }\n        if (gridOptions.onRowClicked) {\n            if (!gridOptions.userOnRowClicked) {\n                gridOptions.userOnRowClicked = gridOptions.onRowClicked;\n            }\n            gridOptions.onRowClicked = function (row) {\n                gridOptions.userOnRowClicked({\n                    caller: self._element,\n                    data: { row: row }\n                });\n            };\n        }\n        if (gridOptions.onRowDoubleClicked) {\n            if (!gridOptions.userOnRowDoubleClicked) {\n                gridOptions.userOnRowDoubleClicked = gridOptions.onRowDoubleClicked;\n            }\n            gridOptions.onRowDoubleClicked = function (row) {\n                gridOptions.userOnRowDoubleClicked({\n                    caller: self._element,\n                    data: { row: row }\n                });\n            };\n        }\n        var hasGrouping = false;\n        if (gridOptions.rowData && !gridOptions.getNodeChildDetails) {\n            for (var i = 0; i < gridOptions.rowData.length; ++i) {\n                var row = gridOptions.rowData[i];\n                if (row.children && row.children.length > 0) {\n                    hasGrouping = true;\n                    break;\n                }\n            }\n        }\n        if (gridOptions.columnDefs) {\n            var valueCellRendererColumns = [];\n            var _loop_1 = function (i) {\n                var column = gridOptions.columnDefs[i];\n                if (column.canShowPercentage || column.showAsPercentage || column.showAsBar) {\n                    valueCellRendererColumns.push(column);\n                    column.cellRenderer = valueCellRenderer;\n                    column.comparator = valueComparator;\n                    if (!column.contextMenuItems) {\n                        column.contextMenuItems = [];\n                    }\n                    var idx = 0;\n                    if (column.showAsPercentage) {\n                        idx = column.contextMenuItems.indexOf(exports.menuItemShowAsPercentage);\n                        if (idx !== -1) {\n                            column.contextMenuItems[i] = exports.menuItemShowAsTotal;\n                        }\n                        else {\n                            idx = column.contextMenuItems.indexOf(exports.menuItemShowAsTotal);\n                            if (idx === -1) {\n                                column.contextMenuItems.push(exports.menuItemShowAsTotal);\n                            }\n                        }\n                    }\n                    else if (column.canShowPercentage) {\n                        idx = column.contextMenuItems.indexOf(exports.menuItemShowAsTotal);\n                        if (idx !== -1) {\n                            column.contextMenuItems[i] = exports.menuItemShowAsPercentage;\n                        }\n                        else {\n                            idx = column.contextMenuItems.indexOf(exports.menuItemShowAsPercentage);\n                            if (idx === -1) {\n                                column.contextMenuItems.push(exports.menuItemShowAsPercentage);\n                            }\n                        }\n                    }\n                }\n                if (column.onCellClicked) {\n                    var onClick_1 = column.onCellClicked;\n                    column.onCellClicked = function (params) {\n                        onClick_1({\n                            caller: self._element,\n                            data: { cell: params }\n                        });\n                    };\n                }\n                if (column.onCellDoubleClicked) {\n                    var onDoubleClick_1 = column.onCellDoubleClicked;\n                    column.onCellDoubleClicked = function (params) {\n                        onDoubleClick_1({\n                            caller: self._element,\n                            data: { cell: params }\n                        });\n                    };\n                }\n            };\n            for (var i = 0; i < gridOptions.columnDefs.length; ++i) {\n                _loop_1(i);\n            }\n            if (hasGrouping && gridOptions.columnDefs.length > 0) {\n                var groupCol_1 = gridOptions.columnDefs[0];\n                groupCol_1.cellRenderer = 'agGroupCellRenderer';\n                groupCol_1.cellRendererParams = {\n                    innerRenderer: function (params) { return params.data[groupCol_1.field]; },\n                    suppressCount: true\n                };\n                gridOptions.getNodeChildDetails = function (rowItem) {\n                    if (rowItem.children) {\n                        return {\n                            group: true,\n                            expanded: rowItem.expanded,\n                            children: rowItem.children,\n                            key: rowItem[groupCol_1.field]\n                        };\n                    }\n                    else {\n                        return null;\n                    }\n                };\n            }\n            if (valueCellRendererColumns.length > 0) {\n                computeMaxAndPercentage(gridOptions.rowData, valueCellRendererColumns);\n            }\n        }\n        if (gridOptions.enableSingleKeyboardSelection) {\n            gridOptions.navigateToNextCell = this.keyboardSelectionFocus;\n        }\n        var noContextMenu = gridOptions.contextMenuItems == undefined;\n        if (gridOptions.columnDefs) {\n            for (var i = 0; noContextMenu && i < gridOptions.columnDefs.length; ++i) {\n                var column = gridOptions.columnDefs[i];\n                if (column.contextMenuItems) {\n                    noContextMenu = false;\n                }\n            }\n        }\n        if (!noContextMenu) {\n            this.setContextMenuItems(gridOptions.columnDefs, gridOptions.contextMenuItems);\n        }\n        while (this._div.firstChild) {\n            this._div.removeChild(this._div.firstChild);\n        }\n        new agGrid.Grid(this._div, this._element.gridOptions); //create a new grid\n    };\n    return AgGrid;\n}());\nvar AgGridRenderer = /** @class */ (function () {\n    function AgGridRenderer(parent, options, colorMgr) {\n        if (options === void 0) { options = {}; }\n        if (colorMgr === void 0) { colorMgr = new color_manager_1.ColorManager(); }\n        this.invalidate = this.render;\n        this._parent = parent;\n        this._rendererMap = new WeakMap();\n        this._options = options;\n        this._colorMgr = colorMgr;\n    }\n    AgGridRenderer.prototype.getColorManager = function () {\n        return this._colorMgr;\n    };\n    AgGridRenderer.prototype.setOnRenderCallback = function (callback) {\n        this.onRender = callback;\n    };\n    /** update any options */\n    AgGridRenderer.prototype.setOptions = function (options) {\n        for (var key in options) {\n            this._options[key] = options[key];\n        }\n    };\n    AgGridRenderer.prototype.hover = function (element, event) {\n        if (this._rendererMap.has(element)) {\n            return this._rendererMap.get(element).select(event);\n        }\n    };\n    AgGridRenderer.prototype.setDiv = function (element, div) {\n        if (!this._rendererMap.has(element)) {\n            if (element.type === ui_base_1.UIType.Grid) {\n                this._rendererMap.set(element, new AgGrid(element, this));\n            }\n        }\n        if (this._rendererMap.has(element)) {\n            this._rendererMap.get(element).setDiv(div);\n        }\n    };\n    /**\n     * Render the given element\n     *\n     * @param the element to render\n     */\n    AgGridRenderer.prototype.render = function (element, options) {\n        if (options === void 0) { options = {}; }\n        var self = this;\n        element.renderer = this;\n        if (!this._rendererMap.has(element)) {\n            if (element.type === ui_base_1.UIType.Grid) {\n                this._rendererMap.set(element, new AgGrid(element, this, this._parent));\n            }\n        }\n        if (this._rendererMap.has(element)) {\n            this._rendererMap.get(element).invalidate(options);\n            if (this.onRender) {\n                this.onRender(element, options);\n            }\n        }\n    };\n    /**\n     * free the resources used by the renderer for this element\n     */\n    AgGridRenderer.prototype.destroy = function (element) {\n        this._rendererMap.delete(element);\n    };\n    AgGridRenderer.prototype.getOptions = function () { return this._options; };\n    return AgGridRenderer;\n}());\nexports.AgGridRenderer = AgGridRenderer;\n\n\n//# sourceURL=webpack://UWT/./src/core/ag-grid/ag-grid-renderer.ts?");

/***/ }),

/***/ "./src/core/color-manager.ts":
/*!***********************************!*\
  !*** ./src/core/color-manager.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction numberToHex(number) {\n    var hex = Number(number).toString(16);\n    return hex.length == 1 ? '0' + hex : hex;\n}\nfunction rgbToHex(color) {\n    var rgb = color.substring(color.indexOf('(') + 1, color.indexOf(')')).split(',');\n    return numberToHex(rgb[0]) + numberToHex(rgb[1]) + numberToHex(rgb[2]);\n}\n/** used to organize and create colors for the UI */\nvar ColorManager = /** @class */ (function () {\n    function ColorManager(randomColorFunc) {\n        this._colorMap = {};\n        if (randomColorFunc) {\n            this.getRandomColor = randomColorFunc;\n        }\n        else {\n            this.getRandomColor = function () {\n                var letters = '0123456789ABCDEF';\n                var color = '#';\n                for (var i = 0; i < 6; i++) {\n                    color += letters[Math.floor(Math.random() * 16)];\n                }\n                return color;\n            };\n        }\n    }\n    /**\n     * check if an existing color exists for a given key\n     *\n     * @param the key associated with your data\n     */\n    ColorManager.prototype.hasColor = function (key) {\n        return this._colorMap.hasOwnProperty(key);\n    };\n    /**\n     * set the color associated with a given key\n     *\n     * @param key associated with your data\n     * @param color to associate with the key\n     */\n    ColorManager.prototype.setColor = function (key, color) {\n        if (color.indexOf('rgb') === 0) {\n            color = ColorManager.RgbToHex(color);\n        }\n        this._colorMap[key] = color;\n    };\n    /**\n     * get the color associated with a given key\n     *\n     * @param key associated with your data\n     */\n    ColorManager.prototype.getColor = function (key) {\n        if (!this.hasColor(key)) {\n            this._colorMap[key] = this.getRandomColor();\n        }\n        return this._colorMap[key];\n    };\n    ColorManager.IntToHex = function (value) {\n        return '#' + value.toString(16).padStart(6, '0');\n    };\n    ColorManager.RgbToHex = function (color) {\n        return '#' + rgbToHex(color);\n    };\n    ColorManager.RgbToInt = function (color) {\n        return parseInt(rgbToHex(color), 16);\n    };\n    return ColorManager;\n}());\nexports.ColorManager = ColorManager;\n\n\n//# sourceURL=webpack://UWT/./src/core/color-manager.ts?");

/***/ }),

/***/ "./src/core/context-menu.ts":
/*!**********************************!*\
  !*** ./src/core/context-menu.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction positionMenu(div, rect) {\n    var bodyWidth = document.body.clientWidth;\n    var bodyHeight = document.body.clientHeight;\n    // these points define the top left of our menu\n    var divX = rect.left;\n    var divY = rect.top;\n    // if we draw on the right we do\n    if (rect.right + div.clientWidth < bodyWidth) {\n        divX = rect.right;\n    }\n    else {\n        divX = rect.left - div.clientWidth;\n    }\n    // if we cannot draw down we draw up\n    if (rect.top + div.clientHeight > bodyHeight) {\n        divY = rect.top - div.clientHeight;\n    }\n    div.style.left = (divX - 2) + 'px';\n    div.style.top = (divY - 2) + 'px';\n}\nfunction createMenu(event, data, contextMenuItems, rect, propogateEvent) {\n    var menuDiv;\n    menuDiv = document.createElement('div');\n    menuDiv.setAttribute('class', 'context-menu');\n    menuDiv.oncontextmenu = function (e) {\n        removeMenu();\n        e.preventDefault();\n    };\n    document.body.appendChild(menuDiv);\n    if (contextMenuItems.length > 0) {\n        var menuList = document.createElement('ul');\n        menuDiv.appendChild(menuList);\n        var _loop_1 = function (i) {\n            var item = contextMenuItems[i];\n            var li = document.createElement('li');\n            if (item.divider) {\n                li.className += ' is-divider';\n                li.innerHTML = '<hr>';\n            }\n            else {\n                if (!item.title) {\n                    console.error('No title attribute set. Check the spelling of your options.');\n                }\n                if (item.disabled) {\n                    li.className += ' is-disabled';\n                }\n                if (!item.action && !item.submenu) {\n                    li.className += ' is-header';\n                }\n                if (item.submenu) {\n                    li.innerHTML = '<span><text>' + item.title +\n                        '</text><text style=\"width: 5px; float: right\">&#9658</text></span>';\n                }\n                else {\n                    li.innerHTML = item.title;\n                }\n                li.onclick = function (d) {\n                    if (item.disabled)\n                        return; // do nothing if disabled\n                    if (!item.action)\n                        return; // headers have no \"action\"\n                    item.action(li, data, i);\n                    removeMenu();\n                };\n                li.onmouseenter = function () {\n                    removeSubmenu(contextMenuItems);\n                    if (item.submenu) {\n                        var relativeRect = li.getBoundingClientRect();\n                        var rect_1 = {\n                            top: relativeRect.top + window.scrollY,\n                            bottom: relativeRect.bottom + window.scrollY,\n                            left: relativeRect.left + window.scrollX,\n                            right: relativeRect.right + window.scrollX,\n                            height: relativeRect.height,\n                            width: relativeRect.width\n                        };\n                        item.submenuDiv = createMenu(event, data, item.submenu, rect_1, propogateEvent);\n                    }\n                };\n            }\n            menuList.appendChild(li);\n        };\n        for (var i = 0; i < contextMenuItems.length; ++i) {\n            _loop_1(i);\n        }\n        menuDiv.style.display = 'block';\n        positionMenu(menuDiv, rect);\n        if (!propogateEvent) {\n            event.stopPropagation();\n        }\n    }\n    return menuDiv;\n}\nfunction removeMenuItem(item) {\n    if (item.submenuDiv) {\n        document.body.removeChild(item.submenuDiv);\n        delete item.submenuDiv;\n    }\n    if (item.submenu) {\n        removeSubmenu(item.submenu);\n    }\n}\nfunction removeSubmenu(items) {\n    items.forEach(function (item, index, items) {\n        removeMenuItem(item);\n    });\n}\nfunction removeMenu() {\n    removeSubmenu(lastMenu);\n    var menus = document.getElementsByClassName('context-menu');\n    while (menus.length) {\n        document.body.removeChild(menus[0]);\n    }\n}\nfunction keyupListener() {\n    window.onkeyup = function (e) {\n        if (e.keyCode === 27) {\n            removeMenu();\n        }\n    };\n}\nvar lastMenu = [];\nfunction showContextMenu(event, data, contextMenuItems, propogateEvent) {\n    if (propogateEvent === void 0) { propogateEvent = false; }\n    keyupListener();\n    removeMenu();\n    lastMenu = contextMenuItems;\n    createMenu(event, data, contextMenuItems, {\n        left: event.pageX,\n        top: event.pageY,\n        right: event.pageX,\n        bottom: event.pageY,\n        height: 0,\n        width: 0\n    }, propogateEvent);\n    event.preventDefault();\n}\nexports.showContextMenu = showContextMenu;\n\n\n//# sourceURL=webpack://UWT/./src/core/context-menu.ts?");

/***/ }),

/***/ "./src/core/element-manager.ts":
/*!*************************************!*\
  !*** ./src/core/element-manager.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utilities_1 = __webpack_require__(/*! ./utilities */ \"./src/core/utilities.ts\");\nvar GroupType;\n(function (GroupType) {\n    GroupType[GroupType[\"Tooltip\"] = 0] = \"Tooltip\";\n    GroupType[GroupType[\"Highlight\"] = 1] = \"Highlight\";\n    GroupType[GroupType[\"Render\"] = 2] = \"Render\";\n    GroupType[GroupType[\"None\"] = 3] = \"None\";\n})(GroupType || (GroupType = {}));\nvar GroupInfo = /** @class */ (function () {\n    function GroupInfo() {\n        this._nameMap = {};\n        this._objectMap = new Map();\n    }\n    return GroupInfo;\n}());\nexports.GroupInfo = GroupInfo;\nfunction addTooltipCallback(elem) {\n    if (!elem.getTooltip) {\n        elem.getTooltip = function (event) {\n            if (elem.renderer && elem.renderer.getTooltipData) {\n                return elem.renderer.getTooltipData(elem, event);\n            }\n            return [{ source: elem, group: '', metrics: {} }];\n        };\n    }\n}\nfunction addHoverCallback(elem) {\n    if (!elem.api) {\n        elem.api = {};\n    }\n    if (!elem.api.cursorChange) {\n        elem.api.cursorChange = function (event) {\n            if (elem.renderer && elem.renderer.cursorChange) {\n                return elem.renderer.cursorChange(elem, event);\n            }\n        };\n    }\n    if (!elem.api.hover) {\n        elem.api.hover = function (event) {\n            if (elem.renderer && elem.renderer.hover) {\n                return elem.renderer.hover(elem, event);\n            }\n        };\n    }\n    if (!elem.api.brush) {\n        elem.api.brush = function (event) {\n            if (elem.renderer && elem.renderer.brush) {\n                return elem.renderer.brush(elem, event);\n            }\n        };\n    }\n    if (!elem.api.zoom) {\n        elem.api.zoom = function (event) {\n            if (elem.renderer && elem.renderer.zoom) {\n                return elem.renderer.zoom(elem, event);\n            }\n        };\n    }\n}\nfunction addRenderCallback(elem) {\n    if (!elem.api) {\n        elem.api = {};\n    }\n    if (!elem.api.brush) {\n        elem.api.brush = function (event) {\n            if (elem.renderer && elem.renderer.brush) {\n                return elem.renderer.brush(elem, event);\n            }\n        };\n    }\n    if (!elem.api.render) {\n        elem.api.render = function (renderer, options) {\n            if (!renderer) {\n                renderer = elem.renderer;\n            }\n            else {\n                elem.renderer = renderer;\n            }\n            return new Promise(function (resolve, reject) {\n                if (renderer) {\n                    elem.renderer.render(elem, options);\n                    resolve('Ok');\n                }\n                reject('No renderer available');\n            });\n        };\n    }\n}\n/** adds some default callbacks to a given UI object */\nfunction addCallbacks(elem) {\n    addTooltipCallback(elem);\n    addHoverCallback(elem);\n    addRenderCallback(elem);\n}\nexports.addCallbacks = addCallbacks;\n/** used to group UI elements together.  Can be used to sync\n * selection/tooltips\n */\nvar ElementManager = /** @class */ (function () {\n    function ElementManager() {\n        /** the list of elements managed by this manager */\n        this._elems = [];\n        var self = this;\n        this._groupInfo = [];\n        for (var i = 0; i < 3 /* None */; ++i) {\n            this._groupInfo.push(new GroupInfo());\n        }\n        this._onHoverCallback = function (event) {\n            var elems = self._groupInfo[1 /* Highlight */]._objectMap.get(event.caller);\n            if (elems) {\n                if (self._hoverCallback) {\n                    self._hoverCallback(elems, event);\n                }\n                else {\n                    for (var i = 0; i < elems.length; ++i) {\n                        var elem = elems[i];\n                        if (elem.api && elem.api.hover) {\n                            elem.api.hover(event);\n                        }\n                    }\n                }\n            }\n        };\n        this._onZoomCallback = function (event) {\n            var elems = self._groupInfo[1 /* Highlight */]._objectMap.get(event.caller);\n            if (elems) {\n                if (self._zoomCallback) {\n                    self._zoomCallback(elems, event);\n                }\n                else {\n                    for (var i = 0; i < elems.length; ++i) {\n                        var elem = elems[i];\n                        if (elem.api && elem.api.zoom) {\n                            elem.api.zoom(event);\n                        }\n                    }\n                }\n            }\n        };\n        this._onTooltipCallback = function (event) {\n            var ret = [];\n            var elems = self._groupInfo[0 /* Tooltip */]._objectMap.get(event.caller);\n            if (elems) {\n                if (self._tooltipCallback) {\n                    ret = ret.concat(self._tooltipCallback(elems, event));\n                }\n                else {\n                    for (var i = 0; i < elems.length; ++i) {\n                        var elem = elems[i];\n                        var data = elem.getTooltip(event);\n                        ret = ret.concat(data);\n                    }\n                }\n                if (event.data && event.data.tooltip) {\n                    event.data.tooltip.setData(event.data.tooltip.getTitle(), ret);\n                }\n                return ret;\n            }\n        };\n        this._onCursorChangeCallback = function (event) {\n            var elems = self._groupInfo[1 /* Highlight */]._objectMap.get(event.caller);\n            if (elems) {\n                if (self._cursorChangeCallback) {\n                    self._cursorChangeCallback(elems, event);\n                }\n                else {\n                    for (var i = 0; i < elems.length; ++i) {\n                        var elem = elems[i];\n                        if (elem.api && elem.api.cursorChange) {\n                            elem.api.cursorChange(event);\n                        }\n                    }\n                }\n            }\n        };\n        this._onBrushCallback = function (event) {\n            var elems = self._groupInfo[1 /* Highlight */]._objectMap.get(event.caller);\n            if (elems) {\n                if (self._brushCallback) {\n                    self._brushCallback(elems, event);\n                }\n                else {\n                    for (var i = 0; i < elems.length; ++i) {\n                        var elem = elems[i];\n                        if (elem.api && elem.api.brush) {\n                            elem.api.brush(event);\n                        }\n                    }\n                }\n            }\n        };\n        this._onUpdateCallback = function (caller, options) {\n            var elems = self._groupInfo[2 /* Render */]._objectMap.get(caller);\n            if (elems) {\n                for (var i = 0; i < elems.length; ++i) {\n                    var elem = elems[i];\n                    if (elem.renderer) {\n                        // use the previous renderer\n                        elem.renderer.render(elem, options);\n                    }\n                }\n            }\n        };\n    }\n    ElementManager.prototype.removeFromGroup = function (elem, type) {\n        var list = this._groupInfo[type]._objectMap.get(elem);\n        if (list) {\n            utilities_1.removeFromList(elem, list);\n        }\n    };\n    ElementManager.prototype.addToGroup = function (elem, groupName, type) {\n        if (!this._groupInfo[type]._nameMap.hasOwnProperty(groupName)) {\n            this._groupInfo[type]._nameMap[groupName] = [];\n        }\n        this._groupInfo[type]._nameMap[groupName].push(elem);\n        this._groupInfo[type]._objectMap.set(elem, this._groupInfo[type]._nameMap[groupName]);\n    };\n    /**\n     * add a elem to the manager\n     *\n     * @param elem - the elem that should should be added\n     * @param tooltipGroupName - Name of the group that this elem should be \"ganged\"\n     *   with when showing tooltips.  If not specified, this elem will not be \"ganged\" with any\n     *   other elem.\n     * @param highlightGroupName - Name of the group that this elem should be \"ganged\"\n     *   with when doing highlighting.  If not specified, this elem will not be \"ganged\" with any\n     *   other elem.\n     * @param renderGroupName - Name of the group that this elem should be \"ganged\"\n     *   with when rerendering.  If not specified, this elem will not be \"ganged\" with any\n     *   other elem.\n     * @return - The elem manager instance.\n     */\n    ElementManager.prototype.addElement = function (elem, tooltipGroupName, highlightGroupName, renderGroupName) {\n        if (!elem) {\n            return this;\n        }\n        var index = this._elems.indexOf(elem);\n        if (index === -1) {\n            addCallbacks(elem);\n            this._elems.push(elem);\n            var renderedElements = void 0;\n            if (!elem.getElements) {\n                elem.getElements = function () { return [elem]; };\n            }\n            renderedElements = elem.getElements();\n            for (var i = 0; i < renderedElements.length; ++i) {\n                var renderedElement = renderedElements[i];\n                if (tooltipGroupName) {\n                    this.addToTooltipGroup(renderedElement, tooltipGroupName);\n                }\n                if (highlightGroupName) {\n                    this.addToHighlightGroup(renderedElement, highlightGroupName);\n                }\n                if (renderGroupName) {\n                    this.addToRenderGroup(renderedElement, renderGroupName);\n                }\n            }\n        }\n        else {\n            throw 'Element already exists in this manager';\n        }\n        elem.manager = this;\n        return this;\n    };\n    /**\n     * remove a elem from the manager, removes it from all groups\n     *\n     * @param elem - the elem that should should be removed\n     *\n     * @return - The elem manager instance.\n     */\n    ElementManager.prototype.removeElement = function (elem) {\n        if (!elem) {\n            return this;\n        }\n        var renderedElements;\n        if (elem.getElements) {\n            renderedElements = elem.getElements();\n        }\n        else {\n            renderedElements = [elem];\n        }\n        for (var i = 0; i < renderedElements.length; ++i) {\n            var renderedElement = renderedElements[i];\n            this.removeFromTooltipGroup(renderedElement);\n            this.removeFromHighlightGroup(renderedElement);\n            this.removeFromRenderGroup(renderedElement);\n        }\n        utilities_1.removeFromList(elem, this._elems);\n        delete elem.manager;\n        return this;\n    };\n    /**\n     * Return all the elems in this list\n     * @return the list of elems\n     */\n    ElementManager.prototype.getElements = function () {\n        return this._elems;\n    };\n    /**\n     * user callback called when a hover event happens\n     *\n     * @param the function to be called\n     */\n    ElementManager.prototype.setHoverCallback = function (callback) {\n        this._hoverCallback = callback;\n        return this;\n    };\n    /**\n     * user callback called when a tooltip is created\n     *\n     * @param the functiotn to be called\n     */\n    ElementManager.prototype.setTooltipCallback = function (callback) {\n        this._tooltipCallback = callback;\n        return this;\n    };\n    /**\n     * user callback called when a selection event happens\n     *\n     * @param the function to be called\n     */\n    ElementManager.prototype.setBrushCallback = function (callback) {\n        this._brushCallback = callback;\n        return this;\n    };\n    /**\n     * set the group this tooltip is associated with\n     *\n     * @param elem - the elem that should should be \"ganged\"\n     * @param groupName - Name of the group that this elem should be \"ganged\"\n     *   with.\n     *\n     * @return - The elem manager instance.\n     */\n    ElementManager.prototype.addToTooltipGroup = function (elem, groupName) {\n        addTooltipCallback(elem);\n        this.removeFromTooltipGroup(elem);\n        this.addToGroup(elem, groupName, 0 /* Tooltip */);\n        if (!elem.onTooltip) {\n            elem.onTooltip = this._onTooltipCallback;\n        }\n        return this;\n    };\n    /**\n     * remove the elem from the tooltip group it is in\n     *\n     * @param elem - the elem that should should be \"unganged\"\n     *\n     * @return - The elem manager instance.\n     */\n    ElementManager.prototype.removeFromTooltipGroup = function (elem) {\n        this.removeFromGroup(elem, 0 /* Tooltip */);\n        return this;\n    };\n    /**\n     * set the group to select this elem with\n     *\n     * @param elem - the elem that should should be \"ganged\"\n     * @param groupName - Name of the group that this elem should be \"ganged\"\n     *   with.\n     *\n     * @return - The elem manager instance.\n     */\n    ElementManager.prototype.addToHighlightGroup = function (elem, groupName) {\n        addHoverCallback(elem);\n        this.removeFromHighlightGroup(elem);\n        this.addToGroup(elem, groupName, 1 /* Highlight */);\n        if (!elem.onBrush) {\n            elem.onBrush = this._onBrushCallback;\n        }\n        if (!elem.onHover) {\n            elem.onHover = this._onHoverCallback;\n        }\n        if (!elem.onCursorChanged) {\n            elem.onCursorChanged = this._onCursorChangeCallback;\n        }\n        if (!elem.onZoom) {\n            elem.onZoom = this._onZoomCallback;\n        }\n        return this;\n    };\n    /**\n     * remove the elem from the zoom group it is in\n     *\n     * @param elem - the elem that should should be \"unganged\"\n     *\n     * @return - The elem manager instance.\n     */\n    ElementManager.prototype.removeFromHighlightGroup = function (elem) {\n        this.removeFromGroup(elem, 1 /* Highlight */);\n        return this;\n    };\n    /**\n     * set the group to select this elem with\n     *\n     * @param elem - the elem that should should be \"ganged\"\n     * @param groupName - Name of the group that this elem should be \"ganged\"\n     *   with.\n     *\n     * @return - The elem manager instance.\n     */\n    ElementManager.prototype.addToRenderGroup = function (elem, groupName) {\n        addRenderCallback(elem);\n        this.removeFromRenderGroup(elem);\n        this.addToGroup(elem, groupName, 2 /* Render */);\n        if (!elem.handleUpdate) {\n            elem.handleUpdate = this._onUpdateCallback;\n        }\n        return this;\n    };\n    /**\n     * remove the elem from the zoom group it is in\n     *\n     * @param elem - the elem that should should be \"unganged\"\n     *\n     * @return - The elem manager instance.\n     */\n    ElementManager.prototype.removeFromRenderGroup = function (elem) {\n        this.removeFromGroup(elem, 2 /* Render */);\n        return this;\n    };\n    /** clear all the elements in this list */\n    ElementManager.prototype.clear = function () {\n        this._elems.length = 0;\n        this._groupInfo.length = 0;\n        for (var i = 0; i < 3 /* None */; ++i) {\n            this._groupInfo.push(new GroupInfo());\n        }\n    };\n    return ElementManager;\n}());\nexports.ElementManager = ElementManager;\n\n\n//# sourceURL=webpack://UWT/./src/core/element-manager.ts?");

/***/ }),

/***/ "./src/core/utilities.ts":
/*!*******************************!*\
  !*** ./src/core/utilities.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getSelectionName(className) {\n    if (typeof (className) === 'number') {\n        return 'n' + className;\n    }\n    if (!className) {\n        return '';\n    }\n    if (className.length > 0 && !isNaN(Number(className[0]))) {\n        className = 'z' + className;\n    }\n    className = className.replace(/[\\*\\%\\#\\[\\]\\/\\>\\<\\s\\+\\(\\)\\;\\@\\:\\?\\\"=.,]/g, '-');\n    return className;\n}\nexports.getSelectionName = getSelectionName;\n/**\n* detect IE\n* returns version of IE or false, if browser is not Internet Explorer\n*/\n// from https://codepen.io/gapcode/pen/vEJNZN\nfunction detectIE() {\n    var ua = window.navigator.userAgent;\n    // Test values; Uncomment to check result \n    // IE 10\n    // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n    // IE 11\n    // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n    // Edge 12 (Spartan)\n    // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n    // Edge 13\n    // ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586';\n    var msie = ua.indexOf('MSIE ');\n    if (msie > 0) {\n        // IE 10 or older => return version number\n        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n    }\n    var trident = ua.indexOf('Trident/');\n    if (trident > 0) {\n        // IE 11 => return version number\n        var rv = ua.indexOf('rv:');\n        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n    }\n    var edge = ua.indexOf('Edge/');\n    if (edge > 0) {\n        // Edge (IE 12+) => return version number\n        return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n    }\n    // other browser\n    return false;\n}\nexports.detectIE = detectIE;\n// from https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent\n// polyfill for old version of IE\nfunction useIEPolyfill(window) {\n    try {\n        new CustomEvent('test'); // No need to polyfill\n    }\n    catch (e) {\n        // Polyfills DOM4 CustomEvent\n        var MouseEvent_1 = function (eventType, params) {\n            params = params || { bubbles: false, cancelable: false };\n            var mouseEvent = document.createEvent('MouseEvent');\n            mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n            return mouseEvent;\n        };\n        MouseEvent_1.prototype = Event.prototype;\n        window.MouseEvent = MouseEvent_1;\n    }\n}\nexports.useIEPolyfill = useIEPolyfill;\nfunction removeFromList(value, arr) {\n    if (value) {\n        var index = arr.indexOf(value);\n        if (index !== -1) {\n            arr.splice(index, 1);\n        }\n    }\n}\nexports.removeFromList = removeFromList;\n/** taken from d3-array */\nfunction ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n/** taken from d3-array */\nfunction ascendingComparator(f) {\n    return function (d, x) {\n        return ascending(f(d), x);\n    };\n}\n/** modified from d3-array */\nfunction bisect(compare) {\n    if (!compare)\n        compare = ascending;\n    if (compare.length === 1)\n        compare = ascendingComparator(compare);\n    return {\n        left: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length;\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a[mid], x) < 0)\n                    lo = mid + 1;\n                else\n                    hi = mid;\n            }\n            return lo;\n        },\n        right: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length;\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a[mid], x) > 0)\n                    hi = mid;\n                else\n                    lo = mid + 1;\n            }\n            return lo;\n        }\n    };\n}\nexports.bisect = bisect;\n/** puts all raw data into buckets based on thresholds and values */\nfunction bucketData(values, thresholds, accessor) {\n    var findRight = bisect().right;\n    var buckets = [];\n    // need one less bucket than thresholds\n    for (var i = 0; i < thresholds.length - 1; ++i) {\n        buckets[i] = [];\n    }\n    var min = thresholds[0];\n    var max = thresholds[thresholds.length - 1];\n    var usedThresholds = thresholds.slice(1);\n    for (var i = 0; i < values.length; ++i) {\n        var compareValue = accessor(values[i]);\n        if (compareValue < min || compareValue > max) {\n            continue;\n        }\n        var valueIdx = findRight(usedThresholds, compareValue);\n        buckets[valueIdx].push(values[i]);\n    }\n    // name the return buckets\n    var ret = {};\n    for (var i = 0; i < thresholds.length - 1; ++i) {\n        var bucketName = thresholds[i] + '-' + thresholds[i + 1];\n        ret[bucketName] = buckets[i];\n    }\n    return ret;\n}\nexports.bucketData = bucketData;\nfunction copy(obj) {\n    var ret = {};\n    for (var key in obj) {\n        ret[key] = obj[key];\n    }\n    return ret;\n}\nexports.copy = copy;\nfunction merge(obj1, obj2) {\n    for (var key in obj2) {\n        obj1[key] = obj2[key];\n    }\n}\nexports.merge = merge;\nfunction convertTraceToTrees(input) {\n    var roots = [];\n    var stack = []; // used to represent the current stack state\n    var nodeStack = []; // used to represent the current stack state\n    for (var i = 0; i < input.length; i++) {\n        var value = input[i];\n        var parent_1 = stack[stack.length - 1];\n        // pop stuff off the stack\n        while (stack.length && value.x > parent_1.x + parent_1.dx) {\n            --stack.length;\n            --nodeStack.length;\n            parent_1 = stack[stack.length - 1];\n        }\n        var parentNode = nodeStack[nodeStack.length - 1];\n        var node = {\n            key: value.key,\n            value: value.dx,\n            children: [],\n            parent: parentNode\n        };\n        if (value.name) {\n            node.name = value.name;\n        }\n        if (parentNode) {\n            parentNode.children.push(node);\n        }\n        else {\n            roots.push(node);\n        }\n        stack.push(value);\n        nodeStack.push(node);\n    }\n    return roots;\n}\nexports.convertTraceToTrees = convertTraceToTrees;\nvar SimpleBuffer = /** @class */ (function () {\n    function SimpleBuffer(data) {\n        if (data) {\n            this._data = data;\n        }\n        else {\n            this._data = [];\n        }\n    }\n    SimpleBuffer.prototype.push = function (d) {\n        this._data.push(d);\n    };\n    SimpleBuffer.prototype.get = function (index) {\n        return this._data[index];\n    };\n    SimpleBuffer.prototype.length = function () {\n        return this._data.length;\n    };\n    SimpleBuffer.prototype.getData = function () {\n        return this._data;\n    };\n    return SimpleBuffer;\n}());\nexports.SimpleBuffer = SimpleBuffer;\nvar RingBuffer = /** @class */ (function () {\n    function RingBuffer(size) {\n        this._data = new Array(size);\n        this._startIdx = 0;\n        this._count = 0;\n        this._isRotating = false;\n    }\n    /** add a new value to the buffer */\n    RingBuffer.prototype.push = function (d) {\n        if (this._isRotating) {\n            // the buffer is rotating\n            this._data[this._startIdx] = d;\n            ++this._startIdx;\n            if (this._startIdx === this._count) {\n                this._startIdx = 0;\n            }\n            this._isRotating = true;\n        }\n        else if (this._count === this._data.length - 1) {\n            // here the buffer will start rotating as the buffer is full\n            this._data[this._count] = d;\n            ++this._count;\n            this._isRotating = true;\n        }\n        else {\n            // here the buffer has not been filled yet\n            this._data[this._count] = d;\n            ++this._count;\n        }\n    };\n    /** return the value offset index from the start index\n     * @param index the offset from the start of the buffer\n     */\n    RingBuffer.prototype.get = function (index) {\n        if (this._isRotating) {\n            // the buffer is rotating\n            index = index + this._startIdx;\n            if (index >= this._count) {\n                index = index - this._count;\n            }\n        }\n        return this._data[index];\n    };\n    /** get the number of items in the buffer */\n    RingBuffer.prototype.length = function () {\n        return this._count;\n    };\n    RingBuffer.prototype.getData = function () {\n        if (this._isRotating) {\n            // the buffer is rotating\n            var ret = [];\n            for (var i = this._startIdx; i < this._data.length; ++i) {\n                ret.push(this._data[i]);\n            }\n            for (var i = 0; i < this._startIdx; ++i) {\n                ret.push(this._data[i]);\n            }\n            return ret;\n        }\n        return this._data;\n    };\n    return RingBuffer;\n}());\nexports.RingBuffer = RingBuffer;\nfunction bisectBuffer(compare) {\n    if (!compare)\n        compare = ascending;\n    if (compare.length === 1)\n        compare = ascendingComparator(compare);\n    return {\n        left: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length();\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a.get(mid), x) < 0)\n                    lo = mid + 1;\n                else\n                    hi = mid;\n            }\n            return lo;\n        },\n        right: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length();\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a.get(mid), x) > 0)\n                    hi = mid;\n                else\n                    lo = mid + 1;\n            }\n            return lo;\n        }\n    };\n}\nexports.bisectBuffer = bisectBuffer;\nfunction transposeKeys(data) {\n    // this is used to map the keys to their indicies in the output summary data\n    var keyIdxMapping = {};\n    function transposeHelper(output, parentKeys, value, level) {\n        var myKeys = [];\n        for (var i = 0; i < parentKeys.length; ++i) {\n            myKeys[i] = parentKeys[i];\n        }\n        myKeys.push(value.key);\n        if (Array.isArray(value.data)) {\n            for (var i = 0; i < value.data.length; ++i) {\n                transposeHelper(output, myKeys, value.data[i], level + 1);\n            }\n        }\n        else {\n            var currSummaryArray = output;\n            for (var keyIdx = myKeys.length - 1; keyIdx >= 0; --keyIdx) {\n                var key = myKeys[keyIdx];\n                var dataIdx = void 0;\n                if (!keyIdxMapping.hasOwnProperty(key)) {\n                    dataIdx = currSummaryArray.length;\n                    keyIdxMapping[key] = dataIdx;\n                }\n                else {\n                    dataIdx = keyIdxMapping[key];\n                }\n                // create the summary data if it doesn't exist yet\n                if (!currSummaryArray[dataIdx]) {\n                    currSummaryArray[dataIdx] = { key: key, data: [] };\n                }\n                // if we are the leaf add the data, else just move to the next level\n                if (keyIdx === 0) {\n                    currSummaryArray[dataIdx].data = value.data;\n                }\n                else {\n                    currSummaryArray = currSummaryArray[dataIdx].data;\n                }\n            }\n        }\n    }\n    var output = [];\n    for (var i = 0; i < data.length; ++i) {\n        transposeHelper(output, [], data[i], 0);\n    }\n    return output;\n}\nexports.transposeKeys = transposeKeys;\nfunction runFunctionOnLeaf(node, func) {\n    if (node && node.children && node.children.length > 0) {\n        for (var i = 0; i < node.children.length; ++i) {\n            runFunctionOnLeaf(node.children[i], func);\n        }\n    }\n    else {\n        func(node);\n    }\n}\nexports.runFunctionOnLeaf = runFunctionOnLeaf;\n\n\n//# sourceURL=webpack://UWT/./src/core/utilities.ts?");

/***/ }),

/***/ "./src/interface/grid.ts":
/*!*******************************!*\
  !*** ./src/interface/grid.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Column = /** @class */ (function () {\n    function Column(headerName, field) {\n        this.headerName = headerName;\n        if (!field) {\n            this.field = headerName;\n        }\n        else {\n            this.field = field;\n        }\n    }\n    return Column;\n}());\nexports.Column = Column;\n\n\n//# sourceURL=webpack://UWT/./src/interface/grid.ts?");

/***/ }),

/***/ "./src/interface/ui-base.ts":
/*!**********************************!*\
  !*** ./src/interface/ui-base.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n;\n/**\n * Represents a relative alignment\n*/\nvar Alignment;\n(function (Alignment) {\n    Alignment[Alignment[\"Left\"] = 1] = \"Left\";\n    Alignment[Alignment[\"Right\"] = 2] = \"Right\";\n    Alignment[Alignment[\"Top\"] = 4] = \"Top\";\n    Alignment[Alignment[\"Bottom\"] = 8] = \"Bottom\";\n    Alignment[Alignment[\"None\"] = 0] = \"None\";\n})(Alignment = exports.Alignment || (exports.Alignment = {}));\n; // bitmask Position\nvar EventType;\n(function (EventType) {\n    EventType[EventType[\"CursorStart\"] = 0] = \"CursorStart\";\n    EventType[EventType[\"CursorMove\"] = 1] = \"CursorMove\";\n    EventType[EventType[\"CursorEnd\"] = 2] = \"CursorEnd\";\n    EventType[EventType[\"BrushStart\"] = 3] = \"BrushStart\";\n    EventType[EventType[\"BrushMove\"] = 4] = \"BrushMove\";\n    EventType[EventType[\"BrushEnd\"] = 5] = \"BrushEnd\";\n    EventType[EventType[\"HoverStart\"] = 6] = \"HoverStart\";\n    EventType[EventType[\"HoverEnd\"] = 7] = \"HoverEnd\";\n    EventType[EventType[\"HoverClear\"] = 8] = \"HoverClear\";\n    EventType[EventType[\"Zoom\"] = 9] = \"Zoom\";\n    EventType[EventType[\"Click\"] = 10] = \"Click\";\n    EventType[EventType[\"DoubleClick\"] = 11] = \"DoubleClick\";\n})(EventType = exports.EventType || (exports.EventType = {}));\nvar UIType;\n(function (UIType) {\n    UIType[UIType[\"Unrendered\"] = 0] = \"Unrendered\";\n    UIType[UIType[\"Cartesian\"] = 1] = \"Cartesian\";\n    UIType[UIType[\"Pie\"] = 2] = \"Pie\";\n    UIType[UIType[\"Grid\"] = 3] = \"Grid\";\n    UIType[UIType[\"FlowDiagram\"] = 4] = \"FlowDiagram\";\n    UIType[UIType[\"ForceDirectedGraph\"] = 5] = \"ForceDirectedGraph\";\n    UIType[UIType[\"Sunburst\"] = 6] = \"Sunburst\";\n    UIType[UIType[\"HierarchyGraph\"] = 7] = \"HierarchyGraph\";\n    UIType[UIType[\"PortDiagram\"] = 8] = \"PortDiagram\";\n    UIType[UIType[\"SimpleGraph\"] = 9] = \"SimpleGraph\";\n    UIType[UIType[\"TreeMap\"] = 10] = \"TreeMap\";\n})(UIType = exports.UIType || (exports.UIType = {}));\nvar LegendType;\n(function (LegendType) {\n    LegendType[LegendType[\"Discrete\"] = 0] = \"Discrete\";\n    LegendType[LegendType[\"Gradient\"] = 1] = \"Gradient\";\n})(LegendType = exports.LegendType || (exports.LegendType = {}));\nvar LegendOrientation;\n(function (LegendOrientation) {\n    LegendOrientation[LegendOrientation[\"Vertical\"] = 0] = \"Vertical\";\n    LegendOrientation[LegendOrientation[\"Horizontal\"] = 1] = \"Horizontal\";\n})(LegendOrientation = exports.LegendOrientation || (exports.LegendOrientation = {}));\nvar LegendItemShape;\n(function (LegendItemShape) {\n    LegendItemShape[LegendItemShape[\"Rectangle\"] = 0] = \"Rectangle\";\n    LegendItemShape[LegendItemShape[\"Line\"] = 1] = \"Line\";\n    LegendItemShape[LegendItemShape[\"Circle\"] = 2] = \"Circle\";\n})(LegendItemShape = exports.LegendItemShape || (exports.LegendItemShape = {}));\n// Represents a rectangular area.\nvar Rect = /** @class */ (function () {\n    function Rect(x, y, width, height) {\n        this.x = 0;\n        this.y = 0;\n        this.width = 0;\n        this.height = 0;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    // Returns true if the rectangle contains (x,y).\n    Rect.prototype.contains = function (x, y) {\n        return (x >= this.x && x <= this.x + this.width &&\n            y >= this.y && y <= this.y + this.height);\n    };\n    return Rect;\n}());\nexports.Rect = Rect;\n/**\n * Used to manipulate CSS class and style information\n */\nvar Css = /** @class */ (function () {\n    function Css(classes, style) {\n        if (classes) {\n            this.addClasses(classes);\n        }\n        else {\n            this.classes = {};\n        }\n        if (style) {\n            this.style = style;\n        }\n        else {\n            this.style = {};\n        }\n    }\n    /**\n     * add a class to the class list\n     * @param classes to add, can be strings separated by spaces\n     *\n     * @return the manager instance\n     */\n    Css.prototype.addClasses = function (classesStr) {\n        var classes = classesStr.split(' ');\n        for (var i = 0; i < classes.length; ++i) {\n            this.classes[classes[i]] = true;\n        }\n        return this;\n    };\n    /**\n     * add a set of styles to the style object\n     * @param style a style object\n     *\n     * @return the manager instance\n     */\n    Css.prototype.addStyles = function (style) {\n        for (var key in style) {\n            this.style[key] = style[key];\n        }\n        return this;\n    };\n    /** set the color value\n     *\n     * @param color a string representing the color to use\n     */\n    Css.prototype.setColor = function (color) {\n        this.addStyles({ color: color });\n        return this;\n    };\n    /** set the opcaity value\n     *\n     * @param opcaity a string representing the color to use\n     */\n    Css.prototype.setOpacity = function (opacity) {\n        this.addStyles({ opacity: opacity });\n        return this;\n    };\n    /**\n     * remove a class from the class list\n     * @param className the class to remove\n     *\n     * @return the manager instance\n     */\n    Css.prototype.removeClass = function (className) {\n        delete this.classes[className];\n        return this;\n    };\n    /**\n     * remove a style from the style map\n     * @param key the name of the style to remove\n     *\n     * @return the manager instance\n     */\n    Css.prototype.removeStyle = function (key) {\n        delete this.style[key];\n        return this;\n    };\n    /**\n     * get the list of classes\n     *\n     * @return a list of classes for this manager\n     */\n    Css.prototype.getClasses = function () {\n        return Object.keys(this.classes);\n    };\n    /**\n     * helper to get a space separated list of classes\n     *\n     * @return a string list of classes for this manager\n     */\n    Css.prototype.getClassString = function () {\n        var ret = '';\n        for (var className in this.classes) {\n            ret += className + ' ';\n        }\n        return ret;\n    };\n    /**\n     * get the style map\n     *\n     * @return an object that contains key/value style pairs\n     */\n    Css.prototype.getStyles = function () {\n        return this.style;\n    };\n    /**\n     * helper to get a json representation of the style map\n     *\n     * @return the json string of the style map\n     */\n    Css.prototype.getStyleString = function () {\n        return JSON.stringify(this.style);\n    };\n    return Css;\n}());\nexports.Css = Css;\n;\n/**\n * implemented a basic API on top of the IRange object\n */\nvar Range = /** @class */ (function () {\n    function Range(min, max) {\n        this.min = min;\n        this.max = max;\n    }\n    /**\n     * set the min value for the range\n     *\n     * @return the min range value\n     */\n    Range.prototype.setMin = function (min) {\n        this.min = min;\n        return this;\n    };\n    /**\n     * get the min value for the range\n     *\n     * @return the min range value\n     */\n    Range.prototype.getMin = function () {\n        return this.min;\n    };\n    /**\n     * set the max value for the range\n     *\n     * @return the max range value\n     */\n    Range.prototype.setMax = function (max) {\n        this.max = max;\n        return this;\n    };\n    /**\n     * get the max value for the range\n     *\n     * @return the max range value\n     */\n    Range.prototype.getMax = function () {\n        return this.max;\n    };\n    return Range;\n}());\nexports.Range = Range;\n\n\n//# sourceURL=webpack://UWT/./src/interface/ui-base.ts?");

/***/ }),

/***/ "ag-grid-community":
/*!***************************************************************************************************************************!*\
  !*** external {"root":"agGrid","commonjs2":"ag-grid-community","amd":"ag-grid-community","commonjs":"ag-grid-community"} ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_ag_grid_community__;\n\n//# sourceURL=webpack://UWT/external_%7B%22root%22:%22agGrid%22,%22commonjs2%22:%22ag-grid-community%22,%22amd%22:%22ag-grid-community%22,%22commonjs%22:%22ag-grid-community%22%7D?");

/***/ })

/******/ });
});