(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("ag-grid-community"), require("es6-promise"));
	else if(typeof define === 'function' && define.amd)
		define("UWT", ["ag-grid-community", "es6-promise"], factory);
	else if(typeof exports === 'object')
		exports["UWT"] = factory(require("ag-grid-community"), require("es6-promise"));
	else
		root["UWT"] = factory(root["agGrid"], root["es6-promise"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_ag_grid_community__, __WEBPACK_EXTERNAL_MODULE_es6_promise__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/build/export.grid.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/build/export.grid.ts":
/*!**********************************!*\
  !*** ./src/build/export.grid.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ../interface/ui-base */ \"./src/interface/ui-base.ts\"));\n__export(__webpack_require__(/*! ../interface/grid */ \"./src/interface/grid.ts\"));\n__export(__webpack_require__(/*! ../core/element-manager */ \"./src/core/element-manager.ts\"));\n__export(__webpack_require__(/*! ../core/color-manager */ \"./src/core/color-manager.ts\"));\n__export(__webpack_require__(/*! ../core/utilities */ \"./src/core/utilities.ts\"));\n__export(__webpack_require__(/*! ../core/web-utilities */ \"./src/core/web-utilities.ts\"));\n__export(__webpack_require__(/*! ../core/ag-grid/ag-grid-renderer */ \"./src/core/ag-grid/ag-grid-renderer.ts\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYnVpbGQvZXhwb3J0LmdyaWQudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9VV1QvLi9zcmMvYnVpbGQvZXhwb3J0LmdyaWQudHM/OWEyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuLi9pbnRlcmZhY2UvdWktYmFzZSc7XG5leHBvcnQgKiBmcm9tICcuLi9pbnRlcmZhY2UvZ3JpZCc7XG5cbmV4cG9ydCAqIGZyb20gJy4uL2NvcmUvZWxlbWVudC1tYW5hZ2VyJztcbmV4cG9ydCAqIGZyb20gJy4uL2NvcmUvY29sb3ItbWFuYWdlcic7XG5leHBvcnQgKiBmcm9tICcuLi9jb3JlL3V0aWxpdGllcyc7XG5leHBvcnQgKiBmcm9tICcuLi9jb3JlL3dlYi11dGlsaXRpZXMnO1xuZXhwb3J0ICogZnJvbSAnLi4vY29yZS9hZy1ncmlkL2FnLWdyaWQtcmVuZGVyZXInO1xuIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/build/export.grid.ts\n");

/***/ }),

/***/ "./src/core/ag-grid/ag-grid-renderer.ts":
/*!**********************************************!*\
  !*** ./src/core/ag-grid/ag-grid-renderer.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ui_base_1 = __webpack_require__(/*! ../../interface/ui-base */ \"./src/interface/ui-base.ts\");\nconst utilities_1 = __webpack_require__(/*! ../utilities */ \"./src/core/utilities.ts\");\nconst color_manager_1 = __webpack_require__(/*! ../color-manager */ \"./src/core/color-manager.ts\");\nconst context_menu_1 = __webpack_require__(/*! ../context-menu */ \"./src/core/context-menu.ts\");\nconst agGrid = __webpack_require__(/*! ag-grid-community */ \"ag-grid-community\");\n// from https://www.ag-grid.com/best-javascript-data-grid/#gsc.tab=0\nfunction percentCellRenderer(params) {\n    var value = params.value;\n    if (value === undefined || value === null) {\n        value = 0;\n    }\n    var percentBar = document.createElement('div');\n    percentBar.className = 'div-percent-bar';\n    percentBar.style.width = value + '%';\n    percentBar.style.height = '25px';\n    percentBar.style.backgroundColor = '#B3E5FC';\n    percentBar.innerHTML = value.toFixed(2) + '%';\n    return percentBar;\n}\nexports.percentCellRenderer = percentCellRenderer;\nfunction computeMaxAndPercentage(rowData, columns) {\n    let columnMax = {};\n    let total = {};\n    for (let i = 0; i < columns.length; ++i) {\n        let column = columns[i];\n        if (!columnMax[column.field]) {\n            columnMax[column.field] = 0;\n        }\n        if (!total[column.field]) {\n            total[column.field] = 0;\n        }\n        for (let j = 0; j < rowData.length; ++j) {\n            if (rowData[j][column.field]) {\n                if (rowData[j][column.field].value) {\n                    rowData[j][column.field] = rowData[j][column.field].value;\n                }\n                columnMax[column.field] = Math.max(columnMax[column.field], rowData[j][column.field]);\n                total[column.field] += rowData[j][column.field];\n            }\n        }\n    }\n    for (let i = 0; i < columns.length; ++i) {\n        let column = columns[i];\n        for (let j = 0; j < rowData.length; ++j) {\n            rowData[j][column.field] = {\n                value: rowData[j][column.field],\n                columnMax: columnMax[column.field],\n                total: total[column.field]\n            };\n        }\n    }\n}\nexports.computeMaxAndPercentage = computeMaxAndPercentage;\nfunction valueCellRenderer(params) {\n    let value = params.value;\n    value.value = value.value ? value.value : 0;\n    let percentBar = document.createElement('div');\n    let barWidth = value.columnMax ? (value.value / value.columnMax * 100) : 0;\n    let percent = value.total ? (value.value / value.total * 100) : 0;\n    percentBar.className = 'div-percent-bar';\n    percentBar.style.height = '25px';\n    percentBar.style.backgroundColor = '#B3E5FC';\n    percentBar.style.width = barWidth + '%';\n    if (params.colDef.showAsPercentage) {\n        percentBar.innerHTML = percent.toFixed(2) + '%';\n        percentBar.title = percent.toFixed(2) + '% (' + 'Value: ' + value.value + ')';\n    }\n    else {\n        percentBar.innerHTML = value.value.toFixed(2);\n        percentBar.title = 'Value: ' + value.value + ' (' + percent.toFixed(2) + '%)';\n    }\n    return percentBar;\n}\nexports.valueCellRenderer = valueCellRenderer;\nfunction valueComparator(valueA, valueB, nodeA, nodeB, isInverted) {\n    return valueA.value - valueB.value;\n}\nexports.valueComparator = valueComparator;\nexports.menuItemShowAsPercentage = {\n    title: 'Display Percentage', action: function (elem, data, index) {\n        let idx = data.colDef.contextMenuItems.indexOf(exports.menuItemShowAsPercentage);\n        data.colDef.contextMenuItems[idx] = exports.menuItemShowAsTotal;\n        data.colDef.showAsPercentage = true;\n        data.api.refreshCells({ columns: [data.colDef], force: true });\n    }\n};\nexports.menuItemShowAsTotal = {\n    title: 'Display Raw Values', action: function (elem, data, index) {\n        let idx = data.colDef.contextMenuItems.indexOf(exports.menuItemShowAsTotal);\n        data.colDef.contextMenuItems = [exports.menuItemShowAsPercentage];\n        data.colDef.showAsPercentage = false;\n        data.api.refreshCells({ columns: [data.colDef], force: true });\n    }\n};\nclass AgGrid {\n    /**\n     * Append the div for this graph to the parent div. The div we create\n     * will be filled when Render() is called\n     *\n     * @param parent - The div that will contain the div for this chart.\n     *\n     * @return - The chart instance\n     */\n    constructor(element, renderer, parent, options = {}) {\n        this._element = element;\n        this._renderer = renderer;\n        this._options = options;\n        this._disableCallbacks = false;\n        if (parent) {\n            this._div = document.querySelector(parent);\n        }\n        let self = this;\n        let defaultCallback = function (row, eventType, callback) {\n            if (self._disableCallbacks) {\n                return;\n            }\n            let grid = self._element;\n            let gridOptions = grid.gridOptions;\n            if (callback) {\n                let columns = gridOptions.columnApi.getAllColumns();\n                if (columns && columns.length > 0) {\n                    let key = columns[0].colDef.field;\n                    let selection = row.node.data[key];\n                    let event = {\n                        caller: grid,\n                        selection: selection,\n                        event: eventType,\n                        data: { row: row }\n                    };\n                    callback(event);\n                }\n            }\n        };\n        this.onRowFocusDefaultCallback = function (row) {\n            defaultCallback(row, ui_base_1.EventType.HoverStart, self._element.onHover);\n        };\n        this.onRowUnfocusDefaultCallback = function (row) {\n            defaultCallback(row, ui_base_1.EventType.HoverEnd, self._element.onHover);\n        };\n        this.onRowSelectedDefaultCallback = function (row) {\n            let eventType = row.node.isSelected() ?\n                ui_base_1.EventType.SelectAdd : ui_base_1.EventType.SelectRemove;\n            defaultCallback(row, eventType, self._element.onClick);\n        };\n        this.api = {\n            select: self.select,\n            hover: self.select\n        };\n        this.keyboardSelectionFocus = function (params) {\n            var previousCell = params.previousCellDef;\n            var suggestedNextCell = params.nextCellDef;\n            var KEY_UP = 38;\n            var KEY_DOWN = 40;\n            var KEY_LEFT = 37;\n            var KEY_RIGHT = 39;\n            let columns = self._element.gridOptions.columnApi.getAllColumns();\n            if (columns && columns.length > 0) {\n                let selectionKey = self._element.gridOptions.selectionKey ?\n                    self._element.gridOptions.selectionKey : columns[0].colDef.field;\n                let helper = function (index) {\n                    previousCell = params.previousCellDef;\n                    // set selected cell on current cell + 1\n                    self._element.gridOptions.api.forEachNode((node) => {\n                        if (index === node.rowIndex) {\n                            node.setSelected(true);\n                        }\n                        else if (!params.event.shiftKey) {\n                            self._renderer.focus(self._element, {\n                                event: ui_base_1.EventType.HoverEnd,\n                                selection: utilities_1.getSelectionName(node.data[selectionKey])\n                            });\n                        }\n                    });\n                    return suggestedNextCell;\n                };\n                switch (params.key) {\n                    case KEY_DOWN:\n                        return helper(previousCell.rowIndex + 1);\n                    case KEY_UP:\n                        return helper(previousCell.rowIndex - 1);\n                    case KEY_LEFT:\n                    case KEY_RIGHT:\n                        return suggestedNextCell;\n                    default:\n                        throw \"this will never happen, navigation is always on of the 4 keys above\";\n                }\n            }\n        };\n    }\n    setDiv(div) {\n        this._div = div;\n    }\n    select(event) {\n        let self = this;\n        let selection = event.selection;\n        // make typescript happy to hardcode some things\n        let gridOptions = this._element.gridOptions;\n        let columns = gridOptions.columnApi.getAllColumns();\n        self._disableCallbacks = true;\n        if (columns && columns.length > 0) {\n            let selectionKey = gridOptions.selectionKey ? gridOptions.selectionKey :\n                columns[0].colDef.field;\n            let key = event.selectionKey ? event.selectionKey : selectionKey;\n            if (event.event === ui_base_1.EventType.SelectAdd ||\n                event.event === ui_base_1.EventType.HoverStart) {\n                this._prevSelection = event.selection;\n                gridOptions.api.forEachNode(function (rowNode) {\n                    if (utilities_1.getSelectionName(rowNode.data[key]) === utilities_1.getSelectionName(selection)) {\n                        // select the node\n                        rowNode.setSelected(true);\n                        if (self._element.gridOptions.autoScrollToSelection) {\n                            gridOptions.api.ensureNodeVisible(rowNode, 'middle');\n                        }\n                    }\n                });\n            }\n            else if (event.event === ui_base_1.EventType.SelectClear ||\n                event.event === ui_base_1.EventType.HoverClear) {\n                gridOptions.api.deselectAll();\n            }\n            else {\n                if (!event.selection) {\n                    selection = self._prevSelection;\n                }\n                gridOptions.api.forEachNode(function (rowNode) {\n                    if (utilities_1.getSelectionName(rowNode.data[key]) === utilities_1.getSelectionName(selection)) {\n                        // deselect the node\n                        rowNode.setSelected(false);\n                        // clear the previous selection if it's what we just removed\n                        if (event.selection === self._prevSelection) {\n                            self._prevSelection = undefined;\n                        }\n                    }\n                });\n            }\n        }\n        self._disableCallbacks = false;\n    }\n    setContextMenuItems(columnDefs, contextMenuItems) {\n        if (columnDefs) {\n            if (!contextMenuItems) {\n                contextMenuItems = [];\n            }\n            for (let i = 0; i < columnDefs.length; ++i) {\n                let column = columnDefs[i];\n                column.onCellContextMenu = function (cell) {\n                    context_menu_1.showContextMenu(cell.event, cell, cell.colDef.contextMenuItems ? contextMenuItems.concat(cell.colDef.contextMenuItems) : contextMenuItems);\n                };\n                if (column.children) {\n                    this.setContextMenuItems(column.children, contextMenuItems);\n                }\n            }\n        }\n    }\n    invalidate(options = {}) {\n        let self = this;\n        // make typescript happy to hardcode some things\n        let gridOptions = this._element.gridOptions;\n        // required to allow the select api to not end up in a infinite loop\n        gridOptions.suppressAsyncEvents = true;\n        gridOptions.animateRows = gridOptions.animateRows !== undefined ?\n            gridOptions.animateRows : true;\n        gridOptions.rowSelection = gridOptions.rowSelection !== undefined ?\n            gridOptions.rowSelection : 'multiple';\n        gridOptions.rowDeselection = gridOptions.rowDeselection !== undefined ?\n            gridOptions.rowDeselection : true;\n        gridOptions.suppressScrollOnNewData = gridOptions.suppressScrollOnNewData !== undefined ?\n            gridOptions.suppressScrollOnNewData : true;\n        gridOptions.suppressPropertyNamesCheck = gridOptions.suppressPropertyNamesCheck !== undefined ?\n            gridOptions.suppressPropertyNamesCheck : true;\n        gridOptions.defaultColDef = gridOptions.defaultColDef !== undefined ?\n            gridOptions.defaultColDef : {};\n        gridOptions.defaultColDef.sortable = gridOptions.defaultColDef.sortable !== undefined ?\n            gridOptions.defaultColDef.sortable : true;\n        gridOptions.defaultColDef.resizable = gridOptions.defaultColDef.resizable !== undefined ?\n            gridOptions.defaultColDef.resizable : true;\n        gridOptions.defaultColDef.filter = gridOptions.defaultColDef.filter !== undefined ?\n            gridOptions.defaultColDef.filter : true;\n        gridOptions.autoScrollToSelection = gridOptions.autoScrollToSelection !== undefined ?\n            gridOptions.autoScrollToSelection : true;\n        let wrapCallback = function (userCallback, defaultCallback, eventType) {\n            if (!userCallback) {\n                return defaultCallback;\n            }\n            else {\n                return function (row) {\n                    if (self._disableCallbacks) {\n                        return;\n                    }\n                    userCallback({\n                        caller: self._element,\n                        event: eventType,\n                        data: { row: row.node.data }\n                    });\n                };\n            }\n        };\n        gridOptions.onCellMouseOver = wrapCallback(gridOptions.onCellMouseOver, this.onRowFocusDefaultCallback, ui_base_1.EventType.HoverStart);\n        gridOptions.cellMouseOut = wrapCallback(gridOptions.onCellMouseOver, this.onRowUnfocusDefaultCallback, ui_base_1.EventType.HoverEnd);\n        gridOptions.onRowClicked = wrapCallback(gridOptions.onRowClicked, undefined, undefined);\n        gridOptions.onRowDoubleClicked = wrapCallback(gridOptions.onRowDoubleClicked, undefined, undefined);\n        if (gridOptions.onClick) {\n            gridOptions.onRowClicked = wrapCallback(gridOptions.onClick, undefined, undefined);\n        }\n        if (gridOptions.onDoubleClick) {\n            gridOptions.onRowDoubleClicked = wrapCallback(gridOptions.onDoubleClick, undefined, undefined);\n        }\n        if (!gridOptions.onRowSelected) {\n            gridOptions.onRowSelected = this.onRowSelectedDefaultCallback;\n        }\n        else {\n            if (!gridOptions.userOnRowSelected) {\n                gridOptions.userOnRowSelected = gridOptions.onRowSelected;\n            }\n            gridOptions.onRowSelected = function (row) {\n                if (self._disableCallbacks) {\n                    return;\n                }\n                // TODO handle multiple selection clear correctly\n                gridOptions.userOnRowSelected({\n                    caller: self._element,\n                    data: {\n                        row: row.node.data,\n                        isSelected: row.node.selected\n                    },\n                    event: row.node.selected ? ui_base_1.EventType.SelectAdd : ui_base_1.EventType.SelectRemove\n                });\n            };\n        }\n        let hasGrouping = false;\n        if (gridOptions.rowData && !gridOptions.getNodeChildDetails) {\n            for (let i = 0; i < gridOptions.rowData.length; ++i) {\n                let row = gridOptions.rowData[i];\n                if (row.children && row.children.length > 0) {\n                    hasGrouping = true;\n                    break;\n                }\n            }\n        }\n        if (gridOptions.columnDefs) {\n            let valueCellRendererColumns = [];\n            for (let i = 0; i < gridOptions.columnDefs.length; ++i) {\n                let column = gridOptions.columnDefs[i];\n                if (column.canShowPercentage || column.showAsPercentage || column.showAsBar) {\n                    valueCellRendererColumns.push(column);\n                    column.cellRenderer = valueCellRenderer;\n                    column.comparator = valueComparator;\n                    if (!column.contextMenuItems) {\n                        column.contextMenuItems = [];\n                    }\n                    let idx = 0;\n                    if (column.showAsPercentage) {\n                        idx = column.contextMenuItems.indexOf(exports.menuItemShowAsPercentage);\n                        if (idx !== -1) {\n                            column.contextMenuItems[i] = exports.menuItemShowAsTotal;\n                        }\n                        else {\n                            idx = column.contextMenuItems.indexOf(exports.menuItemShowAsTotal);\n                            if (idx === -1) {\n                                column.contextMenuItems.push(exports.menuItemShowAsTotal);\n                            }\n                        }\n                    }\n                    else if (column.canShowPercentage) {\n                        idx = column.contextMenuItems.indexOf(exports.menuItemShowAsTotal);\n                        if (idx !== -1) {\n                            column.contextMenuItems[i] = exports.menuItemShowAsPercentage;\n                        }\n                        else {\n                            idx = column.contextMenuItems.indexOf(exports.menuItemShowAsPercentage);\n                            if (idx === -1) {\n                                column.contextMenuItems.push(exports.menuItemShowAsPercentage);\n                            }\n                        }\n                    }\n                }\n                if (column.onCellClicked) {\n                    let onClick = column.onCellClicked;\n                    column.onCellClicked = function (params) {\n                        onClick({\n                            caller: self._element,\n                            data: { cell: params }\n                        });\n                    };\n                }\n                if (column.onCellDoubleClicked) {\n                    let onDoubleClick = column.onCellDoubleClicked;\n                    column.onCellDoubleClicked = function (params) {\n                        onDoubleClick({\n                            caller: self._element,\n                            data: { cell: params }\n                        });\n                    };\n                }\n            }\n            if (hasGrouping && gridOptions.columnDefs.length > 0) {\n                let groupCol = gridOptions.columnDefs[0];\n                groupCol.cellRenderer = 'agGroupCellRenderer';\n                groupCol.cellRendererParams = {\n                    innerRenderer: (params) => { return params.data[groupCol.field]; },\n                    suppressCount: true\n                };\n                gridOptions.getNodeChildDetails = (rowItem) => {\n                    if (rowItem.children) {\n                        return {\n                            group: true,\n                            expanded: rowItem.expanded,\n                            children: rowItem.children,\n                            key: rowItem[groupCol.field]\n                        };\n                    }\n                    else {\n                        return null;\n                    }\n                };\n            }\n            if (valueCellRendererColumns.length > 0) {\n                computeMaxAndPercentage(gridOptions.rowData, valueCellRendererColumns);\n            }\n        }\n        if (gridOptions.enableSingleKeyboardSelection) {\n            gridOptions.navigateToNextCell = this.keyboardSelectionFocus;\n        }\n        let noContextMenu = gridOptions.contextMenuItems == undefined;\n        if (gridOptions.columnDefs) {\n            for (let i = 0; noContextMenu && i < gridOptions.columnDefs.length; ++i) {\n                let column = gridOptions.columnDefs[i];\n                if (column.contextMenuItems) {\n                    noContextMenu = false;\n                }\n            }\n        }\n        if (!noContextMenu) {\n            this.setContextMenuItems(gridOptions.columnDefs, gridOptions.contextMenuItems);\n        }\n        while (this._div.firstChild) {\n            this._div.removeChild(this._div.firstChild);\n        }\n        if (!this._element.api) {\n            this._element.api = { select: undefined, hover: undefined };\n        }\n        this._element.api.select = function (event) {\n            self.select(event);\n        };\n        this._element.api.hover = this._element.api.select;\n        new agGrid.Grid(this._div, this._element.gridOptions); //create a new grid\n    }\n}\nclass AgGridRenderer {\n    constructor(parent, options = {}, colorMgr = new color_manager_1.ColorManager()) {\n        this.invalidate = this.render;\n        this._parent = parent;\n        this._rendererMap = new WeakMap();\n        this._options = options;\n        this._colorMgr = colorMgr;\n    }\n    getColorManager() {\n        return this._colorMgr;\n    }\n    setOnRenderCallback(callback) {\n        this.onRender = callback;\n    }\n    /** update any options */\n    setOptions(options) {\n        for (let key in options) {\n            this._options[key] = options[key];\n        }\n    }\n    /** @deprecated ('Deprecated since 1.14.0 in favor of focus.  Will be removed in 2.x') */\n    hover(element, event) {\n        this.focus(element, event);\n    }\n    focus(element, event) {\n        console.debug('currently no focus events can be created for the grid');\n    }\n    select(element, event) {\n        if (this._rendererMap.has(element)) {\n            return this._rendererMap.get(element).api.select(event);\n        }\n    }\n    setDiv(element, div) {\n        if (!this._rendererMap.has(element)) {\n            if (element.type === ui_base_1.UIType.Grid) {\n                this._rendererMap.set(element, new AgGrid(element, this));\n            }\n        }\n        if (this._rendererMap.has(element)) {\n            this._rendererMap.get(element).setDiv(div);\n        }\n    }\n    /**\n     * Render the given element\n     *\n     * @param the element to render\n     */\n    render(element, options = {}) {\n        let self = this;\n        element.renderer = this;\n        if (!this._rendererMap.has(element)) {\n            if (element.type === ui_base_1.UIType.Grid) {\n                this._rendererMap.set(element, new AgGrid(element, this, this._parent));\n            }\n        }\n        if (this._rendererMap.has(element)) {\n            this._rendererMap.get(element).invalidate(options);\n            if (this.onRender) {\n                this.onRender(element, options);\n            }\n        }\n    }\n    /**\n     * free the resources used by the renderer for this element\n     */\n    destroy(element) {\n        this._rendererMap.delete(element);\n    }\n    getOptions() { return this._options; }\n}\nexports.AgGridRenderer = AgGridRenderer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9hZy1ncmlkL2FnLWdyaWQtcmVuZGVyZXIudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9VV1QvLi9zcmMvY29yZS9hZy1ncmlkL2FnLWdyaWQtcmVuZGVyZXIudHM/ZDRlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJQ29sRGVmLCBJR3JpZCwgfSBmcm9tICcuLi8uLi9pbnRlcmZhY2UvZ3JpZCc7XG5pbXBvcnQge1xuICAgIElDb250ZXh0TWVudUl0ZW0sIElFdmVudCwgSU9wdGlvbnMsIEV2ZW50VHlwZSwgVUlFbGVtZW50LCBVSVJlbmRlcmVyLCBVSVR5cGVcbn0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlL3VpLWJhc2UnO1xuXG5pbXBvcnQgeyBnZXRTZWxlY3Rpb25OYW1lIH0gZnJvbSAnLi4vdXRpbGl0aWVzJztcbmltcG9ydCB7IENvbG9yTWFuYWdlciB9IGZyb20gJy4uL2NvbG9yLW1hbmFnZXInO1xuaW1wb3J0IHsgc2hvd0NvbnRleHRNZW51IH0gZnJvbSAnLi4vY29udGV4dC1tZW51JztcbmltcG9ydCAqIGFzIGFnR3JpZCBmcm9tICdhZy1ncmlkLWNvbW11bml0eSc7XG5cbi8vIGZyb20gaHR0cHM6Ly93d3cuYWctZ3JpZC5jb20vYmVzdC1qYXZhc2NyaXB0LWRhdGEtZ3JpZC8jZ3NjLnRhYj0wXG5leHBvcnQgZnVuY3Rpb24gcGVyY2VudENlbGxSZW5kZXJlcihwYXJhbXM6IGFueSkge1xuICAgIHZhciB2YWx1ZSA9IHBhcmFtcy52YWx1ZTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICB2YWx1ZSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHBlcmNlbnRCYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwZXJjZW50QmFyLmNsYXNzTmFtZSA9ICdkaXYtcGVyY2VudC1iYXInO1xuICAgIHBlcmNlbnRCYXIuc3R5bGUud2lkdGggPSB2YWx1ZSArICclJztcbiAgICBwZXJjZW50QmFyLnN0eWxlLmhlaWdodCA9ICcyNXB4JztcbiAgICBwZXJjZW50QmFyLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjQjNFNUZDJztcbiAgICBwZXJjZW50QmFyLmlubmVySFRNTCA9IHZhbHVlLnRvRml4ZWQoMikgKyAnJSc7XG5cbiAgICByZXR1cm4gcGVyY2VudEJhcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVNYXhBbmRQZXJjZW50YWdlKHJvd0RhdGE6IGFueSwgY29sdW1uczogSUNvbERlZltdKSB7XG4gICAgbGV0IGNvbHVtbk1heDogYW55ID0ge307XG4gICAgbGV0IHRvdGFsOiBhbnkgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbGV0IGNvbHVtbiA9IGNvbHVtbnNbaV07XG4gICAgICAgIGlmICghY29sdW1uTWF4W2NvbHVtbi5maWVsZF0pIHtcbiAgICAgICAgICAgIGNvbHVtbk1heFtjb2x1bW4uZmllbGRdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvdGFsW2NvbHVtbi5maWVsZF0pIHtcbiAgICAgICAgICAgIHRvdGFsW2NvbHVtbi5maWVsZF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93RGF0YS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgaWYgKHJvd0RhdGFbal1bY29sdW1uLmZpZWxkXSkge1xuICAgICAgICAgICAgICAgIGlmIChyb3dEYXRhW2pdW2NvbHVtbi5maWVsZF0udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93RGF0YVtqXVtjb2x1bW4uZmllbGRdID0gcm93RGF0YVtqXVtjb2x1bW4uZmllbGRdLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbHVtbk1heFtjb2x1bW4uZmllbGRdID0gTWF0aC5tYXgoY29sdW1uTWF4W2NvbHVtbi5maWVsZF0sIHJvd0RhdGFbal1bY29sdW1uLmZpZWxkXSk7XG4gICAgICAgICAgICAgICAgdG90YWxbY29sdW1uLmZpZWxkXSArPSByb3dEYXRhW2pdW2NvbHVtbi5maWVsZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbGV0IGNvbHVtbiA9IGNvbHVtbnNbaV07XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93RGF0YS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgcm93RGF0YVtqXVtjb2x1bW4uZmllbGRdID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiByb3dEYXRhW2pdW2NvbHVtbi5maWVsZF0sXG4gICAgICAgICAgICAgICAgY29sdW1uTWF4OiBjb2x1bW5NYXhbY29sdW1uLmZpZWxkXSxcbiAgICAgICAgICAgICAgICB0b3RhbDogdG90YWxbY29sdW1uLmZpZWxkXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlQ2VsbFJlbmRlcmVyKHBhcmFtczogYW55KSB7XG4gICAgbGV0IHZhbHVlID0gcGFyYW1zLnZhbHVlO1xuICAgIHZhbHVlLnZhbHVlID0gdmFsdWUudmFsdWUgPyB2YWx1ZS52YWx1ZSA6IDA7XG5cbiAgICBsZXQgcGVyY2VudEJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxldCBiYXJXaWR0aCA9IHZhbHVlLmNvbHVtbk1heCA/ICh2YWx1ZS52YWx1ZSAvIHZhbHVlLmNvbHVtbk1heCAqIDEwMCkgOiAwO1xuICAgIGxldCBwZXJjZW50ID0gdmFsdWUudG90YWwgPyAodmFsdWUudmFsdWUgLyB2YWx1ZS50b3RhbCAqIDEwMCkgOiAwO1xuICAgIHBlcmNlbnRCYXIuY2xhc3NOYW1lID0gJ2Rpdi1wZXJjZW50LWJhcic7XG4gICAgcGVyY2VudEJhci5zdHlsZS5oZWlnaHQgPSAnMjVweCc7XG4gICAgcGVyY2VudEJhci5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI0IzRTVGQyc7XG4gICAgcGVyY2VudEJhci5zdHlsZS53aWR0aCA9IGJhcldpZHRoICsgJyUnO1xuXG4gICAgaWYgKHBhcmFtcy5jb2xEZWYuc2hvd0FzUGVyY2VudGFnZSkge1xuICAgICAgICBwZXJjZW50QmFyLmlubmVySFRNTCA9IHBlcmNlbnQudG9GaXhlZCgyKSArICclJztcbiAgICAgICAgcGVyY2VudEJhci50aXRsZSA9IHBlcmNlbnQudG9GaXhlZCgyKSArICclICgnICsgJ1ZhbHVlOiAnICsgdmFsdWUudmFsdWUgKyAnKSc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcGVyY2VudEJhci5pbm5lckhUTUwgPSB2YWx1ZS52YWx1ZS50b0ZpeGVkKDIpO1xuICAgICAgICBwZXJjZW50QmFyLnRpdGxlID0gJ1ZhbHVlOiAnICsgdmFsdWUudmFsdWUgKyAnICgnICsgcGVyY2VudC50b0ZpeGVkKDIpICsgJyUpJztcbiAgICB9XG5cbiAgICByZXR1cm4gcGVyY2VudEJhcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlQ29tcGFyYXRvcih2YWx1ZUE6IGFueSwgdmFsdWVCOiBhbnksIG5vZGVBOiBhbnksIG5vZGVCOiBhbnksXG4gICAgaXNJbnZlcnRlZDogYW55KSB7XG4gICAgcmV0dXJuIHZhbHVlQS52YWx1ZSAtIHZhbHVlQi52YWx1ZTtcbn1cblxuZXhwb3J0IGxldCBtZW51SXRlbVNob3dBc1BlcmNlbnRhZ2UgPSB7XG4gICAgdGl0bGU6ICdEaXNwbGF5IFBlcmNlbnRhZ2UnLCBhY3Rpb246IGZ1bmN0aW9uIChlbGVtOiBhbnksIGRhdGE6IGFueSwgaW5kZXg6IGFueSk6IHZvaWQge1xuICAgICAgICBsZXQgaWR4ID0gZGF0YS5jb2xEZWYuY29udGV4dE1lbnVJdGVtcy5pbmRleE9mKG1lbnVJdGVtU2hvd0FzUGVyY2VudGFnZSk7XG4gICAgICAgIGRhdGEuY29sRGVmLmNvbnRleHRNZW51SXRlbXNbaWR4XSA9IG1lbnVJdGVtU2hvd0FzVG90YWw7XG4gICAgICAgIGRhdGEuY29sRGVmLnNob3dBc1BlcmNlbnRhZ2UgPSB0cnVlO1xuICAgICAgICBkYXRhLmFwaS5yZWZyZXNoQ2VsbHMoeyBjb2x1bW5zOiBbZGF0YS5jb2xEZWZdLCBmb3JjZTogdHJ1ZSB9KTtcbiAgICB9XG59O1xuXG5leHBvcnQgbGV0IG1lbnVJdGVtU2hvd0FzVG90YWwgPSB7XG4gICAgdGl0bGU6ICdEaXNwbGF5IFJhdyBWYWx1ZXMnLCBhY3Rpb246IGZ1bmN0aW9uIChlbGVtOiBhbnksIGRhdGE6IGFueSwgaW5kZXg6IGFueSk6IHZvaWQge1xuICAgICAgICBsZXQgaWR4ID0gZGF0YS5jb2xEZWYuY29udGV4dE1lbnVJdGVtcy5pbmRleE9mKG1lbnVJdGVtU2hvd0FzVG90YWwpO1xuICAgICAgICBkYXRhLmNvbERlZi5jb250ZXh0TWVudUl0ZW1zID0gW21lbnVJdGVtU2hvd0FzUGVyY2VudGFnZV07XG4gICAgICAgIGRhdGEuY29sRGVmLnNob3dBc1BlcmNlbnRhZ2UgPSBmYWxzZTtcbiAgICAgICAgZGF0YS5hcGkucmVmcmVzaENlbGxzKHsgY29sdW1uczogW2RhdGEuY29sRGVmXSwgZm9yY2U6IHRydWUgfSk7XG4gICAgfVxufTtcblxuY2xhc3MgQWdHcmlkIHtcbiAgICBwcml2YXRlIF9lbGVtZW50OiBJR3JpZDtcblxuICAgIC8qKiB0aGUgcGFyZW50IHJlbmRlcmVyIG9mIHRoaXMgcmVuZGVyZXIgKi9cbiAgICBwcml2YXRlIF9yZW5kZXJlcjogQWdHcmlkUmVuZGVyZXI7XG5cbiAgICAvKiogdGhlIG9wdGlvbnMgZm9yIHRoZSByZW5kZXIgKi9cbiAgICBwcml2YXRlIF9vcHRpb25zOiBhbnk7XG5cbiAgICAvKiogdGhlIGRpdiBmb3IgdGhpcyBncmlkICovXG4gICAgcHJpdmF0ZSBfZGl2OiBFbGVtZW50O1xuXG4gICAgcHJpdmF0ZSBrZXlib2FyZFNlbGVjdGlvbkZvY3VzOiAocGFyYW1zOiBhbnkpID0+IHZvaWQ7XG5cbiAgICBwcml2YXRlIG9uUm93Rm9jdXNEZWZhdWx0Q2FsbGJhY2s6IChyb3c6IGFueSkgPT4gdm9pZDtcblxuICAgIHByaXZhdGUgb25Sb3dVbmZvY3VzRGVmYXVsdENhbGxiYWNrOiAocm93OiBhbnkpID0+IHZvaWQ7XG5cbiAgICBwcml2YXRlIG9uUm93U2VsZWN0ZWREZWZhdWx0Q2FsbGJhY2s6IChyb3c6IGFueSkgPT4gdm9pZDtcblxuICAgIHByaXZhdGUgX3ByZXZTZWxlY3Rpb246IGFueTtcblxuICAgIHByaXZhdGUgX2Rpc2FibGVDYWxsYmFja3M6IGJvb2xlYW47XG5cbiAgICBwdWJsaWMgYXBpOiB7XG4gICAgICAgIHNlbGVjdDogKGV2ZW50OiBJRXZlbnQpID0+IHZvaWQsXG5cbiAgICAgICAgLyoqIEBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGZvY3VzICovXG4gICAgICAgIGhvdmVyOiAoZXZlbnQ6IElFdmVudCkgPT4gdm9pZFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmQgdGhlIGRpdiBmb3IgdGhpcyBncmFwaCB0byB0aGUgcGFyZW50IGRpdi4gVGhlIGRpdiB3ZSBjcmVhdGVcbiAgICAgKiB3aWxsIGJlIGZpbGxlZCB3aGVuIFJlbmRlcigpIGlzIGNhbGxlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmVudCAtIFRoZSBkaXYgdGhhdCB3aWxsIGNvbnRhaW4gdGhlIGRpdiBmb3IgdGhpcyBjaGFydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gLSBUaGUgY2hhcnQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50OiBVSUVsZW1lbnQsIHJlbmRlcmVyOiBBZ0dyaWRSZW5kZXJlciwgcGFyZW50Pzogc3RyaW5nLCBvcHRpb25zOiBhbnkgPSB7fSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudCBhcyBJR3JpZDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVDYWxsYmFja3MgPSBmYWxzZTtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9kaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhcmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBkZWZhdWx0Q2FsbGJhY2sgPSBmdW5jdGlvbiAocm93OiBhbnksIGV2ZW50VHlwZTogRXZlbnRUeXBlLCBjYWxsYmFjazogYW55KSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5fZGlzYWJsZUNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGdyaWQ6IElHcmlkID0gc2VsZi5fZWxlbWVudCBhcyBJR3JpZDtcbiAgICAgICAgICAgIGxldCBncmlkT3B0aW9uczogYW55ID0gZ3JpZC5ncmlkT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGxldCBjb2x1bW5zID0gZ3JpZE9wdGlvbnMuY29sdW1uQXBpLmdldEFsbENvbHVtbnMoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29sdW1ucyAmJiBjb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGtleSA9IGNvbHVtbnNbMF0uY29sRGVmLmZpZWxkO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gcm93Lm5vZGUuZGF0YVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnQ6IElFdmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlcjogZ3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgcm93OiByb3cgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25Sb3dGb2N1c0RlZmF1bHRDYWxsYmFjayA9IGZ1bmN0aW9uIChyb3c6IGFueSkge1xuICAgICAgICAgICAgZGVmYXVsdENhbGxiYWNrKHJvdywgRXZlbnRUeXBlLkhvdmVyU3RhcnQsIHNlbGYuX2VsZW1lbnQub25Ib3Zlcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uUm93VW5mb2N1c0RlZmF1bHRDYWxsYmFjayA9IGZ1bmN0aW9uIChyb3c6IGFueSkge1xuICAgICAgICAgICAgZGVmYXVsdENhbGxiYWNrKHJvdywgRXZlbnRUeXBlLkhvdmVyRW5kLCBzZWxmLl9lbGVtZW50Lm9uSG92ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vblJvd1NlbGVjdGVkRGVmYXVsdENhbGxiYWNrID0gZnVuY3Rpb24gKHJvdzogYW55KSB7XG4gICAgICAgICAgICBsZXQgZXZlbnRUeXBlID0gcm93Lm5vZGUuaXNTZWxlY3RlZCgpID9cbiAgICAgICAgICAgICAgICBFdmVudFR5cGUuU2VsZWN0QWRkIDogRXZlbnRUeXBlLlNlbGVjdFJlbW92ZTtcblxuICAgICAgICAgICAgZGVmYXVsdENhbGxiYWNrKHJvdywgZXZlbnRUeXBlLCBzZWxmLl9lbGVtZW50Lm9uQ2xpY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hcGkgPSB7XG4gICAgICAgICAgICBzZWxlY3Q6IHNlbGYuc2VsZWN0LFxuICAgICAgICAgICAgaG92ZXI6IHNlbGYuc2VsZWN0XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmtleWJvYXJkU2VsZWN0aW9uRm9jdXMgPSBmdW5jdGlvbiAocGFyYW1zOiBhbnkpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c0NlbGwgPSBwYXJhbXMucHJldmlvdXNDZWxsRGVmO1xuICAgICAgICAgICAgdmFyIHN1Z2dlc3RlZE5leHRDZWxsID0gcGFyYW1zLm5leHRDZWxsRGVmO1xuXG4gICAgICAgICAgICB2YXIgS0VZX1VQID0gMzg7XG4gICAgICAgICAgICB2YXIgS0VZX0RPV04gPSA0MDtcbiAgICAgICAgICAgIHZhciBLRVlfTEVGVCA9IDM3O1xuICAgICAgICAgICAgdmFyIEtFWV9SSUdIVCA9IDM5O1xuXG4gICAgICAgICAgICBsZXQgY29sdW1ucyA9IChzZWxmLl9lbGVtZW50LmdyaWRPcHRpb25zIGFzIGFueSkuY29sdW1uQXBpLmdldEFsbENvbHVtbnMoKTtcblxuICAgICAgICAgICAgaWYgKGNvbHVtbnMgJiYgY29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbGVjdGlvbktleSA9IHNlbGYuX2VsZW1lbnQuZ3JpZE9wdGlvbnMuc2VsZWN0aW9uS2V5ID9cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZWxlbWVudC5ncmlkT3B0aW9ucy5zZWxlY3Rpb25LZXkgOiBjb2x1bW5zWzBdLmNvbERlZi5maWVsZDtcblxuICAgICAgICAgICAgICAgIGxldCBoZWxwZXIgPSBmdW5jdGlvbiAoaW5kZXg6IG51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0NlbGwgPSBwYXJhbXMucHJldmlvdXNDZWxsRGVmO1xuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgc2VsZWN0ZWQgY2VsbCBvbiBjdXJyZW50IGNlbGwgKyAxXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2VsZW1lbnQuZ3JpZE9wdGlvbnMuYXBpLmZvckVhY2hOb2RlKChub2RlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbm9kZS5yb3dJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0U2VsZWN0ZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFwYXJhbXMuZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9yZW5kZXJlci5mb2N1cyhzZWxmLl9lbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBFdmVudFR5cGUuSG92ZXJFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZ2V0U2VsZWN0aW9uTmFtZShub2RlLmRhdGFbc2VsZWN0aW9uS2V5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWdnZXN0ZWROZXh0Q2VsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwYXJhbXMua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS0VZX0RPV046XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyKHByZXZpb3VzQ2VsbC5yb3dJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtFWV9VUDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXIocHJldmlvdXNDZWxsLnJvd0luZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS0VZX0xFRlQ6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS0VZX1JJR0hUOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Z2dlc3RlZE5leHRDZWxsO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJ0aGlzIHdpbGwgbmV2ZXIgaGFwcGVuLCBuYXZpZ2F0aW9uIGlzIGFsd2F5cyBvbiBvZiB0aGUgNCBrZXlzIGFib3ZlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgc2V0RGl2KGRpdjogRWxlbWVudCkge1xuICAgICAgICB0aGlzLl9kaXYgPSBkaXY7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHNlbGVjdChldmVudDogSUV2ZW50KSB7XG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IGV2ZW50LnNlbGVjdGlvbjtcblxuICAgICAgICAvLyBtYWtlIHR5cGVzY3JpcHQgaGFwcHkgdG8gaGFyZGNvZGUgc29tZSB0aGluZ3NcbiAgICAgICAgbGV0IGdyaWRPcHRpb25zOiBhbnkgPSB0aGlzLl9lbGVtZW50LmdyaWRPcHRpb25zO1xuICAgICAgICBsZXQgY29sdW1ucyA9IGdyaWRPcHRpb25zLmNvbHVtbkFwaS5nZXRBbGxDb2x1bW5zKCk7XG5cbiAgICAgICAgc2VsZi5fZGlzYWJsZUNhbGxiYWNrcyA9IHRydWU7XG4gICAgICAgIGlmIChjb2x1bW5zICYmIGNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGlvbktleSA9IGdyaWRPcHRpb25zLnNlbGVjdGlvbktleSA/IGdyaWRPcHRpb25zLnNlbGVjdGlvbktleSA6XG4gICAgICAgICAgICAgICAgY29sdW1uc1swXS5jb2xEZWYuZmllbGQ7XG5cbiAgICAgICAgICAgIGxldCBrZXkgPSBldmVudC5zZWxlY3Rpb25LZXkgPyBldmVudC5zZWxlY3Rpb25LZXkgOiBzZWxlY3Rpb25LZXk7XG4gICAgICAgICAgICBpZiAoZXZlbnQuZXZlbnQgPT09IEV2ZW50VHlwZS5TZWxlY3RBZGQgfHxcbiAgICAgICAgICAgICAgICBldmVudC5ldmVudCA9PT0gRXZlbnRUeXBlLkhvdmVyU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2U2VsZWN0aW9uID0gZXZlbnQuc2VsZWN0aW9uO1xuXG4gICAgICAgICAgICAgICAgZ3JpZE9wdGlvbnMuYXBpLmZvckVhY2hOb2RlKGZ1bmN0aW9uIChyb3dOb2RlOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldFNlbGVjdGlvbk5hbWUocm93Tm9kZS5kYXRhW2tleV0pID09PSBnZXRTZWxlY3Rpb25OYW1lKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbGVjdCB0aGUgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Tm9kZS5zZXRTZWxlY3RlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9lbGVtZW50LmdyaWRPcHRpb25zLmF1dG9TY3JvbGxUb1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRPcHRpb25zLmFwaS5lbnN1cmVOb2RlVmlzaWJsZShyb3dOb2RlLCAnbWlkZGxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZXZlbnQgPT09IEV2ZW50VHlwZS5TZWxlY3RDbGVhciB8fFxuICAgICAgICAgICAgICAgIGV2ZW50LmV2ZW50ID09PSBFdmVudFR5cGUuSG92ZXJDbGVhcikge1xuICAgICAgICAgICAgICAgIGdyaWRPcHRpb25zLmFwaS5kZXNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBzZWxmLl9wcmV2U2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBncmlkT3B0aW9ucy5hcGkuZm9yRWFjaE5vZGUoZnVuY3Rpb24gKHJvd05vZGU6IGFueSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0U2VsZWN0aW9uTmFtZShyb3dOb2RlLmRhdGFba2V5XSkgPT09IGdldFNlbGVjdGlvbk5hbWUoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVzZWxlY3QgdGhlIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd05vZGUuc2V0U2VsZWN0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgdGhlIHByZXZpb3VzIHNlbGVjdGlvbiBpZiBpdCdzIHdoYXQgd2UganVzdCByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuc2VsZWN0aW9uID09PSBzZWxmLl9wcmV2U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcHJldlNlbGVjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGYuX2Rpc2FibGVDYWxsYmFja3MgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldENvbnRleHRNZW51SXRlbXMoY29sdW1uRGVmczogYW55W10sIGNvbnRleHRNZW51SXRlbXM6IElDb250ZXh0TWVudUl0ZW1bXSkge1xuICAgICAgICBpZiAoY29sdW1uRGVmcykge1xuICAgICAgICAgICAgaWYgKCFjb250ZXh0TWVudUl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dE1lbnVJdGVtcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5EZWZzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbHVtbiA9IGNvbHVtbkRlZnNbaV07XG4gICAgICAgICAgICAgICAgY29sdW1uLm9uQ2VsbENvbnRleHRNZW51ID0gZnVuY3Rpb24gKGNlbGw6IGFueSkge1xuICAgICAgICAgICAgICAgICAgICBzaG93Q29udGV4dE1lbnUoY2VsbC5ldmVudCwgY2VsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY29sRGVmLmNvbnRleHRNZW51SXRlbXMgPyBjb250ZXh0TWVudUl0ZW1zLmNvbmNhdChjZWxsLmNvbERlZi5jb250ZXh0TWVudUl0ZW1zKSA6IGNvbnRleHRNZW51SXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29udGV4dE1lbnVJdGVtcyhjb2x1bW4uY2hpbGRyZW4sIGNvbnRleHRNZW51SXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBpbnZhbGlkYXRlKG9wdGlvbnM6IElPcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vIG1ha2UgdHlwZXNjcmlwdCBoYXBweSB0byBoYXJkY29kZSBzb21lIHRoaW5nc1xuICAgICAgICBsZXQgZ3JpZE9wdGlvbnM6IGFueSA9IHRoaXMuX2VsZW1lbnQuZ3JpZE9wdGlvbnM7XG4gICAgICAgICAvLyByZXF1aXJlZCB0byBhbGxvdyB0aGUgc2VsZWN0IGFwaSB0byBub3QgZW5kIHVwIGluIGEgaW5maW5pdGUgbG9vcFxuICAgICAgICBncmlkT3B0aW9ucy5zdXBwcmVzc0FzeW5jRXZlbnRzID0gdHJ1ZTtcbiAgICAgICAgZ3JpZE9wdGlvbnMuYW5pbWF0ZVJvd3MgPSBncmlkT3B0aW9ucy5hbmltYXRlUm93cyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGdyaWRPcHRpb25zLmFuaW1hdGVSb3dzIDogdHJ1ZTtcbiAgICAgICAgZ3JpZE9wdGlvbnMucm93U2VsZWN0aW9uID0gZ3JpZE9wdGlvbnMucm93U2VsZWN0aW9uICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgZ3JpZE9wdGlvbnMucm93U2VsZWN0aW9uIDogJ211bHRpcGxlJztcbiAgICAgICAgZ3JpZE9wdGlvbnMucm93RGVzZWxlY3Rpb24gPSBncmlkT3B0aW9ucy5yb3dEZXNlbGVjdGlvbiAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGdyaWRPcHRpb25zLnJvd0Rlc2VsZWN0aW9uIDogdHJ1ZTtcbiAgICAgICAgZ3JpZE9wdGlvbnMuc3VwcHJlc3NTY3JvbGxPbk5ld0RhdGEgPSBncmlkT3B0aW9ucy5zdXBwcmVzc1Njcm9sbE9uTmV3RGF0YSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGdyaWRPcHRpb25zLnN1cHByZXNzU2Nyb2xsT25OZXdEYXRhIDogdHJ1ZTtcbiAgICAgICAgZ3JpZE9wdGlvbnMuc3VwcHJlc3NQcm9wZXJ0eU5hbWVzQ2hlY2sgPSBncmlkT3B0aW9ucy5zdXBwcmVzc1Byb3BlcnR5TmFtZXNDaGVjayAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGdyaWRPcHRpb25zLnN1cHByZXNzUHJvcGVydHlOYW1lc0NoZWNrIDogdHJ1ZTtcbiAgICAgICAgZ3JpZE9wdGlvbnMuZGVmYXVsdENvbERlZiA9IGdyaWRPcHRpb25zLmRlZmF1bHRDb2xEZWYgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBncmlkT3B0aW9ucy5kZWZhdWx0Q29sRGVmIDoge307XG4gICAgICAgIGdyaWRPcHRpb25zLmRlZmF1bHRDb2xEZWYuc29ydGFibGUgPSBncmlkT3B0aW9ucy5kZWZhdWx0Q29sRGVmLnNvcnRhYmxlICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgZ3JpZE9wdGlvbnMuZGVmYXVsdENvbERlZi5zb3J0YWJsZSA6IHRydWU7XG4gICAgICAgIGdyaWRPcHRpb25zLmRlZmF1bHRDb2xEZWYucmVzaXphYmxlID0gZ3JpZE9wdGlvbnMuZGVmYXVsdENvbERlZi5yZXNpemFibGUgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBncmlkT3B0aW9ucy5kZWZhdWx0Q29sRGVmLnJlc2l6YWJsZSA6IHRydWU7XG4gICAgICAgIGdyaWRPcHRpb25zLmRlZmF1bHRDb2xEZWYuZmlsdGVyID0gZ3JpZE9wdGlvbnMuZGVmYXVsdENvbERlZi5maWx0ZXIgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICBncmlkT3B0aW9ucy5kZWZhdWx0Q29sRGVmLmZpbHRlciA6IHRydWU7XG4gICAgICAgIGdyaWRPcHRpb25zLmF1dG9TY3JvbGxUb1NlbGVjdGlvbiA9IGdyaWRPcHRpb25zLmF1dG9TY3JvbGxUb1NlbGVjdGlvbiAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgIGdyaWRPcHRpb25zLmF1dG9TY3JvbGxUb1NlbGVjdGlvbiA6IHRydWVcblxuICAgICAgICBsZXQgd3JhcENhbGxiYWNrID0gZnVuY3Rpb24gKHVzZXJDYWxsYmFjazogKHJvdzogYW55KSA9PiB2b2lkLFxuICAgICAgICAgICAgZGVmYXVsdENhbGxiYWNrOiAocm93OiBhbnkpID0+IHZvaWQsXG4gICAgICAgICAgICBldmVudFR5cGU6IEV2ZW50VHlwZSkge1xuICAgICAgICAgICAgaWYgKCF1c2VyQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdENhbGxiYWNrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHJvdzogYW55KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9kaXNhYmxlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXNlckNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxlcjogc2VsZi5fZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHJvdzogcm93Lm5vZGUuZGF0YSB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBncmlkT3B0aW9ucy5vbkNlbGxNb3VzZU92ZXIgPSB3cmFwQ2FsbGJhY2soZ3JpZE9wdGlvbnMub25DZWxsTW91c2VPdmVyLFxuICAgICAgICAgICAgdGhpcy5vblJvd0ZvY3VzRGVmYXVsdENhbGxiYWNrLCBFdmVudFR5cGUuSG92ZXJTdGFydCk7XG4gICAgICAgIGdyaWRPcHRpb25zLmNlbGxNb3VzZU91dCA9IHdyYXBDYWxsYmFjayhncmlkT3B0aW9ucy5vbkNlbGxNb3VzZU92ZXIsXG4gICAgICAgICAgICB0aGlzLm9uUm93VW5mb2N1c0RlZmF1bHRDYWxsYmFjaywgRXZlbnRUeXBlLkhvdmVyRW5kKTtcbiAgICAgICAgZ3JpZE9wdGlvbnMub25Sb3dDbGlja2VkID0gd3JhcENhbGxiYWNrKGdyaWRPcHRpb25zLm9uUm93Q2xpY2tlZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgZ3JpZE9wdGlvbnMub25Sb3dEb3VibGVDbGlja2VkID0gd3JhcENhbGxiYWNrKGdyaWRPcHRpb25zLm9uUm93RG91YmxlQ2xpY2tlZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKGdyaWRPcHRpb25zLm9uQ2xpY2spIHtcbiAgICAgICAgICAgIGdyaWRPcHRpb25zLm9uUm93Q2xpY2tlZCA9IHdyYXBDYWxsYmFjayhncmlkT3B0aW9ucy5vbkNsaWNrLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JpZE9wdGlvbnMub25Eb3VibGVDbGljaykge1xuICAgICAgICAgICAgZ3JpZE9wdGlvbnMub25Sb3dEb3VibGVDbGlja2VkID0gd3JhcENhbGxiYWNrKGdyaWRPcHRpb25zLm9uRG91YmxlQ2xpY2ssXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFncmlkT3B0aW9ucy5vblJvd1NlbGVjdGVkKSB7XG4gICAgICAgICAgICBncmlkT3B0aW9ucy5vblJvd1NlbGVjdGVkID0gdGhpcy5vblJvd1NlbGVjdGVkRGVmYXVsdENhbGxiYWNrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFncmlkT3B0aW9ucy51c2VyT25Sb3dTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGdyaWRPcHRpb25zLnVzZXJPblJvd1NlbGVjdGVkID0gZ3JpZE9wdGlvbnMub25Sb3dTZWxlY3RlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ3JpZE9wdGlvbnMub25Sb3dTZWxlY3RlZCA9IGZ1bmN0aW9uIChyb3c6IGFueSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9kaXNhYmxlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBoYW5kbGUgbXVsdGlwbGUgc2VsZWN0aW9uIGNsZWFyIGNvcnJlY3RseVxuICAgICAgICAgICAgICAgIGdyaWRPcHRpb25zLnVzZXJPblJvd1NlbGVjdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVyOiBzZWxmLl9lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IHJvdy5ub2RlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGVkOiByb3cubm9kZS5zZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBldmVudDogcm93Lm5vZGUuc2VsZWN0ZWQgPyBFdmVudFR5cGUuU2VsZWN0QWRkIDogRXZlbnRUeXBlLlNlbGVjdFJlbW92ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhhc0dyb3VwaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChncmlkT3B0aW9ucy5yb3dEYXRhICYmICFncmlkT3B0aW9ucy5nZXROb2RlQ2hpbGREZXRhaWxzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyaWRPcHRpb25zLnJvd0RhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgcm93ID0gZ3JpZE9wdGlvbnMucm93RGF0YVtpXTtcbiAgICAgICAgICAgICAgICBpZiAocm93LmNoaWxkcmVuICYmIHJvdy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0dyb3VwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChncmlkT3B0aW9ucy5jb2x1bW5EZWZzKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWVDZWxsUmVuZGVyZXJDb2x1bW5zID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyaWRPcHRpb25zLmNvbHVtbkRlZnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29sdW1uID0gZ3JpZE9wdGlvbnMuY29sdW1uRGVmc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uY2FuU2hvd1BlcmNlbnRhZ2UgfHwgY29sdW1uLnNob3dBc1BlcmNlbnRhZ2UgfHwgY29sdW1uLnNob3dBc0Jhcikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUNlbGxSZW5kZXJlckNvbHVtbnMucHVzaChjb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uY2VsbFJlbmRlcmVyID0gdmFsdWVDZWxsUmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbi5jb21wYXJhdG9yID0gdmFsdWVDb21wYXJhdG9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbHVtbi5jb250ZXh0TWVudUl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uY29udGV4dE1lbnVJdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBpZHggPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uLnNob3dBc1BlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGNvbHVtbi5jb250ZXh0TWVudUl0ZW1zLmluZGV4T2YobWVudUl0ZW1TaG93QXNQZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLmNvbnRleHRNZW51SXRlbXNbaV0gPSBtZW51SXRlbVNob3dBc1RvdGFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZHggPSBjb2x1bW4uY29udGV4dE1lbnVJdGVtcy5pbmRleE9mKG1lbnVJdGVtU2hvd0FzVG90YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5jb250ZXh0TWVudUl0ZW1zLnB1c2gobWVudUl0ZW1TaG93QXNUb3RhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvbHVtbi5jYW5TaG93UGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gY29sdW1uLmNvbnRleHRNZW51SXRlbXMuaW5kZXhPZihtZW51SXRlbVNob3dBc1RvdGFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLmNvbnRleHRNZW51SXRlbXNbaV0gPSBtZW51SXRlbVNob3dBc1BlcmNlbnRhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGNvbHVtbi5jb250ZXh0TWVudUl0ZW1zLmluZGV4T2YobWVudUl0ZW1TaG93QXNQZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uY29udGV4dE1lbnVJdGVtcy5wdXNoKG1lbnVJdGVtU2hvd0FzUGVyY2VudGFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4ub25DZWxsQ2xpY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25DbGljayA9IGNvbHVtbi5vbkNlbGxDbGlja2VkO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ub25DZWxsQ2xpY2tlZCA9IGZ1bmN0aW9uIChwYXJhbXM6IGFueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVyOiBzZWxmLl9lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgY2VsbDogcGFyYW1zIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4ub25DZWxsRG91YmxlQ2xpY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgb25Eb3VibGVDbGljayA9IGNvbHVtbi5vbkNlbGxEb3VibGVDbGlja2VkO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ub25DZWxsRG91YmxlQ2xpY2tlZCA9IGZ1bmN0aW9uIChwYXJhbXM6IGFueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Eb3VibGVDbGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVyOiBzZWxmLl9lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgY2VsbDogcGFyYW1zIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0dyb3VwaW5nICYmIGdyaWRPcHRpb25zLmNvbHVtbkRlZnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBncm91cENvbCA9IGdyaWRPcHRpb25zLmNvbHVtbkRlZnNbMF07XG4gICAgICAgICAgICAgICAgZ3JvdXBDb2wuY2VsbFJlbmRlcmVyID0gJ2FnR3JvdXBDZWxsUmVuZGVyZXInO1xuICAgICAgICAgICAgICAgIGdyb3VwQ29sLmNlbGxSZW5kZXJlclBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJSZW5kZXJlcjogKHBhcmFtczogYW55KSA9PiB7IHJldHVybiBwYXJhbXMuZGF0YVtncm91cENvbC5maWVsZF0gfSxcbiAgICAgICAgICAgICAgICAgICAgc3VwcHJlc3NDb3VudDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZ3JpZE9wdGlvbnMuZ2V0Tm9kZUNoaWxkRGV0YWlscyA9IChyb3dJdGVtOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0l0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQ6IHJvd0l0ZW0uZXhwYW5kZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IHJvd0l0ZW0uY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiByb3dJdGVtW2dyb3VwQ29sLmZpZWxkXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlQ2VsbFJlbmRlcmVyQ29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1heEFuZFBlcmNlbnRhZ2UoZ3JpZE9wdGlvbnMucm93RGF0YSwgdmFsdWVDZWxsUmVuZGVyZXJDb2x1bW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JpZE9wdGlvbnMuZW5hYmxlU2luZ2xlS2V5Ym9hcmRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGdyaWRPcHRpb25zLm5hdmlnYXRlVG9OZXh0Q2VsbCA9IHRoaXMua2V5Ym9hcmRTZWxlY3Rpb25Gb2N1cztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBub0NvbnRleHRNZW51ID0gZ3JpZE9wdGlvbnMuY29udGV4dE1lbnVJdGVtcyA9PSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChncmlkT3B0aW9ucy5jb2x1bW5EZWZzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgbm9Db250ZXh0TWVudSAmJiBpIDwgZ3JpZE9wdGlvbnMuY29sdW1uRGVmcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCBjb2x1bW4gPSBncmlkT3B0aW9ucy5jb2x1bW5EZWZzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uY29udGV4dE1lbnVJdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBub0NvbnRleHRNZW51ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9Db250ZXh0TWVudSkge1xuICAgICAgICAgICAgdGhpcy5zZXRDb250ZXh0TWVudUl0ZW1zKGdyaWRPcHRpb25zLmNvbHVtbkRlZnMsIGdyaWRPcHRpb25zLmNvbnRleHRNZW51SXRlbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuX2Rpdi5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXYucmVtb3ZlQ2hpbGQodGhpcy5fZGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudC5hcGkpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnQuYXBpID0geyBzZWxlY3Q6IHVuZGVmaW5lZCwgaG92ZXI6IHVuZGVmaW5lZCB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZWxlbWVudC5hcGkuc2VsZWN0ID0gZnVuY3Rpb24gKGV2ZW50OiBJRXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbGVtZW50LmFwaS5ob3ZlciA9IHRoaXMuX2VsZW1lbnQuYXBpLnNlbGVjdDtcbiAgICAgICAgbmV3IGFnR3JpZC5HcmlkKHRoaXMuX2RpdiBhcyBIVE1MRWxlbWVudCwgdGhpcy5fZWxlbWVudC5ncmlkT3B0aW9ucyBhcyBhbnkpOyAvL2NyZWF0ZSBhIG5ldyBncmlkXG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQWdHcmlkUmVuZGVyZXIgaW1wbGVtZW50cyBVSVJlbmRlcmVyIHtcbiAgICAvKiogVGhlIHBhcmVudCBpZCBvZiB0aGUgZGl2ICovXG4gICAgcHJpdmF0ZSBfcGFyZW50OiBzdHJpbmc7XG5cbiAgICAvKiogdGhlIG9wdGlvbnMgZm9yIHRoZSByZW5kZXIgKi9cbiAgICBwcml2YXRlIF9vcHRpb25zOiBhbnk7XG5cbiAgICAvKiogdGhlIGNvbG9ycyBmb3IgdGhlIHJlbmRlciAqL1xuICAgIHByaXZhdGUgX2NvbG9yTWdyOiBhbnk7XG5cbiAgICAvLyBmcm9tIFVJUmVuZGVyZXJcbiAgICBwdWJsaWMgb25SZW5kZXI6IChlbGVtOiBVSUVsZW1lbnQsIG9wdGlvbnM6IElPcHRpb25zKSA9PiB2b2lkO1xuXG4gICAgLyoqIG1hcHMgdG8gcmVuZGVyIGVsZW1lbnRzIGlmIG11bHRpcGxlIHJlbmRlcnMgYXJlIHVzZWRcbiAgICAgKiAgdGhyb3VnaCB0aGlzIGludGVyZmFjZSAqL1xuICAgIHByaXZhdGUgX3JlbmRlcmVyTWFwOiBXZWFrTWFwPFVJRWxlbWVudCwgQWdHcmlkPjtcblxuICAgIGNvbnN0cnVjdG9yKHBhcmVudD86IHN0cmluZywgb3B0aW9ucyA9IHt9LCBjb2xvck1ncjogQ29sb3JNYW5hZ2VyID0gbmV3IENvbG9yTWFuYWdlcigpKSB7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXJNYXAgPSBuZXcgV2Vha01hcDxVSUVsZW1lbnQsIEFnR3JpZD4oKTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2NvbG9yTWdyID0gY29sb3JNZ3I7XG4gICAgfVxuXG4gICAgcHVibGljIGdldENvbG9yTWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yTWdyO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRPblJlbmRlckNhbGxiYWNrKGNhbGxiYWNrOiAoZWxlbTogVUlFbGVtZW50LCBvcHRpb25zOiBJT3B0aW9ucykgPT4gdm9pZCkge1xuICAgICAgICB0aGlzLm9uUmVuZGVyID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgLyoqIHVwZGF0ZSBhbnkgb3B0aW9ucyAqL1xuICAgIHB1YmxpYyBzZXRPcHRpb25zKG9wdGlvbnM6IGFueSkge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBkZXByZWNhdGVkICgnRGVwcmVjYXRlZCBzaW5jZSAxLjE0LjAgaW4gZmF2b3Igb2YgZm9jdXMuICBXaWxsIGJlIHJlbW92ZWQgaW4gMi54JykgKi9cbiAgICBwdWJsaWMgaG92ZXIoZWxlbWVudDogVUlFbGVtZW50LCBldmVudDogSUV2ZW50KSB7XG4gICAgICAgIHRoaXMuZm9jdXMoZWxlbWVudCwgZXZlbnQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBmb2N1cyhlbGVtZW50OiBVSUVsZW1lbnQsIGV2ZW50OiBJRXZlbnQpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnY3VycmVudGx5IG5vIGZvY3VzIGV2ZW50cyBjYW4gYmUgY3JlYXRlZCBmb3IgdGhlIGdyaWQnKVxuICAgIH1cblxuICAgIHB1YmxpYyBzZWxlY3QoZWxlbWVudDogVUlFbGVtZW50LCBldmVudDogSUV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJlck1hcC5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlck1hcC5nZXQoZWxlbWVudCkuYXBpLnNlbGVjdChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0RGl2KGVsZW1lbnQ6IFVJRWxlbWVudCwgZGl2OiBFbGVtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXJNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBVSVR5cGUuR3JpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyTWFwLnNldChlbGVtZW50LCBuZXcgQWdHcmlkKGVsZW1lbnQsIHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyZXJNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlck1hcC5nZXQoZWxlbWVudCkuc2V0RGl2KGRpdik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aGUgZWxlbWVudCB0byByZW5kZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVuZGVyKGVsZW1lbnQ6IFVJRWxlbWVudCwgb3B0aW9uczogSU9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIGVsZW1lbnQucmVuZGVyZXIgPSB0aGlzO1xuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXJNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBVSVR5cGUuR3JpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyTWFwLnNldChlbGVtZW50LCBuZXcgQWdHcmlkKGVsZW1lbnQsIHRoaXMsIHRoaXMuX3BhcmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJlck1hcC5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICh0aGlzLl9yZW5kZXJlck1hcC5nZXQoZWxlbWVudCkgYXMgQWdHcmlkKS5pbnZhbGlkYXRlKG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHRoaXMub25SZW5kZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVuZGVyKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGludmFsaWRhdGUgPSB0aGlzLnJlbmRlcjtcblxuICAgIC8qKlxuICAgICAqIGZyZWUgdGhlIHJlc291cmNlcyB1c2VkIGJ5IHRoZSByZW5kZXJlciBmb3IgdGhpcyBlbGVtZW50XG4gICAgICovXG4gICAgcHVibGljIGRlc3Ryb3koZWxlbWVudDogVUlFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyTWFwLmRlbGV0ZShlbGVtZW50KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0T3B0aW9ucygpIHsgcmV0dXJuIHRoaXMuX29wdGlvbnM7IH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQ0E7QUFtQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQXJCQTtBQXVCQTtBQUVBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUErQkE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBaUJBO0FBc0VBO0FBckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFqR0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/ag-grid/ag-grid-renderer.ts\n");

/***/ }),

/***/ "./src/core/color-manager.ts":
/*!***********************************!*\
  !*** ./src/core/color-manager.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction numberToHex(number) {\n    var hex = Number(number).toString(16);\n    return hex.length == 1 ? '0' + hex : hex;\n}\nfunction rgbToHex(color) {\n    let rgb = color.substring(color.indexOf('(') + 1, color.indexOf(')')).split(',');\n    return numberToHex(rgb[0]) + numberToHex(rgb[1]) + numberToHex(rgb[2]);\n}\n/** used to organize and create colors for the UI */\nclass ColorManager {\n    constructor(randomColorFunc) {\n        this._colorMap = {};\n        if (randomColorFunc) {\n            this.getRandomColor = randomColorFunc;\n        }\n        else {\n            this.getRandomColor = function () {\n                var letters = '0123456789ABCDEF';\n                var color = '#';\n                for (var i = 0; i < 6; i++) {\n                    color += letters[Math.floor(Math.random() * 16)];\n                }\n                return color;\n            };\n        }\n    }\n    /**\n     * check if an existing color exists for a given key\n     *\n     * @param the key associated with your data\n     */\n    hasColor(key) {\n        return this._colorMap.hasOwnProperty(key);\n    }\n    /**\n     * set the color associated with a given key\n     *\n     * @param key associated with your data\n     * @param color to associate with the key\n     */\n    setColor(key, color) {\n        if (color.indexOf('rgb') === 0) {\n            color = ColorManager.RgbToHex(color);\n        }\n        this._colorMap[key] = color;\n    }\n    /**\n     * get the color associated with a given key\n     *\n     * @param key associated with your data\n     */\n    getColor(key) {\n        if (!this.hasColor(key)) {\n            this._colorMap[key] = this.getRandomColor();\n        }\n        return this._colorMap[key];\n    }\n    static IntToHex(value) {\n        return '#' + value.toString(16).padStart(6, '0');\n    }\n    static RgbToHex(color) {\n        return '#' + rgbToHex(color);\n    }\n    static RgbToInt(color) {\n        return parseInt(rgbToHex(color), 16);\n    }\n}\nexports.ColorManager = ColorManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb2xvci1tYW5hZ2VyLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVVdULy4vc3JjL2NvcmUvY29sb3ItbWFuYWdlci50cz9mYWIzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG51bWJlclRvSGV4KG51bWJlcjogc3RyaW5nKSB7XG4gICAgdmFyIGhleCA9IE51bWJlcihudW1iZXIpLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PSAxID8gJzAnICsgaGV4IDogaGV4O1xufVxuZnVuY3Rpb24gcmdiVG9IZXgoY29sb3I6IHN0cmluZykge1xuICAgIGxldCByZ2IgPSBjb2xvci5zdWJzdHJpbmcoY29sb3IuaW5kZXhPZignKCcpICsgMSwgY29sb3IuaW5kZXhPZignKScpKS5zcGxpdCgnLCcpO1xuICAgIHJldHVybiBudW1iZXJUb0hleChyZ2JbMF0pICsgbnVtYmVyVG9IZXgocmdiWzFdKSArIG51bWJlclRvSGV4KHJnYlsyXSk7XG59XG5cbi8qKiB1c2VkIHRvIG9yZ2FuaXplIGFuZCBjcmVhdGUgY29sb3JzIGZvciB0aGUgVUkgKi9cbmV4cG9ydCBjbGFzcyBDb2xvck1hbmFnZXIge1xuICAgIHByaXZhdGUgX2NvbG9yTWFwOiB7IFtpbmRleDogc3RyaW5nXTogc3RyaW5nIH07XG4gICAgcHJpdmF0ZSBnZXRSYW5kb21Db2xvcjogKCkgPT4gc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocmFuZG9tQ29sb3JGdW5jPzogKCkgPT4gc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2NvbG9yTWFwID0ge31cbiAgICAgICAgaWYgKHJhbmRvbUNvbG9yRnVuYykge1xuICAgICAgICAgICAgdGhpcy5nZXRSYW5kb21Db2xvciA9IHJhbmRvbUNvbG9yRnVuYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0UmFuZG9tQ29sb3IgPSBmdW5jdGlvbiAoKTogc3RyaW5nIHtcbiAgICAgICAgICAgICAgICB2YXIgbGV0dGVycyA9ICcwMTIzNDU2Nzg5QUJDREVGJztcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSAnIyc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgKz0gbGV0dGVyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNildO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjaGVjayBpZiBhbiBleGlzdGluZyBjb2xvciBleGlzdHMgZm9yIGEgZ2l2ZW4ga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggeW91ciBkYXRhXG4gICAgICovXG4gICAgcHVibGljIGhhc0NvbG9yKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvck1hcC5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgY29sb3IgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4ga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IGFzc29jaWF0ZWQgd2l0aCB5b3VyIGRhdGFcbiAgICAgKiBAcGFyYW0gY29sb3IgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGtleVxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRDb2xvcihrZXk6IHN0cmluZywgY29sb3I6IHN0cmluZyk6IHZvaWQge1xuXG4gICAgICAgIGlmIChjb2xvci5pbmRleE9mKCdyZ2InKSA9PT0gMCkge1xuICAgICAgICAgICAgY29sb3IgPSBDb2xvck1hbmFnZXIuUmdiVG9IZXgoY29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbG9yTWFwW2tleV0gPSBjb2xvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGNvbG9yIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIGtleSBhc3NvY2lhdGVkIHdpdGggeW91ciBkYXRhXG4gICAgICovXG4gICAgcHVibGljIGdldENvbG9yKGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0NvbG9yKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yTWFwW2tleV0gPSB0aGlzLmdldFJhbmRvbUNvbG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yTWFwW2tleV07XG4gICAgfVxuXG4gICAgc3RhdGljIEludFRvSGV4KHZhbHVlOiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJyMnICsgdmFsdWUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDYsICcwJyk7XG4gICAgfVxuXG4gICAgc3RhdGljIFJnYlRvSGV4KGNvbG9yOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJyMnICsgcmdiVG9IZXgoY29sb3IpO1xuICAgIH1cblxuICAgIHN0YXRpYyBSZ2JUb0ludChjb2xvcjogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHJnYlRvSGV4KGNvbG9yKSwgMTYpO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBbEVBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/color-manager.ts\n");

/***/ }),

/***/ "./src/core/context-menu.ts":
/*!**********************************!*\
  !*** ./src/core/context-menu.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction positionMenu(div, rect) {\n    let bodyWidth = document.body.clientWidth;\n    let bodyHeight = document.body.clientHeight;\n    // these points define the top left of our menu\n    let divX = rect.left;\n    let divY = rect.top;\n    // if we draw on the right we do\n    if (rect.right + div.clientWidth < bodyWidth) {\n        divX = rect.right;\n    }\n    else {\n        divX = rect.left - div.clientWidth;\n    }\n    // if we cannot draw down we draw up\n    if (rect.top + div.clientHeight > bodyHeight) {\n        divY = rect.top - div.clientHeight;\n    }\n    div.style.left = (divX - 2) + 'px';\n    div.style.top = (divY - 2) + 'px';\n}\nfunction createMenu(event, data, contextMenuItems, rect, propogateEvent) {\n    let menuDiv;\n    menuDiv = document.createElement('div');\n    menuDiv.setAttribute('class', 'context-menu');\n    menuDiv.oncontextmenu = function (e) {\n        removeMenu();\n        e.preventDefault();\n    };\n    document.body.appendChild(menuDiv);\n    if (contextMenuItems.length > 0) {\n        let menuList = document.createElement('ul');\n        menuDiv.appendChild(menuList);\n        for (let i = 0; i < contextMenuItems.length; ++i) {\n            let item = contextMenuItems[i];\n            let li = document.createElement('li');\n            if (item.divider) {\n                li.className += ' is-divider';\n                li.innerHTML = '<hr>';\n            }\n            else {\n                if (!item.title) {\n                    console.error('No title attribute set. Check the spelling of your options.');\n                }\n                if (item.disabled) {\n                    li.className += ' is-disabled';\n                }\n                if (!item.action && !item.submenu) {\n                    li.className += ' is-header';\n                }\n                if (item.submenu) {\n                    li.innerHTML = `<span><text>${item.title}</text>` +\n                        '<text style=\"width: 5px; float: right; color: #000000A0\">&#9658</text></span>';\n                }\n                else {\n                    li.innerHTML = item.title;\n                }\n                li.onclick = function (d) {\n                    if (item.disabled)\n                        return; // do nothing if disabled\n                    if (!item.action)\n                        return; // headers have no \"action\"\n                    item.action(li, data, i);\n                    removeMenu();\n                };\n                li.onmouseenter = function () {\n                    removeSubmenu(contextMenuItems);\n                    if (item.submenu) {\n                        let relativeRect = li.getBoundingClientRect();\n                        let rect = {\n                            top: relativeRect.top + window.scrollY,\n                            bottom: relativeRect.bottom + window.scrollY,\n                            left: relativeRect.left + window.scrollX,\n                            right: relativeRect.right + window.scrollX,\n                            height: relativeRect.height,\n                            width: relativeRect.width\n                        };\n                        item.submenuDiv = createMenu(event, data, item.submenu, rect, propogateEvent);\n                    }\n                };\n            }\n            menuList.appendChild(li);\n        }\n        menuDiv.style.display = 'block';\n        positionMenu(menuDiv, rect);\n        if (!propogateEvent) {\n            event.stopPropagation();\n        }\n    }\n    return menuDiv;\n}\nfunction removeMenuItem(item) {\n    if (item.submenuDiv) {\n        document.body.removeChild(item.submenuDiv);\n        delete item.submenuDiv;\n    }\n    if (item.submenu) {\n        removeSubmenu(item.submenu);\n    }\n}\nfunction removeSubmenu(items) {\n    items.forEach(function (item, index, items) {\n        removeMenuItem(item);\n    });\n}\nfunction removeMenu() {\n    removeSubmenu(lastMenu);\n    let menus = document.getElementsByClassName('context-menu');\n    while (menus.length) {\n        document.body.removeChild(menus[0]);\n    }\n}\nfunction keyupListener() {\n    window.onkeyup = function (e) {\n        if (e.keyCode === 27) {\n            removeMenu();\n        }\n    };\n}\nlet lastMenu = [];\nfunction showContextMenu(event, data, contextMenuItems, propogateEvent = false) {\n    if (event) {\n        keyupListener();\n        removeMenu();\n        lastMenu = contextMenuItems;\n        createMenu(event, data, contextMenuItems, {\n            left: event.pageX,\n            top: event.pageY,\n            right: event.pageX,\n            bottom: event.pageY,\n            height: 0,\n            width: 0\n        }, propogateEvent);\n        event.preventDefault();\n    }\n}\nexports.showContextMenu = showContextMenu;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9jb250ZXh0LW1lbnUudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9VV1QvLi9zcmMvY29yZS9jb250ZXh0LW1lbnUudHM/ZjNjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJQ29udGV4dE1lbnVJdGVtIH0gZnJvbSAnLi4vaW50ZXJmYWNlL3VpLWJhc2UnO1xuXG5mdW5jdGlvbiBwb3NpdGlvbk1lbnUoZGl2OiBIVE1MRGl2RWxlbWVudCwgcmVjdDogQ2xpZW50UmVjdCkge1xuICAgIGxldCBib2R5V2lkdGggPSBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoO1xuICAgIGxldCBib2R5SGVpZ2h0ID0gZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7XG5cbiAgICAvLyB0aGVzZSBwb2ludHMgZGVmaW5lIHRoZSB0b3AgbGVmdCBvZiBvdXIgbWVudVxuICAgIGxldCBkaXZYID0gcmVjdC5sZWZ0O1xuICAgIGxldCBkaXZZID0gcmVjdC50b3A7XG4gICAgLy8gaWYgd2UgZHJhdyBvbiB0aGUgcmlnaHQgd2UgZG9cbiAgICBpZiAocmVjdC5yaWdodCArIGRpdi5jbGllbnRXaWR0aCA8IGJvZHlXaWR0aCkge1xuICAgICAgICBkaXZYID0gcmVjdC5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkaXZYID0gcmVjdC5sZWZ0IC0gZGl2LmNsaWVudFdpZHRoO1xuICAgIH1cblxuICAgIC8vIGlmIHdlIGNhbm5vdCBkcmF3IGRvd24gd2UgZHJhdyB1cFxuICAgIGlmIChyZWN0LnRvcCArIGRpdi5jbGllbnRIZWlnaHQgPiBib2R5SGVpZ2h0KSB7XG4gICAgICAgIGRpdlkgPSByZWN0LnRvcCAtIGRpdi5jbGllbnRIZWlnaHQ7XG4gICAgfVxuXG4gICAgZGl2LnN0eWxlLmxlZnQgPSAoZGl2WCAtIDIpICsgJ3B4JztcbiAgICBkaXYuc3R5bGUudG9wID0gKGRpdlkgLSAyKSArICdweCc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1lbnUoZXZlbnQ6IE1vdXNlRXZlbnQsIGRhdGE6IGFueSwgY29udGV4dE1lbnVJdGVtczogSUNvbnRleHRNZW51SXRlbVtdLCByZWN0OiBDbGllbnRSZWN0LFxuICAgIHByb3BvZ2F0ZUV2ZW50OiBib29sZWFuKTogSFRNTERpdkVsZW1lbnQge1xuICAgIGxldCBtZW51RGl2OiBhbnk7XG4gICAgbWVudURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIG1lbnVEaXYuc2V0QXR0cmlidXRlKCdjbGFzcycsICdjb250ZXh0LW1lbnUnKTtcbiAgICBtZW51RGl2Lm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbiAoZTogTW91c2VFdmVudCkge1xuICAgICAgICByZW1vdmVNZW51KCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtZW51RGl2KTtcblxuICAgIGlmIChjb250ZXh0TWVudUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IG1lbnVMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcbiAgICAgICAgbWVudURpdi5hcHBlbmRDaGlsZChtZW51TGlzdCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZXh0TWVudUl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgaXRlbTogSUNvbnRleHRNZW51SXRlbSA9IGNvbnRleHRNZW51SXRlbXNbaV07XG4gICAgICAgICAgICBsZXQgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgaWYgKGl0ZW0uZGl2aWRlcikge1xuICAgICAgICAgICAgICAgIGxpLmNsYXNzTmFtZSArPSAnIGlzLWRpdmlkZXInO1xuICAgICAgICAgICAgICAgIGxpLmlubmVySFRNTCA9ICc8aHI+JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHRpdGxlIGF0dHJpYnV0ZSBzZXQuIENoZWNrIHRoZSBzcGVsbGluZyBvZiB5b3VyIG9wdGlvbnMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpLmNsYXNzTmFtZSArPSAnIGlzLWRpc2FibGVkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLmFjdGlvbiAmJiAhaXRlbS5zdWJtZW51KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpLmNsYXNzTmFtZSArPSAnIGlzLWhlYWRlcic7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uc3VibWVudSkge1xuICAgICAgICAgICAgICAgICAgICBsaS5pbm5lckhUTUwgPSBgPHNwYW4+PHRleHQ+JHtpdGVtLnRpdGxlfTwvdGV4dD5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8dGV4dCBzdHlsZT1cIndpZHRoOiA1cHg7IGZsb2F0OiByaWdodDsgY29sb3I6ICMwMDAwMDBBMFwiPiYjOTY1ODwvdGV4dD48L3NwYW4+J1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpLmlubmVySFRNTCA9IGl0ZW0udGl0bGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGkub25jbGljayA9IGZ1bmN0aW9uIChkOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uZGlzYWJsZWQpIHJldHVybjsgLy8gZG8gbm90aGluZyBpZiBkaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uYWN0aW9uKSByZXR1cm47IC8vIGhlYWRlcnMgaGF2ZSBubyBcImFjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYWN0aW9uKGxpLCBkYXRhLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxpLm9ubW91c2VlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlU3VibWVudShjb250ZXh0TWVudUl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uc3VibWVudSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlbGF0aXZlUmVjdCA9IGxpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiByZWxhdGl2ZVJlY3QudG9wICsgd2luZG93LnNjcm9sbFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiByZWxhdGl2ZVJlY3QuYm90dG9tICsgd2luZG93LnNjcm9sbFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcmVsYXRpdmVSZWN0LmxlZnQgKyB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmVsYXRpdmVSZWN0LnJpZ2h0ICsgd2luZG93LnNjcm9sbFgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiByZWxhdGl2ZVJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiByZWxhdGl2ZVJlY3Qud2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc3VibWVudURpdiA9IGNyZWF0ZU1lbnUoZXZlbnQsIGRhdGEsIGl0ZW0uc3VibWVudSwgcmVjdCwgcHJvcG9nYXRlRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZW51TGlzdC5hcHBlbmRDaGlsZChsaSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVudURpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgcG9zaXRpb25NZW51KG1lbnVEaXYsIHJlY3QpO1xuXG4gICAgICAgIGlmICghcHJvcG9nYXRlRXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZW51RGl2O1xufVxuXG5mdW5jdGlvbiByZW1vdmVNZW51SXRlbShpdGVtOiBJQ29udGV4dE1lbnVJdGVtKSB7XG4gICAgaWYgKGl0ZW0uc3VibWVudURpdikge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGl0ZW0uc3VibWVudURpdik7XG4gICAgICAgIGRlbGV0ZSBpdGVtLnN1Ym1lbnVEaXY7XG4gICAgfVxuICAgIGlmIChpdGVtLnN1Ym1lbnUpIHtcbiAgICAgICAgcmVtb3ZlU3VibWVudShpdGVtLnN1Ym1lbnUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3VibWVudShpdGVtczogSUNvbnRleHRNZW51SXRlbVtdKSB7XG4gICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbTogSUNvbnRleHRNZW51SXRlbSwgaW5kZXg6IG51bWJlcixcbiAgICAgICAgaXRlbXM6IElDb250ZXh0TWVudUl0ZW1bXSkge1xuICAgICAgICByZW1vdmVNZW51SXRlbShpdGVtKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTWVudSgpIHtcbiAgICByZW1vdmVTdWJtZW51KGxhc3RNZW51KTtcblxuICAgIGxldCBtZW51cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NvbnRleHQtbWVudScpO1xuICAgIHdoaWxlIChtZW51cy5sZW5ndGgpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChtZW51c1swXSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBrZXl1cExpc3RlbmVyKCkge1xuICAgIHdpbmRvdy5vbmtleXVwID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgICAgIHJlbW92ZU1lbnUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubGV0IGxhc3RNZW51OiBJQ29udGV4dE1lbnVJdGVtW10gPSBbXTtcbmV4cG9ydCBmdW5jdGlvbiBzaG93Q29udGV4dE1lbnUoZXZlbnQ6IE1vdXNlRXZlbnQsIGRhdGE6IGFueSwgY29udGV4dE1lbnVJdGVtczogSUNvbnRleHRNZW51SXRlbVtdLFxuICAgIHByb3BvZ2F0ZUV2ZW50OiBib29sZWFuID0gZmFsc2UpIHtcblxuICAgIGlmIChldmVudCkge1xuICAgICAgICBrZXl1cExpc3RlbmVyKCk7XG4gICAgICAgIHJlbW92ZU1lbnUoKTtcblxuICAgICAgICBsYXN0TWVudSA9IGNvbnRleHRNZW51SXRlbXM7XG4gICAgICAgIGNyZWF0ZU1lbnUoZXZlbnQsIGRhdGEsIGNvbnRleHRNZW51SXRlbXMsIHtcbiAgICAgICAgICAgIGxlZnQ6IGV2ZW50LnBhZ2VYLFxuICAgICAgICAgICAgdG9wOiBldmVudC5wYWdlWSxcbiAgICAgICAgICAgIHJpZ2h0OiBldmVudC5wYWdlWCxcbiAgICAgICAgICAgIGJvdHRvbTogZXZlbnQucGFnZVksXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICB9LCBwcm9wb2dhdGVFdmVudCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufSJdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQkE7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/core/context-menu.ts\n");

/***/ }),

/***/ "./src/core/element-manager.ts":
/*!*************************************!*\
  !*** ./src/core/element-manager.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utilities_1 = __webpack_require__(/*! ./utilities */ \"./src/core/utilities.ts\");\nconst ui_base_1 = __webpack_require__(/*! ../interface/ui-base */ \"./src/interface/ui-base.ts\");\nvar GroupType;\n(function (GroupType) {\n    GroupType[GroupType[\"Tooltip\"] = 0] = \"Tooltip\";\n    GroupType[GroupType[\"Highlight\"] = 1] = \"Highlight\";\n    GroupType[GroupType[\"Render\"] = 2] = \"Render\";\n    GroupType[GroupType[\"Focus\"] = 3] = \"Focus\";\n    GroupType[GroupType[\"Select\"] = 4] = \"Select\";\n    GroupType[GroupType[\"None\"] = 5] = \"None\";\n})(GroupType || (GroupType = {}));\nclass GroupInfo {\n    constructor() {\n        this._nameMap = {};\n        this._objectMap = new Map();\n    }\n}\nexports.GroupInfo = GroupInfo;\nfunction addTooltipCallback(elem) {\n    if (!elem.getTooltip) {\n        elem.getTooltip = function (event) {\n            if (elem.renderer && elem.renderer.getTooltipData) {\n                return elem.renderer.getTooltipData(elem, event);\n            }\n            return [{ source: elem, group: '', metrics: {} }];\n        };\n    }\n}\nfunction addClickCallback(elem) {\n    if (!elem.api) {\n        elem.api = {};\n    }\n    if (!elem.api.select) {\n        elem.api.select = function (event) {\n            if (elem.renderer && elem.renderer.select) {\n                return elem.renderer.select(elem, event);\n            }\n        };\n    }\n}\nfunction addHoverCallback(elem) {\n    if (!elem.api) {\n        elem.api = {};\n    }\n    if (!elem.api.cursorChange) {\n        elem.api.cursorChange = function (event) {\n            if (elem.renderer && elem.renderer.cursorChange) {\n                return elem.renderer.cursorChange(elem, event);\n            }\n        };\n    }\n    if (!elem.api.focus) {\n        elem.api.focus = function (event) {\n            /** @deprecated ('Deprecated since 1.14.0 in favor of focus.  Will be removed in 2.x') */\n            if (elem.renderer && !elem.renderer.focus && elem.renderer.hover) {\n                return elem.renderer.hover(elem, event);\n            }\n            // end deprecated\n            if (elem.renderer && elem.renderer.focus) {\n                return elem.renderer.focus(elem, event);\n            }\n        };\n        elem.api.hover = elem.api.focus;\n    }\n    if (!elem.api.brush) {\n        elem.api.brush = function (event) {\n            if (elem.renderer && elem.renderer.brush) {\n                return elem.renderer.brush(elem, event);\n            }\n        };\n    }\n    if (!elem.api.zoom) {\n        elem.api.zoom = function (event) {\n            if (elem.renderer && elem.renderer.zoom) {\n                return elem.renderer.zoom(elem, event);\n            }\n        };\n    }\n}\nfunction addRenderCallback(elem) {\n    if (!elem.api) {\n        elem.api = {};\n    }\n    if (!elem.api.brush) {\n        elem.api.brush = function (event) {\n            if (elem.renderer && elem.renderer.brush) {\n                return elem.renderer.brush(elem, event);\n            }\n        };\n    }\n    if (!elem.api.render) {\n        elem.api.render = function (renderer, options) {\n            if (!renderer) {\n                renderer = elem.renderer;\n            }\n            else {\n                elem.renderer = renderer;\n            }\n            return new Promise(function (resolve, reject) {\n                if (renderer) {\n                    elem.renderer.render(elem, options);\n                    resolve('Ok');\n                }\n                reject('No renderer available');\n            });\n        };\n    }\n}\n/** adds some default callbacks to a given UI object */\nfunction addCallbacks(elem) {\n    addTooltipCallback(elem);\n    addHoverCallback(elem);\n    addClickCallback(elem);\n    addRenderCallback(elem);\n}\nexports.addCallbacks = addCallbacks;\n/** used to group UI elements together.  Can be used to sync\n * selection/tooltips\n */\nclass ElementManager {\n    constructor() {\n        /** the list of elements managed by this manager */\n        this._elems = [];\n        let self = this;\n        this._groupInfo = [];\n        for (let i = 0; i < 5 /* None */; ++i) {\n            this._groupInfo.push(new GroupInfo());\n        }\n        this._onHoverCallback = function (event) {\n            if (!event.caller) {\n                console.warn('Warning no caller specified for this event, cannot propoate changes', event);\n            }\n            let elems = self._groupInfo[3 /* Focus */]._objectMap.get(event.caller);\n            if (elems) {\n                if (self._hoverCallback) {\n                    self._hoverCallback(elems, event);\n                }\n                else {\n                    for (let i = 0; i < elems.length; ++i) {\n                        let elem = elems[i];\n                        /** @deprecated to remove in 2.x */\n                        if (event.caller !== elem && elem.api && !elem.api.focus && elem.api.hover) {\n                            elem.api.hover(event);\n                        }\n                        // end deprecated\n                        if (event.caller !== elem && elem.api && elem.api.focus) {\n                            elem.api.focus(event);\n                        }\n                    }\n                }\n            }\n        };\n        let dispatch = function (groupType, callback, apiName) {\n            return function (event) {\n                if (!event.caller) {\n                    console.warn('Warning no caller specified for this event, cannot propagate changes', event);\n                }\n                let elems = self._groupInfo[groupType]._objectMap.get(event.caller);\n                if (elems) {\n                    if (callback) {\n                        callback(elems, event);\n                    }\n                    else {\n                        for (let i = 0; i < elems.length; ++i) {\n                            let elem = elems[i];\n                            if (event.caller !== elem && elem.api && elem.api[apiName]) {\n                                elem.api[apiName](event);\n                            }\n                        }\n                    }\n                }\n            };\n        };\n        this._onZoomCallback = dispatch(1 /* Highlight */, this._zoomCallback, 'zoom');\n        this._onCursorChangeCallback = dispatch(1 /* Highlight */, this._cursorChangeCallback, 'cursorChange');\n        this._onBrushCallback = dispatch(1 /* Highlight */, this._brushCallback, 'brush');\n        this._onClickCallback = dispatch(4 /* Select */, this._clickCallback, 'select');\n        this._onTooltipCallback = function (event) {\n            if (!event.caller) {\n                console.warn('Warning no caller specified for this event, cannot propoate changes', event);\n            }\n            let ret = [];\n            let elems = self._groupInfo[0 /* Tooltip */]._objectMap.get(event.caller);\n            if (elems) {\n                if (self._tooltipCallback) {\n                    ret = ret.concat(self._tooltipCallback(elems, event));\n                }\n                else {\n                    for (let i = 0; i < elems.length; ++i) {\n                        let elem = elems[i];\n                        let data = elem.getTooltip(event);\n                        ret = ret.concat(data);\n                    }\n                }\n                if (event.data && event.data.tooltip) {\n                    event.data.tooltip.setData(event.data.tooltip.getTitle(), ret);\n                }\n                return ret;\n            }\n        };\n        this._onUpdateCallback = function (caller, options) {\n            if (!caller) {\n                console.warn('Warning no caller specified for this event, cannot propoate changes');\n            }\n            let elems = self._groupInfo[2 /* Render */]._objectMap.get(caller);\n            if (elems) {\n                for (let i = 0; i < elems.length; ++i) {\n                    let elem = elems[i];\n                    if (elem.renderer) {\n                        // use the previous renderer\n                        elem.renderer.render(elem, options);\n                    }\n                }\n            }\n        };\n    }\n    removeFromGroup(elem, type) {\n        let list = this._groupInfo[type]._objectMap.get(elem);\n        if (list) {\n            utilities_1.removeFromList(elem, list);\n        }\n    }\n    addToGroup(elem, groupName, type) {\n        if (!this._groupInfo[type]._nameMap.hasOwnProperty(groupName)) {\n            this._groupInfo[type]._nameMap[groupName] = [];\n        }\n        this._groupInfo[type]._nameMap[groupName].push(elem);\n        this._groupInfo[type]._objectMap.set(elem, this._groupInfo[type]._nameMap[groupName]);\n    }\n    /**\n     * add a elem to the manager\n     *\n     * @param elem - the elem that should should be added\n     * @param tooltipGroupName - Name of the group that this elem should be \"ganged\"\n     *   with when showing tooltips.  If not specified, this elem will not be \"ganged\" with any\n     *   other elem.\n     * @param highlightGroupName - Name of the group that this elem should be \"ganged\"\n     *   with when doing highlighting.  If not specified, this elem will not be \"ganged\" with any\n     *   other elem.\n     * @param renderGroupName - Name of the group that this elem should be \"ganged\"\n     *   with when rerendering.  If not specified, this elem will not be \"ganged\" with any\n     *   other elem.\n     * @return - The elem manager instance.\n     */\n    addElement(elem, tooltipGroupName, highlightGroupName, renderGroupName) {\n        if (!elem) {\n            return this;\n        }\n        let index = this._elems.indexOf(elem);\n        if (index === -1) {\n            addCallbacks(elem);\n            this._elems.push(elem);\n            let renderedElements;\n            if (!elem.getElements) {\n                elem.getElements = function () { return [elem]; };\n            }\n            renderedElements = elem.getElements();\n            for (let i = 0; i < renderedElements.length; ++i) {\n                let renderedElement = renderedElements[i];\n                if (tooltipGroupName) {\n                    this.addToTooltipGroup(renderedElement, tooltipGroupName);\n                }\n                if (highlightGroupName) {\n                    this.addToHighlightGroup(renderedElement, highlightGroupName);\n                }\n                if (renderGroupName) {\n                    this.addToRenderGroup(renderedElement, renderGroupName);\n                }\n            }\n        }\n        else {\n            throw 'Element already exists in this manager';\n        }\n        elem.manager = this;\n        return this;\n    }\n    /**\n     * remove a elem from the manager, removes it from all groups\n     *\n     * @param elem - the elem that should should be removed\n     *\n     * @return - The elem manager instance.\n     */\n    removeElement(elem) {\n        if (!elem) {\n            return this;\n        }\n        let renderedElements;\n        if (elem.getElements) {\n            renderedElements = elem.getElements();\n        }\n        else {\n            renderedElements = [elem];\n        }\n        for (let i = 0; i < renderedElements.length; ++i) {\n            let renderedElement = renderedElements[i];\n            this.removeFromTooltipGroup(renderedElement);\n            this.removeFromHighlightGroup(renderedElement);\n            this.removeFromRenderGroup(renderedElement);\n        }\n        utilities_1.removeFromList(elem, this._elems);\n        delete elem.manager;\n        return this;\n    }\n    /**\n     * Return all the elems in this list\n     * @return the list of elems\n     */\n    getElements() {\n        return this._elems;\n    }\n    /**\n     * user callback called when a tooltip is created\n     *\n     * @param the functiotn to be called\n     */\n    setZoomCallback(callback) {\n        this._zoomCallback = callback;\n        return this;\n    }\n    /**\n     * user callback called when a hover event happens\n     *\n     * @param the function to be called\n     */\n    setHoverCallback(callback) {\n        this._hoverCallback = callback;\n        return this;\n    }\n    /**\n     * user callback called when a hover event happens\n     *\n     * @param the function to be called\n     */\n    setClickCallback(callback) {\n        this._clickCallback = callback;\n        return this;\n    }\n    /**\n     * user callback called when a tooltip is created\n     *\n     * @param the functiotn to be called\n     */\n    setTooltipCallback(callback) {\n        this._tooltipCallback = callback;\n        return this;\n    }\n    /**\n     * user callback called when a selection event happens\n     *\n     * @param the function to be called\n     */\n    setBrushCallback(callback) {\n        this._brushCallback = callback;\n        return this;\n    }\n    /**\n     * set the group this tooltip is associated with\n     *\n     * @param elem - the elem that should should be \"ganged\"\n     * @param groupName - Name of the group that this elem should be \"ganged\"\n     *   with.\n     *\n     * @return - The elem manager instance.\n     */\n    addToTooltipGroup(elem, groupName) {\n        addTooltipCallback(elem);\n        this.removeFromTooltipGroup(elem);\n        this.addToGroup(elem, groupName, 0 /* Tooltip */);\n        let self = this;\n        if (elem.onTooltip) {\n            let func = elem.onTooltip;\n            elem.onTooltip = function (event) {\n                self._onTooltipCallback(event);\n                func(event);\n            };\n        }\n        else {\n            elem.onTooltip = this._onTooltipCallback;\n        }\n        return this;\n    }\n    /**\n     * remove the elem from the tooltip group it is in\n     *\n     * @param elem - the elem that should should be \"unganged\"\n     *\n     * @return - The elem manager instance.\n     */\n    removeFromTooltipGroup(elem) {\n        this.removeFromGroup(elem, 0 /* Tooltip */);\n        return this;\n    }\n    /**\n    * set the group to sync this elem with\n    *\n    * @param elem - the elem that should should be \"ganged\"\n    * @param groupName - Name of the group that this elem should be \"ganged\"\n    *   with.\n    *\n    * @return - The elem manager instance.\n    */\n    addToFocusGroup(elem, groupName) {\n        addHoverCallback(elem);\n        this.removeFromFocusGroup(elem);\n        let self = this;\n        if (elem.onHover) {\n            let func = elem.onHover;\n            elem.onHover = function (event) {\n                self._onHoverCallback(event);\n                func(event);\n            };\n        }\n        else {\n            elem.onHover = self._onHoverCallback;\n        }\n        this.addToGroup(elem, groupName, 3 /* Focus */);\n        return this;\n    }\n    /**\n     * remove the elem from the zoom group it is in\n     *\n     * @param elem - the elem that should should be \"unganged\"\n     *\n     * @return - The elem manager instance.\n     */\n    removeFromFocusGroup(elem) {\n        this.removeFromGroup(elem, 3 /* Focus */);\n        return this;\n    }\n    /**\n    * set the group to sync this elem with\n    *\n    * @param elem - the elem that should should be \"ganged\"\n    * @param groupName - Name of the group that this elem should be \"ganged\"\n    *   with.\n    *\n    * @return - The elem manager instance.\n    */\n    addToSelectGroup(elem, groupName) {\n        addClickCallback(elem);\n        this.removeFromSelectGroup(elem);\n        let self = this;\n        if (elem.onClick) {\n            let func = elem.onClick;\n            elem.onClick = function (event) {\n                self._onClickCallback(event);\n                func(event);\n            };\n        }\n        else {\n            elem.onClick = self._onClickCallback;\n        }\n        this.addToGroup(elem, groupName, 4 /* Select */);\n        return this;\n    }\n    /**\n     * remove the elem from the zoom group it is in\n     *\n     * @param elem - the elem that should should be \"unganged\"\n     *\n     * @return - The elem manager instance.\n     */\n    removeFromSelectGroup(elem) {\n        this.removeFromGroup(elem, 4 /* Select */);\n        return this;\n    }\n    /**\n     * set the group to sync this elem with\n     *\n     * @param elem - the elem that should should be \"ganged\"\n     * @param groupName - Name of the group that this elem should be \"ganged\"\n     *   with.\n     *\n     * @return - The elem manager instance.\n     */\n    addToHighlightGroup(elem, groupName) {\n        addHoverCallback(elem);\n        this.removeFromHighlightGroup(elem);\n        this.addToFocusGroup(elem, groupName);\n        this.addToSelectGroup(elem, groupName);\n        let self = this;\n        if (elem.onBrush) {\n            let func = elem.onBrush;\n            elem.onBrush = function (event) {\n                self._onBrushCallback(event);\n                func(event);\n            };\n        }\n        else {\n            elem.onBrush = self._onBrushCallback;\n        }\n        if (elem.onCursorChanged) {\n            let func = elem.onCursorChanged;\n            elem.onCursorChanged = function (event) {\n                self._onCursorChangeCallback(event);\n                func(event);\n            };\n        }\n        else {\n            elem.onCursorChanged = this._onCursorChangeCallback;\n        }\n        if (elem.onZoom) {\n            let func = elem.onZoom;\n            elem.onZoom = function (event) {\n                self._onZoomCallback(event);\n                func(event);\n            };\n        }\n        else {\n            elem.onZoom = this._onZoomCallback;\n        }\n        let elems = this._groupInfo[1 /* Highlight */]._nameMap[groupName];\n        if (elems && elems.length) {\n            let oldElem = elems[0];\n            if (oldElem.api.getOptions && elem.api && elem.api.zoom) {\n                let options = oldElem.api.getOptions();\n                let zoomEvent = utilities_1.copy(options);\n                zoomEvent.event = ui_base_1.EventType.Zoom;\n                setTimeout(() => {\n                    elem.api.zoom(zoomEvent);\n                });\n            }\n        }\n        this.addToGroup(elem, groupName, 1 /* Highlight */);\n        return this;\n    }\n    /**\n     * remove the elem from the zoom group it is in\n     *\n     * @param elem - the elem that should should be \"unganged\"\n     *\n     * @return - The elem manager instance.\n     */\n    removeFromHighlightGroup(elem) {\n        this.removeFromFocusGroup(elem);\n        this.removeFromSelectGroup(elem);\n        this.removeFromGroup(elem, 1 /* Highlight */);\n        return this;\n    }\n    /**\n     * set the group to select this elem with\n     *\n     * @param elem - the elem that should should be \"ganged\"\n     * @param groupName - Name of the group that this elem should be \"ganged\"\n     *   with.\n     *\n     * @return - The elem manager instance.\n     */\n    addToRenderGroup(elem, groupName) {\n        addRenderCallback(elem);\n        this.removeFromRenderGroup(elem);\n        this.addToGroup(elem, groupName, 2 /* Render */);\n        let self = this;\n        if (elem.handleUpdate) {\n            let func = elem.handleUpdate;\n            elem.handleUpdate = function (caller, options) {\n                self._onUpdateCallback(caller, options);\n                func(caller, options);\n            };\n        }\n        else {\n            elem.handleUpdate = this._onUpdateCallback;\n        }\n        return this;\n    }\n    /**\n     * remove the elem from the zoom group it is in\n     *\n     * @param elem - the elem that should should be \"unganged\"\n     *\n     * @return - The elem manager instance.\n     */\n    removeFromRenderGroup(elem) {\n        this.removeFromGroup(elem, 2 /* Render */);\n        return this;\n    }\n    /** clear all the elements in this list */\n    clear() {\n        this._elems.length = 0;\n        this._groupInfo.length = 0;\n        for (let i = 0; i < 5 /* None */; ++i) {\n            this._groupInfo.push(new GroupInfo());\n        }\n    }\n}\nexports.ElementManager = ElementManager;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS9lbGVtZW50LW1hbmFnZXIudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9VV1QvLi9zcmMvY29yZS9lbGVtZW50LW1hbmFnZXIudHM/NjNiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb3B5LCByZW1vdmVGcm9tTGlzdCB9IGZyb20gJy4vdXRpbGl0aWVzJztcbmltcG9ydCB7XG4gICAgVUlFbGVtZW50LCBVSUVsZW1lbnRNYW5hZ2VyLCBVSVJlbmRlcmVyLCBJRXZlbnQsIElPcHRpb25zLFxuICAgIElUb29sdGlwRGF0YSwgRXZlbnRUeXBlXG59IGZyb20gJy4uL2ludGVyZmFjZS91aS1iYXNlJztcblxuY29uc3QgZW51bSBHcm91cFR5cGUge1xuICAgIFRvb2x0aXAsXG4gICAgSGlnaGxpZ2h0LFxuICAgIFJlbmRlcixcbiAgICBGb2N1cyxcbiAgICBTZWxlY3QsXG4gICAgTm9uZVxufVxuXG5leHBvcnQgY2xhc3MgR3JvdXBJbmZvIHtcbiAgICBwdWJsaWMgX25hbWVNYXA6IHsgW2luZGV4OiBzdHJpbmddOiBVSUVsZW1lbnRbXSB9O1xuICAgIHB1YmxpYyBfb2JqZWN0TWFwOiBNYXA8VUlFbGVtZW50LCBVSUVsZW1lbnRbXT47XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbmFtZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLl9vYmplY3RNYXAgPSBuZXcgTWFwPFVJRWxlbWVudCwgVUlFbGVtZW50W10+KCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRUb29sdGlwQ2FsbGJhY2soZWxlbTogVUlFbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtLmdldFRvb2x0aXApIHtcbiAgICAgICAgZWxlbS5nZXRUb29sdGlwID0gZnVuY3Rpb24gKGV2ZW50OiBJRXZlbnQpOiBJVG9vbHRpcERhdGFbXSB7XG4gICAgICAgICAgICBpZiAoZWxlbS5yZW5kZXJlciAmJiBlbGVtLnJlbmRlcmVyLmdldFRvb2x0aXBEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ucmVuZGVyZXIuZ2V0VG9vbHRpcERhdGEoZWxlbSwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt7IHNvdXJjZTogZWxlbSwgZ3JvdXA6ICcnLCBtZXRyaWNzOiB7fSB9XTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkQ2xpY2tDYWxsYmFjayhlbGVtOiBVSUVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW0uYXBpKSB7XG4gICAgICAgIGVsZW0uYXBpID0ge31cbiAgICB9XG4gICAgaWYgKCFlbGVtLmFwaS5zZWxlY3QpIHtcbiAgICAgICAgZWxlbS5hcGkuc2VsZWN0ID0gZnVuY3Rpb24gKGV2ZW50OiBJRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChlbGVtLnJlbmRlcmVyICYmIGVsZW0ucmVuZGVyZXIuc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ucmVuZGVyZXIuc2VsZWN0KGVsZW0sIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkSG92ZXJDYWxsYmFjayhlbGVtOiBVSUVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW0uYXBpKSB7XG4gICAgICAgIGVsZW0uYXBpID0ge31cbiAgICB9XG4gICAgaWYgKCFlbGVtLmFwaS5jdXJzb3JDaGFuZ2UpIHtcbiAgICAgICAgZWxlbS5hcGkuY3Vyc29yQ2hhbmdlID0gZnVuY3Rpb24gKGV2ZW50OiBJRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChlbGVtLnJlbmRlcmVyICYmIGVsZW0ucmVuZGVyZXIuY3Vyc29yQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ucmVuZGVyZXIuY3Vyc29yQ2hhbmdlKGVsZW0sIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZWxlbS5hcGkuZm9jdXMpIHtcbiAgICAgICAgZWxlbS5hcGkuZm9jdXMgPSBmdW5jdGlvbiAoZXZlbnQ6IElFdmVudCk6IHZvaWQge1xuICAgICAgICAgICAgLyoqIEBkZXByZWNhdGVkICgnRGVwcmVjYXRlZCBzaW5jZSAxLjE0LjAgaW4gZmF2b3Igb2YgZm9jdXMuICBXaWxsIGJlIHJlbW92ZWQgaW4gMi54JykgKi9cbiAgICAgICAgICAgIGlmIChlbGVtLnJlbmRlcmVyICYmICFlbGVtLnJlbmRlcmVyLmZvY3VzICYmIGVsZW0ucmVuZGVyZXIuaG92ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5yZW5kZXJlci5ob3ZlcihlbGVtLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbmQgZGVwcmVjYXRlZFxuXG4gICAgICAgICAgICBpZiAoZWxlbS5yZW5kZXJlciAmJiBlbGVtLnJlbmRlcmVyLmZvY3VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ucmVuZGVyZXIuZm9jdXMoZWxlbSwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsZW0uYXBpLmhvdmVyID0gZWxlbS5hcGkuZm9jdXM7XG4gICAgfVxuXG4gICAgaWYgKCFlbGVtLmFwaS5icnVzaCkge1xuICAgICAgICBlbGVtLmFwaS5icnVzaCA9IGZ1bmN0aW9uIChldmVudDogSUV2ZW50KTogdm9pZCB7XG4gICAgICAgICAgICBpZiAoZWxlbS5yZW5kZXJlciAmJiBlbGVtLnJlbmRlcmVyLmJydXNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ucmVuZGVyZXIuYnJ1c2goZWxlbSwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFlbGVtLmFwaS56b29tKSB7XG4gICAgICAgIGVsZW0uYXBpLnpvb20gPSBmdW5jdGlvbiAoZXZlbnQ6IElFdmVudCk6IHZvaWQge1xuICAgICAgICAgICAgaWYgKGVsZW0ucmVuZGVyZXIgJiYgZWxlbS5yZW5kZXJlci56b29tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0ucmVuZGVyZXIuem9vbShlbGVtLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZFJlbmRlckNhbGxiYWNrKGVsZW06IFVJRWxlbWVudCkge1xuICAgIGlmICghZWxlbS5hcGkpIHtcbiAgICAgICAgZWxlbS5hcGkgPSB7fVxuICAgIH1cbiAgICBpZiAoIWVsZW0uYXBpLmJydXNoKSB7XG4gICAgICAgIGVsZW0uYXBpLmJydXNoID0gZnVuY3Rpb24gKGV2ZW50OiBJRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChlbGVtLnJlbmRlcmVyICYmIGVsZW0ucmVuZGVyZXIuYnJ1c2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5yZW5kZXJlci5icnVzaChlbGVtLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFlbGVtLmFwaS5yZW5kZXIpIHtcbiAgICAgICAgZWxlbS5hcGkucmVuZGVyID0gZnVuY3Rpb24gKHJlbmRlcmVyOiBVSVJlbmRlcmVyLCBvcHRpb25zOiBJT3B0aW9ucyk6IFByb21pc2U8YW55PiB7XG4gICAgICAgICAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIgPSBlbGVtLnJlbmRlcmVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxhbnk+KGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5yZW5kZXJlci5yZW5kZXIoZWxlbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoJ09rJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlamVjdCgnTm8gcmVuZGVyZXIgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqIGFkZHMgc29tZSBkZWZhdWx0IGNhbGxiYWNrcyB0byBhIGdpdmVuIFVJIG9iamVjdCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENhbGxiYWNrcyhlbGVtOiBVSUVsZW1lbnQpIHtcbiAgICBhZGRUb29sdGlwQ2FsbGJhY2soZWxlbSk7XG4gICAgYWRkSG92ZXJDYWxsYmFjayhlbGVtKTtcbiAgICBhZGRDbGlja0NhbGxiYWNrKGVsZW0pO1xuICAgIGFkZFJlbmRlckNhbGxiYWNrKGVsZW0pO1xufVxuXG4vKiogdXNlZCB0byBncm91cCBVSSBlbGVtZW50cyB0b2dldGhlci4gIENhbiBiZSB1c2VkIHRvIHN5bmNcbiAqIHNlbGVjdGlvbi90b29sdGlwc1xuICovXG5leHBvcnQgY2xhc3MgRWxlbWVudE1hbmFnZXIgaW1wbGVtZW50cyBVSUVsZW1lbnRNYW5hZ2VyIHtcbiAgICAvKiogdGhlIGxpc3Qgb2YgZWxlbWVudHMgbWFuYWdlZCBieSB0aGlzIG1hbmFnZXIgKi9cbiAgICBwcm90ZWN0ZWQgX2VsZW1zOiBVSUVsZW1lbnRbXSA9IFtdO1xuXG4gICAgLyoqIHRoZSBncm91cHMgb2YgZWxlbWVudHMgY3JlYXRlZCBieSB0aGlzIGdyb3VwICovXG4gICAgcHJvdGVjdGVkIF9ncm91cEluZm86IEdyb3VwSW5mb1tdO1xuXG4gICAgcHJvdGVjdGVkIF9ob3ZlckNhbGxiYWNrOiAoZ3JvdXA6IFVJRWxlbWVudFtdLCBldmVudDogSUV2ZW50KSA9PiB2b2lkO1xuICAgIHByb3RlY3RlZCBfY2xpY2tDYWxsYmFjazogKGdyb3VwOiBVSUVsZW1lbnRbXSwgZXZlbnQ6IElFdmVudCkgPT4gdm9pZDtcbiAgICBwcm90ZWN0ZWQgX3pvb21DYWxsYmFjazogKGdyb3VwOiBVSUVsZW1lbnRbXSwgZXZlbnQ6IElFdmVudCkgPT4gdm9pZDtcbiAgICBwcm90ZWN0ZWQgX3Rvb2x0aXBDYWxsYmFjazogKGdyb3VwOiBVSUVsZW1lbnRbXSwgZXZlbnQ6IElFdmVudCkgPT4gSVRvb2x0aXBEYXRhO1xuICAgIHByb3RlY3RlZCBfY3Vyc29yQ2hhbmdlQ2FsbGJhY2s6IChncm91cDogVUlFbGVtZW50W10sIGV2ZW50OiBJRXZlbnQpID0+IHZvaWQ7XG4gICAgcHJvdGVjdGVkIF9icnVzaENhbGxiYWNrOiAoZ3JvdXA6IFVJRWxlbWVudFtdLCBldmVudDogSUV2ZW50KSA9PiB2b2lkO1xuXG4gICAgcHJvdGVjdGVkIF9vblRvb2x0aXBDYWxsYmFjazogKGV2ZW50OiBJRXZlbnQpID0+IElUb29sdGlwRGF0YVtdO1xuICAgIHByb3RlY3RlZCBfb25ab29tQ2FsbGJhY2s6IChldmVudDogSUV2ZW50KSA9PiB2b2lkO1xuICAgIHByb3RlY3RlZCBfb25Ib3ZlckNhbGxiYWNrOiAoZXZlbnQ6IElFdmVudCkgPT4gdm9pZDtcbiAgICBwcm90ZWN0ZWQgX29uQ2xpY2tDYWxsYmFjazogKGV2ZW50OiBJRXZlbnQpID0+IHZvaWQ7XG4gICAgcHJvdGVjdGVkIF9vbkN1cnNvckNoYW5nZUNhbGxiYWNrOiAoZXZlbnQ6IElFdmVudCkgPT4gdm9pZDtcbiAgICBwcm90ZWN0ZWQgX29uQnJ1c2hDYWxsYmFjazogKGV2ZW50OiBJRXZlbnQpID0+IHZvaWQ7XG4gICAgcHJvdGVjdGVkIF9vblVwZGF0ZUNhbGxiYWNrOiAoY2FsbGVyOiBVSUVsZW1lbnQsIG9wdGlvbnM6IElPcHRpb25zKSA9PiB2b2lkO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcblxuICAgICAgICB0aGlzLl9ncm91cEluZm8gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBHcm91cFR5cGUuTm9uZTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLl9ncm91cEluZm8ucHVzaChuZXcgR3JvdXBJbmZvKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb25Ib3ZlckNhbGxiYWNrID0gZnVuY3Rpb24gKGV2ZW50OiBJRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgICAgIGlmICghZXZlbnQuY2FsbGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nIG5vIGNhbGxlciBzcGVjaWZpZWQgZm9yIHRoaXMgZXZlbnQsIGNhbm5vdCBwcm9wb2F0ZSBjaGFuZ2VzJywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVsZW1zID0gc2VsZi5fZ3JvdXBJbmZvW0dyb3VwVHlwZS5Gb2N1c10uX29iamVjdE1hcC5nZXQoZXZlbnQuY2FsbGVyKTtcbiAgICAgICAgICAgIGlmIChlbGVtcykge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9ob3ZlckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2hvdmVyQ2FsbGJhY2soZWxlbXMsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbSA9IGVsZW1zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqIEBkZXByZWNhdGVkIHRvIHJlbW92ZSBpbiAyLnggKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5jYWxsZXIgIT09IGVsZW0gJiYgZWxlbS5hcGkgJiYgIWVsZW0uYXBpLmZvY3VzICYmIGVsZW0uYXBpLmhvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5hcGkuaG92ZXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5jYWxsZXIgIT09IGVsZW0gJiYgZWxlbS5hcGkgJiYgZWxlbS5hcGkuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmFwaS5mb2N1cyhldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGlzcGF0Y2ggPSBmdW5jdGlvbiAoZ3JvdXBUeXBlOiBHcm91cFR5cGUsIGNhbGxiYWNrOiBhbnksIGFwaU5hbWU6IHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudDogSUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFldmVudC5jYWxsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXYXJuaW5nIG5vIGNhbGxlciBzcGVjaWZpZWQgZm9yIHRoaXMgZXZlbnQsIGNhbm5vdCBwcm9wYWdhdGUgY2hhbmdlcycsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGVsZW1zID0gc2VsZi5fZ3JvdXBJbmZvW2dyb3VwVHlwZV0uX29iamVjdE1hcC5nZXQoZXZlbnQuY2FsbGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlbGVtcywgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbGVtID0gZWxlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmNhbGxlciAhPT0gZWxlbSAmJiBlbGVtLmFwaSAmJiBlbGVtLmFwaVthcGlOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmFwaVthcGlOYW1lXShldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29uWm9vbUNhbGxiYWNrID0gZGlzcGF0Y2goR3JvdXBUeXBlLkhpZ2hsaWdodCwgdGhpcy5fem9vbUNhbGxiYWNrLCAnem9vbScpO1xuICAgICAgICB0aGlzLl9vbkN1cnNvckNoYW5nZUNhbGxiYWNrID0gZGlzcGF0Y2goR3JvdXBUeXBlLkhpZ2hsaWdodCwgdGhpcy5fY3Vyc29yQ2hhbmdlQ2FsbGJhY2ssICdjdXJzb3JDaGFuZ2UnKTtcbiAgICAgICAgdGhpcy5fb25CcnVzaENhbGxiYWNrID0gZGlzcGF0Y2goR3JvdXBUeXBlLkhpZ2hsaWdodCwgdGhpcy5fYnJ1c2hDYWxsYmFjaywgJ2JydXNoJyk7XG4gICAgICAgIHRoaXMuX29uQ2xpY2tDYWxsYmFjayA9IGRpc3BhdGNoKEdyb3VwVHlwZS5TZWxlY3QsIHRoaXMuX2NsaWNrQ2FsbGJhY2ssICdzZWxlY3QnKTtcblxuICAgICAgICB0aGlzLl9vblRvb2x0aXBDYWxsYmFjayA9IGZ1bmN0aW9uIChldmVudDogSUV2ZW50KTogSVRvb2x0aXBEYXRhW10ge1xuICAgICAgICAgICAgaWYgKCFldmVudC5jYWxsZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmcgbm8gY2FsbGVyIHNwZWNpZmllZCBmb3IgdGhpcyBldmVudCwgY2Fubm90IHByb3BvYXRlIGNoYW5nZXMnLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmV0OiBJVG9vbHRpcERhdGFbXSA9IFtdO1xuICAgICAgICAgICAgbGV0IGVsZW1zID0gc2VsZi5fZ3JvdXBJbmZvW0dyb3VwVHlwZS5Ub29sdGlwXS5fb2JqZWN0TWFwLmdldChldmVudC5jYWxsZXIpO1xuICAgICAgICAgICAgaWYgKGVsZW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3Rvb2x0aXBDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KHNlbGYuX3Rvb2x0aXBDYWxsYmFjayhlbGVtcywgZXZlbnQpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbSA9IGVsZW1zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBlbGVtLmdldFRvb2x0aXAoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLnRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGF0YS50b29sdGlwLnNldERhdGEoZXZlbnQuZGF0YS50b29sdGlwLmdldFRpdGxlKCksIHJldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb25VcGRhdGVDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsZXI6IFVJRWxlbWVudCxcbiAgICAgICAgICAgIG9wdGlvbnM6IElPcHRpb25zKTogdm9pZCB7XG4gICAgICAgICAgICBpZiAoIWNhbGxlcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignV2FybmluZyBubyBjYWxsZXIgc3BlY2lmaWVkIGZvciB0aGlzIGV2ZW50LCBjYW5ub3QgcHJvcG9hdGUgY2hhbmdlcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVsZW1zID0gc2VsZi5fZ3JvdXBJbmZvW0dyb3VwVHlwZS5SZW5kZXJdLl9vYmplY3RNYXAuZ2V0KGNhbGxlcik7XG4gICAgICAgICAgICBpZiAoZWxlbXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbGVtID0gZWxlbXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW0ucmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgcHJldmlvdXMgcmVuZGVyZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0ucmVuZGVyZXIucmVuZGVyKGVsZW0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW1vdmVGcm9tR3JvdXAoZWxlbTogVUlFbGVtZW50LCB0eXBlOiBHcm91cFR5cGUpIHtcbiAgICAgICAgbGV0IGxpc3QgPSB0aGlzLl9ncm91cEluZm9bdHlwZV0uX29iamVjdE1hcC5nZXQoZWxlbSk7XG4gICAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgICAgICByZW1vdmVGcm9tTGlzdChlbGVtLCBsaXN0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgYWRkVG9Hcm91cChlbGVtOiBVSUVsZW1lbnQsIGdyb3VwTmFtZTogc3RyaW5nLCB0eXBlOiBHcm91cFR5cGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ncm91cEluZm9bdHlwZV0uX25hbWVNYXAuaGFzT3duUHJvcGVydHkoZ3JvdXBOYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fZ3JvdXBJbmZvW3R5cGVdLl9uYW1lTWFwW2dyb3VwTmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ncm91cEluZm9bdHlwZV0uX25hbWVNYXBbZ3JvdXBOYW1lXS5wdXNoKGVsZW0pO1xuICAgICAgICB0aGlzLl9ncm91cEluZm9bdHlwZV0uX29iamVjdE1hcC5zZXQoZWxlbSwgdGhpcy5fZ3JvdXBJbmZvW3R5cGVdLl9uYW1lTWFwW2dyb3VwTmFtZV0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFkZCBhIGVsZW0gdG8gdGhlIG1hbmFnZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtIC0gdGhlIGVsZW0gdGhhdCBzaG91bGQgc2hvdWxkIGJlIGFkZGVkXG4gICAgICogQHBhcmFtIHRvb2x0aXBHcm91cE5hbWUgLSBOYW1lIG9mIHRoZSBncm91cCB0aGF0IHRoaXMgZWxlbSBzaG91bGQgYmUgXCJnYW5nZWRcIlxuICAgICAqICAgd2l0aCB3aGVuIHNob3dpbmcgdG9vbHRpcHMuICBJZiBub3Qgc3BlY2lmaWVkLCB0aGlzIGVsZW0gd2lsbCBub3QgYmUgXCJnYW5nZWRcIiB3aXRoIGFueVxuICAgICAqICAgb3RoZXIgZWxlbS5cbiAgICAgKiBAcGFyYW0gaGlnaGxpZ2h0R3JvdXBOYW1lIC0gTmFtZSBvZiB0aGUgZ3JvdXAgdGhhdCB0aGlzIGVsZW0gc2hvdWxkIGJlIFwiZ2FuZ2VkXCJcbiAgICAgKiAgIHdpdGggd2hlbiBkb2luZyBoaWdobGlnaHRpbmcuICBJZiBub3Qgc3BlY2lmaWVkLCB0aGlzIGVsZW0gd2lsbCBub3QgYmUgXCJnYW5nZWRcIiB3aXRoIGFueVxuICAgICAqICAgb3RoZXIgZWxlbS5cbiAgICAgKiBAcGFyYW0gcmVuZGVyR3JvdXBOYW1lIC0gTmFtZSBvZiB0aGUgZ3JvdXAgdGhhdCB0aGlzIGVsZW0gc2hvdWxkIGJlIFwiZ2FuZ2VkXCJcbiAgICAgKiAgIHdpdGggd2hlbiByZXJlbmRlcmluZy4gIElmIG5vdCBzcGVjaWZpZWQsIHRoaXMgZWxlbSB3aWxsIG5vdCBiZSBcImdhbmdlZFwiIHdpdGggYW55XG4gICAgICogICBvdGhlciBlbGVtLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZWxlbSBtYW5hZ2VyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHB1YmxpYyBhZGRFbGVtZW50KGVsZW06IFVJRWxlbWVudCwgdG9vbHRpcEdyb3VwTmFtZT86IHN0cmluZyxcbiAgICAgICAgaGlnaGxpZ2h0R3JvdXBOYW1lPzogc3RyaW5nLCByZW5kZXJHcm91cE5hbWU/OiBzdHJpbmcpOiBFbGVtZW50TWFuYWdlciB7XG5cbiAgICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLl9lbGVtcy5pbmRleE9mKGVsZW0pO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBhZGRDYWxsYmFja3MoZWxlbSk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtcy5wdXNoKGVsZW0pO1xuXG4gICAgICAgICAgICBsZXQgcmVuZGVyZWRFbGVtZW50czogVUlFbGVtZW50W107XG4gICAgICAgICAgICBpZiAoIWVsZW0uZ2V0RWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBlbGVtLmdldEVsZW1lbnRzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW2VsZW1dIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyZWRFbGVtZW50cyA9IGVsZW0uZ2V0RWxlbWVudHMoKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJlZEVsZW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlbmRlcmVkRWxlbWVudCA9IHJlbmRlcmVkRWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHRvb2x0aXBHcm91cE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUb1Rvb2x0aXBHcm91cChyZW5kZXJlZEVsZW1lbnQsIHRvb2x0aXBHcm91cE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0R3JvdXBOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVG9IaWdobGlnaHRHcm91cChyZW5kZXJlZEVsZW1lbnQsIGhpZ2hsaWdodEdyb3VwTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJHcm91cE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUb1JlbmRlckdyb3VwKHJlbmRlcmVkRWxlbWVudCwgcmVuZGVyR3JvdXBOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyAnRWxlbWVudCBhbHJlYWR5IGV4aXN0cyBpbiB0aGlzIG1hbmFnZXInO1xuICAgICAgICB9XG4gICAgICAgIGVsZW0ubWFuYWdlciA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSBhIGVsZW0gZnJvbSB0aGUgbWFuYWdlciwgcmVtb3ZlcyBpdCBmcm9tIGFsbCBncm91cHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtIC0gdGhlIGVsZW0gdGhhdCBzaG91bGQgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm4gLSBUaGUgZWxlbSBtYW5hZ2VyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHB1YmxpYyByZW1vdmVFbGVtZW50KGVsZW06IFVJRWxlbWVudCk6IEVsZW1lbnRNYW5hZ2VyIHtcbiAgICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZW5kZXJlZEVsZW1lbnRzOiBVSUVsZW1lbnRbXTtcbiAgICAgICAgaWYgKGVsZW0uZ2V0RWxlbWVudHMpIHtcbiAgICAgICAgICAgIHJlbmRlcmVkRWxlbWVudHMgPSBlbGVtLmdldEVsZW1lbnRzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlZEVsZW1lbnRzID0gW2VsZW1dO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJlZEVsZW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgcmVuZGVyZWRFbGVtZW50ID0gcmVuZGVyZWRFbGVtZW50c1tpXTtcblxuICAgICAgICAgICAgdGhpcy5yZW1vdmVGcm9tVG9vbHRpcEdyb3VwKHJlbmRlcmVkRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZyb21IaWdobGlnaHRHcm91cChyZW5kZXJlZEVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVGcm9tUmVuZGVyR3JvdXAocmVuZGVyZWRFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVGcm9tTGlzdChlbGVtLCB0aGlzLl9lbGVtcyk7XG5cbiAgICAgICAgZGVsZXRlIGVsZW0ubWFuYWdlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFsbCB0aGUgZWxlbXMgaW4gdGhpcyBsaXN0XG4gICAgICogQHJldHVybiB0aGUgbGlzdCBvZiBlbGVtc1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXRFbGVtZW50cygpOiBVSUVsZW1lbnRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1c2VyIGNhbGxiYWNrIGNhbGxlZCB3aGVuIGEgdG9vbHRpcCBpcyBjcmVhdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhlIGZ1bmN0aW90biB0byBiZSBjYWxsZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0Wm9vbUNhbGxiYWNrKGNhbGxiYWNrOiAoZ3JvdXA6IFVJRWxlbWVudFtdLFxuICAgICAgICBldmVudDogSUV2ZW50KSA9PiBJVG9vbHRpcERhdGEpOiBFbGVtZW50TWFuYWdlciB7XG4gICAgICAgIHRoaXMuX3pvb21DYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1c2VyIGNhbGxiYWNrIGNhbGxlZCB3aGVuIGEgaG92ZXIgZXZlbnQgaGFwcGVuc1xuICAgICAqXG4gICAgICogQHBhcmFtIHRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0SG92ZXJDYWxsYmFjayhjYWxsYmFjazogKGdyb3VwOiBVSUVsZW1lbnRbXSwgZXZlbnQ6IElFdmVudCkgPT4gdm9pZCk6IEVsZW1lbnRNYW5hZ2VyIHtcbiAgICAgICAgdGhpcy5faG92ZXJDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1c2VyIGNhbGxiYWNrIGNhbGxlZCB3aGVuIGEgaG92ZXIgZXZlbnQgaGFwcGVuc1xuICAgICAqXG4gICAgICogQHBhcmFtIHRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0Q2xpY2tDYWxsYmFjayhjYWxsYmFjazogKGdyb3VwOiBVSUVsZW1lbnRbXSwgZXZlbnQ6IElFdmVudCkgPT4gdm9pZCk6IEVsZW1lbnRNYW5hZ2VyIHtcbiAgICAgICAgdGhpcy5fY2xpY2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1c2VyIGNhbGxiYWNrIGNhbGxlZCB3aGVuIGEgdG9vbHRpcCBpcyBjcmVhdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGhlIGZ1bmN0aW90biB0byBiZSBjYWxsZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0VG9vbHRpcENhbGxiYWNrKGNhbGxiYWNrOiAoZ3JvdXA6IFVJRWxlbWVudFtdLFxuICAgICAgICBldmVudDogSUV2ZW50KSA9PiBJVG9vbHRpcERhdGEpOiBFbGVtZW50TWFuYWdlciB7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXBDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1c2VyIGNhbGxiYWNrIGNhbGxlZCB3aGVuIGEgc2VsZWN0aW9uIGV2ZW50IGhhcHBlbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAgICovXG4gICAgcHVibGljIHNldEJydXNoQ2FsbGJhY2soY2FsbGJhY2s6IChncm91cDogVUlFbGVtZW50W10sIGV2ZW50OiBJRXZlbnQpID0+IHZvaWQpOiBFbGVtZW50TWFuYWdlciB7XG4gICAgICAgIHRoaXMuX2JydXNoQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHRoZSBncm91cCB0aGlzIHRvb2x0aXAgaXMgYXNzb2NpYXRlZCB3aXRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbSAtIHRoZSBlbGVtIHRoYXQgc2hvdWxkIHNob3VsZCBiZSBcImdhbmdlZFwiXG4gICAgICogQHBhcmFtIGdyb3VwTmFtZSAtIE5hbWUgb2YgdGhlIGdyb3VwIHRoYXQgdGhpcyBlbGVtIHNob3VsZCBiZSBcImdhbmdlZFwiXG4gICAgICogICB3aXRoLlxuICAgICAqXG4gICAgICogQHJldHVybiAtIFRoZSBlbGVtIG1hbmFnZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcHVibGljIGFkZFRvVG9vbHRpcEdyb3VwKGVsZW06IFVJRWxlbWVudCwgZ3JvdXBOYW1lOiBzdHJpbmcpOiBFbGVtZW50TWFuYWdlciB7XG4gICAgICAgIGFkZFRvb2x0aXBDYWxsYmFjayhlbGVtKTtcbiAgICAgICAgdGhpcy5yZW1vdmVGcm9tVG9vbHRpcEdyb3VwKGVsZW0pO1xuICAgICAgICB0aGlzLmFkZFRvR3JvdXAoZWxlbSwgZ3JvdXBOYW1lLCBHcm91cFR5cGUuVG9vbHRpcCk7XG5cbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoZWxlbS5vblRvb2x0aXApIHtcbiAgICAgICAgICAgIGxldCBmdW5jID0gZWxlbS5vblRvb2x0aXA7XG4gICAgICAgICAgICBlbGVtLm9uVG9vbHRpcCA9IGZ1bmN0aW9uIChldmVudDogSUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fb25Ub29sdGlwQ2FsbGJhY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgIGZ1bmMoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5vblRvb2x0aXAgPSB0aGlzLl9vblRvb2x0aXBDYWxsYmFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgZWxlbSBmcm9tIHRoZSB0b29sdGlwIGdyb3VwIGl0IGlzIGluXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbSAtIHRoZSBlbGVtIHRoYXQgc2hvdWxkIHNob3VsZCBiZSBcInVuZ2FuZ2VkXCJcbiAgICAgKlxuICAgICAqIEByZXR1cm4gLSBUaGUgZWxlbSBtYW5hZ2VyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHB1YmxpYyByZW1vdmVGcm9tVG9vbHRpcEdyb3VwKGVsZW06IFVJRWxlbWVudCk6IEVsZW1lbnRNYW5hZ2VyIHtcbiAgICAgICAgdGhpcy5yZW1vdmVGcm9tR3JvdXAoZWxlbSwgR3JvdXBUeXBlLlRvb2x0aXApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIHNldCB0aGUgZ3JvdXAgdG8gc3luYyB0aGlzIGVsZW0gd2l0aFxuICAgICpcbiAgICAqIEBwYXJhbSBlbGVtIC0gdGhlIGVsZW0gdGhhdCBzaG91bGQgc2hvdWxkIGJlIFwiZ2FuZ2VkXCJcbiAgICAqIEBwYXJhbSBncm91cE5hbWUgLSBOYW1lIG9mIHRoZSBncm91cCB0aGF0IHRoaXMgZWxlbSBzaG91bGQgYmUgXCJnYW5nZWRcIlxuICAgICogICB3aXRoLlxuICAgICpcbiAgICAqIEByZXR1cm4gLSBUaGUgZWxlbSBtYW5hZ2VyIGluc3RhbmNlLlxuICAgICovXG4gICAgcHVibGljIGFkZFRvRm9jdXNHcm91cChlbGVtOiBVSUVsZW1lbnQsIGdyb3VwTmFtZTogc3RyaW5nKTogRWxlbWVudE1hbmFnZXIge1xuICAgICAgICBhZGRIb3ZlckNhbGxiYWNrKGVsZW0pO1xuICAgICAgICB0aGlzLnJlbW92ZUZyb21Gb2N1c0dyb3VwKGVsZW0pO1xuXG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGVsZW0ub25Ib3Zlcikge1xuICAgICAgICAgICAgbGV0IGZ1bmMgPSBlbGVtLm9uSG92ZXI7XG4gICAgICAgICAgICBlbGVtLm9uSG92ZXIgPSBmdW5jdGlvbiAoZXZlbnQ6IElFdmVudCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX29uSG92ZXJDYWxsYmFjayhldmVudCk7XG4gICAgICAgICAgICAgICAgZnVuYyhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtLm9uSG92ZXIgPSBzZWxmLl9vbkhvdmVyQ2FsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFkZFRvR3JvdXAoZWxlbSwgZ3JvdXBOYW1lLCBHcm91cFR5cGUuRm9jdXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgZWxlbSBmcm9tIHRoZSB6b29tIGdyb3VwIGl0IGlzIGluXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbSAtIHRoZSBlbGVtIHRoYXQgc2hvdWxkIHNob3VsZCBiZSBcInVuZ2FuZ2VkXCJcbiAgICAgKlxuICAgICAqIEByZXR1cm4gLSBUaGUgZWxlbSBtYW5hZ2VyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHB1YmxpYyByZW1vdmVGcm9tRm9jdXNHcm91cChlbGVtOiBVSUVsZW1lbnQpOiBFbGVtZW50TWFuYWdlciB7XG4gICAgICAgIHRoaXMucmVtb3ZlRnJvbUdyb3VwKGVsZW0sIEdyb3VwVHlwZS5Gb2N1cyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICogc2V0IHRoZSBncm91cCB0byBzeW5jIHRoaXMgZWxlbSB3aXRoXG4gICAgKlxuICAgICogQHBhcmFtIGVsZW0gLSB0aGUgZWxlbSB0aGF0IHNob3VsZCBzaG91bGQgYmUgXCJnYW5nZWRcIlxuICAgICogQHBhcmFtIGdyb3VwTmFtZSAtIE5hbWUgb2YgdGhlIGdyb3VwIHRoYXQgdGhpcyBlbGVtIHNob3VsZCBiZSBcImdhbmdlZFwiXG4gICAgKiAgIHdpdGguXG4gICAgKlxuICAgICogQHJldHVybiAtIFRoZSBlbGVtIG1hbmFnZXIgaW5zdGFuY2UuXG4gICAgKi9cbiAgICBwdWJsaWMgYWRkVG9TZWxlY3RHcm91cChlbGVtOiBVSUVsZW1lbnQsIGdyb3VwTmFtZTogc3RyaW5nKTogRWxlbWVudE1hbmFnZXIge1xuICAgICAgICBhZGRDbGlja0NhbGxiYWNrKGVsZW0pO1xuICAgICAgICB0aGlzLnJlbW92ZUZyb21TZWxlY3RHcm91cChlbGVtKTtcblxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChlbGVtLm9uQ2xpY2spIHtcbiAgICAgICAgICAgIGxldCBmdW5jID0gZWxlbS5vbkNsaWNrO1xuICAgICAgICAgICAgZWxlbS5vbkNsaWNrID0gZnVuY3Rpb24gKGV2ZW50OiBJRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9vbkNsaWNrQ2FsbGJhY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgIGZ1bmMoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5vbkNsaWNrID0gc2VsZi5fb25DbGlja0NhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGRUb0dyb3VwKGVsZW0sIGdyb3VwTmFtZSwgR3JvdXBUeXBlLlNlbGVjdCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBlbGVtIGZyb20gdGhlIHpvb20gZ3JvdXAgaXQgaXMgaW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtIC0gdGhlIGVsZW0gdGhhdCBzaG91bGQgc2hvdWxkIGJlIFwidW5nYW5nZWRcIlxuICAgICAqXG4gICAgICogQHJldHVybiAtIFRoZSBlbGVtIG1hbmFnZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcHVibGljIHJlbW92ZUZyb21TZWxlY3RHcm91cChlbGVtOiBVSUVsZW1lbnQpOiBFbGVtZW50TWFuYWdlciB7XG4gICAgICAgIHRoaXMucmVtb3ZlRnJvbUdyb3VwKGVsZW0sIEdyb3VwVHlwZS5TZWxlY3QpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIGdyb3VwIHRvIHN5bmMgdGhpcyBlbGVtIHdpdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtIC0gdGhlIGVsZW0gdGhhdCBzaG91bGQgc2hvdWxkIGJlIFwiZ2FuZ2VkXCJcbiAgICAgKiBAcGFyYW0gZ3JvdXBOYW1lIC0gTmFtZSBvZiB0aGUgZ3JvdXAgdGhhdCB0aGlzIGVsZW0gc2hvdWxkIGJlIFwiZ2FuZ2VkXCJcbiAgICAgKiAgIHdpdGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIC0gVGhlIGVsZW0gbWFuYWdlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkVG9IaWdobGlnaHRHcm91cChlbGVtOiBVSUVsZW1lbnQsIGdyb3VwTmFtZTogc3RyaW5nKTogRWxlbWVudE1hbmFnZXIge1xuICAgICAgICBhZGRIb3ZlckNhbGxiYWNrKGVsZW0pO1xuICAgICAgICB0aGlzLnJlbW92ZUZyb21IaWdobGlnaHRHcm91cChlbGVtKTtcblxuICAgICAgICB0aGlzLmFkZFRvRm9jdXNHcm91cChlbGVtLCBncm91cE5hbWUpO1xuICAgICAgICB0aGlzLmFkZFRvU2VsZWN0R3JvdXAoZWxlbSwgZ3JvdXBOYW1lKTtcblxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChlbGVtLm9uQnJ1c2gpIHtcbiAgICAgICAgICAgIGxldCBmdW5jID0gZWxlbS5vbkJydXNoO1xuICAgICAgICAgICAgZWxlbS5vbkJydXNoID0gZnVuY3Rpb24gKGV2ZW50OiBJRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9vbkJydXNoQ2FsbGJhY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgIGZ1bmMoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5vbkJydXNoID0gc2VsZi5fb25CcnVzaENhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW0ub25DdXJzb3JDaGFuZ2VkKSB7XG4gICAgICAgICAgICBsZXQgZnVuYyA9IGVsZW0ub25DdXJzb3JDaGFuZ2VkO1xuICAgICAgICAgICAgZWxlbS5vbkN1cnNvckNoYW5nZWQgPSBmdW5jdGlvbiAoZXZlbnQ6IElFdmVudCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX29uQ3Vyc29yQ2hhbmdlQ2FsbGJhY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgIGZ1bmMoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5vbkN1cnNvckNoYW5nZWQgPSB0aGlzLl9vbkN1cnNvckNoYW5nZUNhbGxiYWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW0ub25ab29tKSB7XG4gICAgICAgICAgICBsZXQgZnVuYyA9IGVsZW0ub25ab29tO1xuICAgICAgICAgICAgZWxlbS5vblpvb20gPSBmdW5jdGlvbiAoZXZlbnQ6IElFdmVudCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX29uWm9vbUNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBmdW5jKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW0ub25ab29tID0gdGhpcy5fb25ab29tQ2FsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZWxlbXMgPSB0aGlzLl9ncm91cEluZm9bR3JvdXBUeXBlLkhpZ2hsaWdodF0uX25hbWVNYXBbZ3JvdXBOYW1lXTtcbiAgICAgICAgaWYgKGVsZW1zICYmIGVsZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG9sZEVsZW0gPSBlbGVtc1swXTtcbiAgICAgICAgICAgIGlmIChvbGRFbGVtLmFwaS5nZXRPcHRpb25zICYmIGVsZW0uYXBpICYmIGVsZW0uYXBpLnpvb20pIHtcbiAgICAgICAgICAgICAgICBsZXQgb3B0aW9uczogSU9wdGlvbnMgPSBvbGRFbGVtLmFwaS5nZXRPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgbGV0IHpvb21FdmVudDogSUV2ZW50ID0gY29weShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB6b29tRXZlbnQuZXZlbnQgPSBFdmVudFR5cGUuWm9vbTtcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLmFwaS56b29tKHpvb21FdmVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRUb0dyb3VwKGVsZW0sIGdyb3VwTmFtZSwgR3JvdXBUeXBlLkhpZ2hsaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBlbGVtIGZyb20gdGhlIHpvb20gZ3JvdXAgaXQgaXMgaW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtIC0gdGhlIGVsZW0gdGhhdCBzaG91bGQgc2hvdWxkIGJlIFwidW5nYW5nZWRcIlxuICAgICAqXG4gICAgICogQHJldHVybiAtIFRoZSBlbGVtIG1hbmFnZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcHVibGljIHJlbW92ZUZyb21IaWdobGlnaHRHcm91cChlbGVtOiBVSUVsZW1lbnQpOiBFbGVtZW50TWFuYWdlciB7XG4gICAgICAgIHRoaXMucmVtb3ZlRnJvbUZvY3VzR3JvdXAoZWxlbSk7XG4gICAgICAgIHRoaXMucmVtb3ZlRnJvbVNlbGVjdEdyb3VwKGVsZW0pO1xuICAgICAgICB0aGlzLnJlbW92ZUZyb21Hcm91cChlbGVtLCBHcm91cFR5cGUuSGlnaGxpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHRoZSBncm91cCB0byBzZWxlY3QgdGhpcyBlbGVtIHdpdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtIC0gdGhlIGVsZW0gdGhhdCBzaG91bGQgc2hvdWxkIGJlIFwiZ2FuZ2VkXCJcbiAgICAgKiBAcGFyYW0gZ3JvdXBOYW1lIC0gTmFtZSBvZiB0aGUgZ3JvdXAgdGhhdCB0aGlzIGVsZW0gc2hvdWxkIGJlIFwiZ2FuZ2VkXCJcbiAgICAgKiAgIHdpdGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIC0gVGhlIGVsZW0gbWFuYWdlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkVG9SZW5kZXJHcm91cChlbGVtOiBVSUVsZW1lbnQsIGdyb3VwTmFtZTogc3RyaW5nKTogRWxlbWVudE1hbmFnZXIge1xuICAgICAgICBhZGRSZW5kZXJDYWxsYmFjayhlbGVtKTtcbiAgICAgICAgdGhpcy5yZW1vdmVGcm9tUmVuZGVyR3JvdXAoZWxlbSk7XG4gICAgICAgIHRoaXMuYWRkVG9Hcm91cChlbGVtLCBncm91cE5hbWUsIEdyb3VwVHlwZS5SZW5kZXIpO1xuXG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGVsZW0uaGFuZGxlVXBkYXRlKSB7XG4gICAgICAgICAgICBsZXQgZnVuYyA9IGVsZW0uaGFuZGxlVXBkYXRlO1xuICAgICAgICAgICAgZWxlbS5oYW5kbGVVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGVyOiBVSUVsZW1lbnQsIG9wdGlvbnM6IElPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fb25VcGRhdGVDYWxsYmFjayhjYWxsZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGZ1bmMoY2FsbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW0uaGFuZGxlVXBkYXRlID0gdGhpcy5fb25VcGRhdGVDYWxsYmFja1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBlbGVtIGZyb20gdGhlIHpvb20gZ3JvdXAgaXQgaXMgaW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtIC0gdGhlIGVsZW0gdGhhdCBzaG91bGQgc2hvdWxkIGJlIFwidW5nYW5nZWRcIlxuICAgICAqXG4gICAgICogQHJldHVybiAtIFRoZSBlbGVtIG1hbmFnZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcHVibGljIHJlbW92ZUZyb21SZW5kZXJHcm91cChlbGVtOiBVSUVsZW1lbnQpOiBFbGVtZW50TWFuYWdlciB7XG4gICAgICAgIHRoaXMucmVtb3ZlRnJvbUdyb3VwKGVsZW0sIEdyb3VwVHlwZS5SZW5kZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKiogY2xlYXIgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGlzIGxpc3QgKi9cbiAgICBwdWJsaWMgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX2VsZW1zLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2dyb3VwSW5mby5sZW5ndGggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEdyb3VwVHlwZS5Ob25lOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwSW5mby5wdXNoKG5ldyBHcm91cEluZm8oKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUtBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BOztBQUVBO0FBQ0E7QUFzQkE7QUFyQkE7QUFDQTtBQXFCQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoaEJBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/element-manager.ts\n");

/***/ }),

/***/ "./src/core/utilities.ts":
/*!*******************************!*\
  !*** ./src/core/utilities.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getSelectionName(className) {\n    if (typeof (className) === 'number') {\n        return 'n' + className;\n    }\n    if (!className) {\n        return '';\n    }\n    if (className.length > 0 && !isNaN(Number(className[0]))) {\n        className = 'z' + className;\n    }\n    className = className.replace(/[\\*\\%\\#\\[\\]\\/\\>\\<\\s\\+\\(\\)\\;\\@\\:\\?\\\"=.,]/g, '-');\n    return className;\n}\nexports.getSelectionName = getSelectionName;\nfunction removeFromList(value, arr) {\n    if (value) {\n        let index = arr.indexOf(value);\n        if (index !== -1) {\n            arr.splice(index, 1);\n        }\n    }\n}\nexports.removeFromList = removeFromList;\n/** taken from d3-array */\nfunction ascending(a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n/** taken from d3-array */\nfunction ascendingComparator(f) {\n    return function (d, x) {\n        return ascending(f(d), x);\n    };\n}\n/** modified from d3-array */\nfunction bisect(compare) {\n    if (!compare)\n        compare = ascending;\n    if (compare.length === 1)\n        compare = ascendingComparator(compare);\n    return {\n        left: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length;\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a[mid], x) < 0)\n                    lo = mid + 1;\n                else\n                    hi = mid;\n            }\n            return lo;\n        },\n        right: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length;\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a[mid], x) > 0)\n                    hi = mid;\n                else\n                    lo = mid + 1;\n            }\n            return lo;\n        }\n    };\n}\nexports.bisect = bisect;\n/** puts all raw data into buckets based on thresholds and values */\nfunction bucketData(values, thresholds, accessor) {\n    let findRight = bisect().right;\n    let buckets = [];\n    // need one less bucket than thresholds\n    for (let i = 0; i < thresholds.length - 1; ++i) {\n        buckets[i] = [];\n    }\n    let min = thresholds[0];\n    let max = thresholds[thresholds.length - 1];\n    let usedThresholds = thresholds.slice(1);\n    for (let i = 0; i < values.length; ++i) {\n        let compareValue = accessor(values[i]);\n        if (compareValue < min || compareValue > max) {\n            continue;\n        }\n        let valueIdx = findRight(usedThresholds, compareValue);\n        buckets[valueIdx].push(values[i]);\n    }\n    // name the return buckets\n    let ret = {};\n    for (let i = 0; i < thresholds.length - 1; ++i) {\n        let bucketName = thresholds[i] + '-' + thresholds[i + 1];\n        ret[bucketName] = buckets[i];\n    }\n    return ret;\n}\nexports.bucketData = bucketData;\nfunction copy(obj) {\n    let ret = {};\n    for (let key in obj) {\n        ret[key] = obj[key];\n    }\n    return ret;\n}\nexports.copy = copy;\nfunction merge(obj1, obj2) {\n    for (let key in obj2) {\n        obj1[key] = obj2[key];\n    }\n}\nexports.merge = merge;\nfunction convertTraceToTrees(input) {\n    let roots = [];\n    let stack = []; // used to represent the current stack state\n    let nodeStack = []; // used to represent the current stack state\n    for (let i = 0; i < input.length; i++) {\n        let value = input[i];\n        let parent = stack[stack.length - 1];\n        // pop stuff off the stack\n        while (stack.length && value.x > parent.x + parent.dx) {\n            --stack.length;\n            --nodeStack.length;\n            parent = stack[stack.length - 1];\n        }\n        let parentNode = nodeStack[nodeStack.length - 1];\n        let node = {\n            key: value.key,\n            value: value.dx,\n            children: [],\n            parent: parentNode\n        };\n        if (value.name) {\n            node.name = value.name;\n        }\n        if (parentNode) {\n            parentNode.children.push(node);\n        }\n        else {\n            roots.push(node);\n        }\n        stack.push(value);\n        nodeStack.push(node);\n    }\n    return roots;\n}\nexports.convertTraceToTrees = convertTraceToTrees;\nclass SimpleBuffer {\n    constructor(data) {\n        if (data) {\n            this._data = data;\n        }\n        else {\n            this._data = [];\n        }\n    }\n    push(d) {\n        this._data.push(d);\n    }\n    get(index) {\n        return this._data[index];\n    }\n    length() {\n        return this._data.length;\n    }\n    getData() {\n        return this._data;\n    }\n}\nexports.SimpleBuffer = SimpleBuffer;\nclass RingBuffer {\n    constructor(size) {\n        this._data = new Array(size);\n        this._startIdx = 0;\n        this._count = 0;\n        this._isRotating = false;\n    }\n    /** add a new value to the buffer */\n    push(d) {\n        if (this._isRotating) {\n            // the buffer is rotating\n            this._data[this._startIdx] = d;\n            ++this._startIdx;\n            if (this._startIdx === this._count) {\n                this._startIdx = 0;\n            }\n            this._isRotating = true;\n        }\n        else if (this._count === this._data.length - 1) {\n            // here the buffer will start rotating as the buffer is full\n            this._data[this._count] = d;\n            ++this._count;\n            this._isRotating = true;\n        }\n        else {\n            // here the buffer has not been filled yet\n            this._data[this._count] = d;\n            ++this._count;\n        }\n    }\n    /** return the value offset index from the start index\n     * @param index the offset from the start of the buffer\n     */\n    get(index) {\n        if (this._isRotating) {\n            // the buffer is rotating\n            index = index + this._startIdx;\n            if (index >= this._count) {\n                index = index - this._count;\n            }\n        }\n        return this._data[index];\n    }\n    /** get the number of items in the buffer */\n    length() {\n        return this._count;\n    }\n    getData() {\n        if (this._isRotating) {\n            // the buffer is rotating\n            let ret = [];\n            for (let i = this._startIdx; i < this._data.length; ++i) {\n                ret.push(this._data[i]);\n            }\n            for (let i = 0; i < this._startIdx; ++i) {\n                ret.push(this._data[i]);\n            }\n            return ret;\n        }\n        return this._data;\n    }\n}\nexports.RingBuffer = RingBuffer;\nfunction bisectBuffer(compare) {\n    if (!compare)\n        compare = ascending;\n    if (compare.length === 1)\n        compare = ascendingComparator(compare);\n    return {\n        left: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length();\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a.get(mid), x) < 0)\n                    lo = mid + 1;\n                else\n                    hi = mid;\n            }\n            return lo;\n        },\n        right: function (a, x, lo, hi) {\n            if (lo == null)\n                lo = 0;\n            if (hi == null)\n                hi = a.length();\n            while (lo < hi) {\n                var mid = lo + hi >>> 1;\n                if (compare(a.get(mid), x) > 0)\n                    hi = mid;\n                else\n                    lo = mid + 1;\n            }\n            return lo;\n        }\n    };\n}\nexports.bisectBuffer = bisectBuffer;\nfunction transposeKeys(data) {\n    // this is used to map the keys to their indicies in the output summary data\n    let keyIdxMapping = {};\n    function transposeHelper(output, parentKeys, value, level) {\n        let myKeys = [];\n        for (let i = 0; i < parentKeys.length; ++i) {\n            myKeys[i] = parentKeys[i];\n        }\n        myKeys.push(value.key);\n        if (Array.isArray(value.data)) {\n            for (let i = 0; i < value.data.length; ++i) {\n                transposeHelper(output, myKeys, value.data[i], level + 1);\n            }\n        }\n        else {\n            let currSummaryArray = output;\n            for (let keyIdx = myKeys.length - 1; keyIdx >= 0; --keyIdx) {\n                let key = myKeys[keyIdx];\n                let dataIdx;\n                if (!keyIdxMapping.hasOwnProperty(key)) {\n                    dataIdx = currSummaryArray.length;\n                    keyIdxMapping[key] = dataIdx;\n                }\n                else {\n                    dataIdx = keyIdxMapping[key];\n                }\n                // create the summary data if it doesn't exist yet\n                if (!currSummaryArray[dataIdx]) {\n                    currSummaryArray[dataIdx] = { key: key, data: [] };\n                }\n                // if we are the leaf add the data, else just move to the next level\n                if (keyIdx === 0) {\n                    currSummaryArray[dataIdx].data = value.data;\n                }\n                else {\n                    currSummaryArray = currSummaryArray[dataIdx].data;\n                }\n            }\n        }\n    }\n    let output = [];\n    for (let i = 0; i < data.length; ++i) {\n        transposeHelper(output, [], data[i], 0);\n    }\n    return output;\n}\nexports.transposeKeys = transposeKeys;\nfunction runFunctionOnLeaf(node, func) {\n    if (node && node.children && node.children.length > 0) {\n        for (let i = 0; i < node.children.length; ++i) {\n            runFunctionOnLeaf(node.children[i], func);\n        }\n    }\n    else {\n        func(node);\n    }\n}\nexports.runFunctionOnLeaf = runFunctionOnLeaf;\nfunction isOverlapping(rect1, rect2) {\n    return rect1.x <= rect2.right && rect1.right >= rect2.x &&\n        rect1.y <= rect2.bottom && rect1.bottom >= rect2.y;\n}\nexports.isOverlapping = isOverlapping;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS91dGlsaXRpZXMudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9VV1QvLi9zcmMvY29yZS91dGlsaXRpZXMudHM/NmNhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJVHJlZU5vZGUsIElUcmFjZVZhbHVlLCBJU3VtbWFyeVZhbHVlIH0gZnJvbSAnLi4vaW50ZXJmYWNlL2NoYXJ0L3Nlcmllcy1kYXRhJztcbmltcG9ydCB7IElCdWZmZXIsIElDaGVja2JveFRyZWVOb2RlLCBJUmVjdCB9IGZyb20gJy4uL2ludGVyZmFjZS91aS1iYXNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdGlvbk5hbWUoY2xhc3NOYW1lOiBzdHJpbmcpIHtcbiAgICBpZiAodHlwZW9mIChjbGFzc05hbWUpID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gJ24nICsgY2xhc3NOYW1lO1xuICAgIH1cbiAgICBpZiAoIWNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGlmIChjbGFzc05hbWUubGVuZ3RoID4gMCAmJiAhaXNOYU4oTnVtYmVyKGNsYXNzTmFtZVswXSkpKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9ICd6JyArIGNsYXNzTmFtZTtcbiAgICB9XG4gICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lLnJlcGxhY2UoL1tcXCpcXCVcXCNcXFtcXF1cXC9cXD5cXDxcXHNcXCtcXChcXClcXDtcXEBcXDpcXD9cXFwiPS4sXS9nLCAnLScpO1xuICAgIHJldHVybiBjbGFzc05hbWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVGcm9tTGlzdCh2YWx1ZTogYW55LCBhcnI6IGFueVtdKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGxldCBpbmRleCA9IGFyci5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgYXJyLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKiB0YWtlbiBmcm9tIGQzLWFycmF5ICovXG5mdW5jdGlvbiBhc2NlbmRpbmcoYTogYW55LCBiOiBhbnkpOiBudW1iZXIge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbn1cblxuLyoqIHRha2VuIGZyb20gZDMtYXJyYXkgKi9cbmZ1bmN0aW9uIGFzY2VuZGluZ0NvbXBhcmF0b3IoZjogKGQ6IGFueSkgPT4gbnVtYmVyKTogKGE6IGFueSwgYjogYW55KSA9PiBudW1iZXIge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZDogYW55LCB4OiBhbnkpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gYXNjZW5kaW5nKGYoZCksIHgpO1xuICAgIH07XG59XG5cbi8qKiBtb2RpZmllZCBmcm9tIGQzLWFycmF5ICovXG5leHBvcnQgZnVuY3Rpb24gYmlzZWN0KGNvbXBhcmU/OiBhbnkpOiBhbnkge1xuICAgIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcbiAgICBpZiAoY29tcGFyZS5sZW5ndGggPT09IDEpIGNvbXBhcmUgPSBhc2NlbmRpbmdDb21wYXJhdG9yKGNvbXBhcmUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGZ1bmN0aW9uIChhOiBhbnlbXSwgeDogYW55LCBsbzogbnVtYmVyLCBoaTogbnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgICAgICAgICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPCAwKSBsbyA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsbztcbiAgICAgICAgfSxcbiAgICAgICAgcmlnaHQ6IGZ1bmN0aW9uIChhOiBhbnlbXSwgeDogbnVtYmVyLCBsbzogbnVtYmVyLCBoaTogbnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAobG8gPT0gbnVsbCkgbG8gPSAwO1xuICAgICAgICAgICAgaWYgKGhpID09IG51bGwpIGhpID0gYS5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPiAwKSBoaSA9IG1pZDtcbiAgICAgICAgICAgICAgICBlbHNlIGxvID0gbWlkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsbztcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8qKiBwdXRzIGFsbCByYXcgZGF0YSBpbnRvIGJ1Y2tldHMgYmFzZWQgb24gdGhyZXNob2xkcyBhbmQgdmFsdWVzICovXG5leHBvcnQgZnVuY3Rpb24gYnVja2V0RGF0YSh2YWx1ZXM6IGFueVtdLCB0aHJlc2hvbGRzOiBudW1iZXJbXSxcbiAgICBhY2Nlc3NvcjogKGQ6IGFueSkgPT4gbnVtYmVyKTogeyBbaW5kZXg6IHN0cmluZ106IGFueVtdIH0ge1xuXG4gICAgbGV0IGZpbmRSaWdodCA9IGJpc2VjdCgpLnJpZ2h0O1xuXG4gICAgbGV0IGJ1Y2tldHM6IGFueVtdW10gPSBbXTtcbiAgICAvLyBuZWVkIG9uZSBsZXNzIGJ1Y2tldCB0aGFuIHRocmVzaG9sZHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRocmVzaG9sZHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGJ1Y2tldHNbaV0gPSBbXTtcbiAgICB9XG5cbiAgICBsZXQgbWluID0gdGhyZXNob2xkc1swXTtcbiAgICBsZXQgbWF4ID0gdGhyZXNob2xkc1t0aHJlc2hvbGRzLmxlbmd0aCAtIDFdO1xuXG4gICAgbGV0IHVzZWRUaHJlc2hvbGRzID0gdGhyZXNob2xkcy5zbGljZSgxKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBsZXQgY29tcGFyZVZhbHVlID0gYWNjZXNzb3IodmFsdWVzW2ldKTtcbiAgICAgICAgaWYgKGNvbXBhcmVWYWx1ZSA8IG1pbiB8fCBjb21wYXJlVmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHZhbHVlSWR4ID0gZmluZFJpZ2h0KHVzZWRUaHJlc2hvbGRzLCBjb21wYXJlVmFsdWUpO1xuICAgICAgICBidWNrZXRzW3ZhbHVlSWR4XS5wdXNoKHZhbHVlc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gbmFtZSB0aGUgcmV0dXJuIGJ1Y2tldHNcbiAgICBsZXQgcmV0OiB7IFtpbmRleDogc3RyaW5nXTogYW55W10gfSA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhyZXNob2xkcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgbGV0IGJ1Y2tldE5hbWU6IHN0cmluZyA9IHRocmVzaG9sZHNbaV0gKyAnLScgKyB0aHJlc2hvbGRzW2kgKyAxXTtcbiAgICAgICAgcmV0W2J1Y2tldE5hbWVdID0gYnVja2V0c1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29weShvYmo6IGFueSk6IE9iamVjdCB7XG4gICAgbGV0IHJldDogYW55ID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgICAgICByZXRba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlKG9iajE6IGFueSwgb2JqMjogYW55KTogdm9pZCB7XG4gICAgZm9yIChsZXQga2V5IGluIG9iajIpIHtcbiAgICAgICAgb2JqMVtrZXldID0gb2JqMltrZXldO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUcmFjZVRvVHJlZXMoaW5wdXQ6IElUcmFjZVZhbHVlW10pOiBJVHJlZU5vZGVbXSB7XG4gICAgbGV0IHJvb3RzOiBJVHJlZU5vZGVbXSA9IFtdO1xuXG4gICAgbGV0IHN0YWNrOiBJVHJhY2VWYWx1ZVtdID0gW107IC8vIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBjdXJyZW50IHN0YWNrIHN0YXRlXG4gICAgbGV0IG5vZGVTdGFjazogSVRyZWVOb2RlW10gPSBbXTsgLy8gdXNlZCB0byByZXByZXNlbnQgdGhlIGN1cnJlbnQgc3RhY2sgc3RhdGVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgICBsZXQgcGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgICAgLy8gcG9wIHN0dWZmIG9mZiB0aGUgc3RhY2tcbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCAmJiB2YWx1ZS54ID4gcGFyZW50LnggKyBwYXJlbnQuZHgpIHtcbiAgICAgICAgICAgIC0tc3RhY2subGVuZ3RoO1xuICAgICAgICAgICAgLS1ub2RlU3RhY2subGVuZ3RoO1xuICAgICAgICAgICAgcGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcGFyZW50Tm9kZSA9IG5vZGVTdGFja1tub2RlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBub2RlOiBJVHJlZU5vZGUgPSB7XG4gICAgICAgICAgICBrZXk6IHZhbHVlLmtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5keCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50Tm9kZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh2YWx1ZS5uYW1lKSB7XG4gICAgICAgICAgICBub2RlLm5hbWUgPSB2YWx1ZS5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvb3RzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgbm9kZVN0YWNrLnB1c2gobm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3RzO1xufVxuXG5leHBvcnQgY2xhc3MgU2ltcGxlQnVmZmVyPERhdGFUeXBlPiBpbXBsZW1lbnRzIElCdWZmZXI8RGF0YVR5cGU+IHtcbiAgICBwcml2YXRlIF9kYXRhOiBEYXRhVHlwZVtdO1xuXG4gICAgY29uc3RydWN0b3IoZGF0YT86IERhdGFUeXBlW10pIHtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIHB1c2goZDogRGF0YVR5cGUpIHtcbiAgICAgICAgdGhpcy5fZGF0YS5wdXNoKGQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQoaW5kZXg6IG51bWJlcik6IERhdGFUeXBlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbaW5kZXhdO1xuICAgIH1cblxuICAgIHB1YmxpYyBsZW5ndGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEubGVuZ3RoO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXREYXRhKCk6IERhdGFUeXBlW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSaW5nQnVmZmVyPERhdGFUeXBlPiBpbXBsZW1lbnRzIElCdWZmZXI8RGF0YVR5cGU+IHtcbiAgICBwcml2YXRlIF9kYXRhOiBEYXRhVHlwZVtdO1xuICAgIHByaXZhdGUgX3N0YXJ0SWR4OiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfY291bnQ6IG51bWJlcjtcbiAgICBwcml2YXRlIF9pc1JvdGF0aW5nOiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3Ioc2l6ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICAgIHRoaXMuX3N0YXJ0SWR4ID0gMDtcbiAgICAgICAgdGhpcy5fY291bnQgPSAwO1xuICAgICAgICB0aGlzLl9pc1JvdGF0aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqIGFkZCBhIG5ldyB2YWx1ZSB0byB0aGUgYnVmZmVyICovXG4gICAgcHVibGljIHB1c2goZDogRGF0YVR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUm90YXRpbmcpIHtcbiAgICAgICAgICAgIC8vIHRoZSBidWZmZXIgaXMgcm90YXRpbmdcbiAgICAgICAgICAgIHRoaXMuX2RhdGFbdGhpcy5fc3RhcnRJZHhdID0gZDtcbiAgICAgICAgICAgICsrdGhpcy5fc3RhcnRJZHg7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGFydElkeCA9PT0gdGhpcy5fY291bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydElkeCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2lzUm90YXRpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2NvdW50ID09PSB0aGlzLl9kYXRhLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIC8vIGhlcmUgdGhlIGJ1ZmZlciB3aWxsIHN0YXJ0IHJvdGF0aW5nIGFzIHRoZSBidWZmZXIgaXMgZnVsbFxuICAgICAgICAgICAgdGhpcy5fZGF0YVt0aGlzLl9jb3VudF0gPSBkO1xuICAgICAgICAgICAgKyt0aGlzLl9jb3VudDtcbiAgICAgICAgICAgIHRoaXMuX2lzUm90YXRpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGVyZSB0aGUgYnVmZmVyIGhhcyBub3QgYmVlbiBmaWxsZWQgeWV0XG4gICAgICAgICAgICB0aGlzLl9kYXRhW3RoaXMuX2NvdW50XSA9IGQ7XG4gICAgICAgICAgICArK3RoaXMuX2NvdW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIHJldHVybiB0aGUgdmFsdWUgb2Zmc2V0IGluZGV4IGZyb20gdGhlIHN0YXJ0IGluZGV4XG4gICAgICogQHBhcmFtIGluZGV4IHRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIGJ1ZmZlclxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQoaW5kZXg6IG51bWJlcik6IERhdGFUeXBlIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUm90YXRpbmcpIHtcbiAgICAgICAgICAgIC8vIHRoZSBidWZmZXIgaXMgcm90YXRpbmdcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyB0aGlzLl9zdGFydElkeDtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLl9jb3VudCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXggLSB0aGlzLl9jb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtpbmRleF07XG4gICAgfVxuXG4gICAgLyoqIGdldCB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBidWZmZXIgKi9cbiAgICBwdWJsaWMgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY291bnQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldERhdGEoKTogRGF0YVR5cGVbXSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1JvdGF0aW5nKSB7XG4gICAgICAgICAgICAvLyB0aGUgYnVmZmVyIGlzIHJvdGF0aW5nXG4gICAgICAgICAgICBsZXQgcmV0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fc3RhcnRJZHg7IGkgPCB0aGlzLl9kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2godGhpcy5fZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3N0YXJ0SWR4OyArK2kpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaCh0aGlzLl9kYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmlzZWN0QnVmZmVyKGNvbXBhcmU/OiBhbnkpOiBhbnkge1xuICAgIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcbiAgICBpZiAoY29tcGFyZS5sZW5ndGggPT09IDEpIGNvbXBhcmUgPSBhc2NlbmRpbmdDb21wYXJhdG9yKGNvbXBhcmUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGZ1bmN0aW9uIChhOiBJQnVmZmVyPGFueT4sIHg6IGFueSwgbG86IG51bWJlciwgaGk6IG51bWJlcikge1xuICAgICAgICAgICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICAgICAgICAgIGlmIChoaSA9PSBudWxsKSBoaSA9IGEubGVuZ3RoKCk7XG4gICAgICAgICAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgICAgICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGEuZ2V0KG1pZCksIHgpIDwgMCkgbG8gPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaGkgPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG87XG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0OiBmdW5jdGlvbiAoYTogSUJ1ZmZlcjxhbnk+LCB4OiBudW1iZXIsIGxvOiBudW1iZXIsIGhpOiBudW1iZXIpIHtcbiAgICAgICAgICAgIGlmIChsbyA9PSBudWxsKSBsbyA9IDA7XG4gICAgICAgICAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aCgpO1xuICAgICAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShhLmdldChtaWQpLCB4KSA+IDApIGhpID0gbWlkO1xuICAgICAgICAgICAgICAgIGVsc2UgbG8gPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlS2V5cyhkYXRhOiBJU3VtbWFyeVZhbHVlW10pOiBJU3VtbWFyeVZhbHVlW10ge1xuXG4gICAgLy8gdGhpcyBpcyB1c2VkIHRvIG1hcCB0aGUga2V5cyB0byB0aGVpciBpbmRpY2llcyBpbiB0aGUgb3V0cHV0IHN1bW1hcnkgZGF0YVxuICAgIGxldCBrZXlJZHhNYXBwaW5nOiB7IFtpbmRleDogc3RyaW5nXTogbnVtYmVyIH0gPSB7fTtcblxuICAgIGZ1bmN0aW9uIHRyYW5zcG9zZUhlbHBlcihvdXRwdXQ6IElTdW1tYXJ5VmFsdWVbXSwgcGFyZW50S2V5czogc3RyaW5nW10sXG4gICAgICAgIHZhbHVlOiBJU3VtbWFyeVZhbHVlLCBsZXZlbDogbnVtYmVyKSB7XG5cbiAgICAgICAgbGV0IG15S2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudEtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG15S2V5c1tpXSA9IHBhcmVudEtleXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgbXlLZXlzLnB1c2godmFsdWUua2V5KTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZS5kYXRhKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3NlSGVscGVyKG91dHB1dCwgbXlLZXlzLCB2YWx1ZS5kYXRhW2ldLCBsZXZlbCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGN1cnJTdW1tYXJ5QXJyYXkgPSBvdXRwdXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXlJZHggPSBteUtleXMubGVuZ3RoIC0gMTsga2V5SWR4ID49IDA7IC0ta2V5SWR4KSB7XG4gICAgICAgICAgICAgICAgbGV0IGtleSA9IG15S2V5c1trZXlJZHhdO1xuICAgICAgICAgICAgICAgIGxldCBkYXRhSWR4OiBudW1iZXI7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXlJZHhNYXBwaW5nLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUlkeCA9IGN1cnJTdW1tYXJ5QXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBrZXlJZHhNYXBwaW5nW2tleV0gPSBkYXRhSWR4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFJZHggPSBrZXlJZHhNYXBwaW5nW2tleV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBzdW1tYXJ5IGRhdGEgaWYgaXQgZG9lc24ndCBleGlzdCB5ZXRcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJTdW1tYXJ5QXJyYXlbZGF0YUlkeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyclN1bW1hcnlBcnJheVtkYXRhSWR4XSA9IHsga2V5OiBrZXksIGRhdGE6IFtdIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIHRoZSBsZWFmIGFkZCB0aGUgZGF0YSwgZWxzZSBqdXN0IG1vdmUgdG8gdGhlIG5leHQgbGV2ZWxcbiAgICAgICAgICAgICAgICBpZiAoa2V5SWR4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJTdW1tYXJ5QXJyYXlbZGF0YUlkeF0uZGF0YSA9IHZhbHVlLmRhdGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyclN1bW1hcnlBcnJheSA9IGN1cnJTdW1tYXJ5QXJyYXlbZGF0YUlkeF0uZGF0YSBhcyBJU3VtbWFyeVZhbHVlW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG91dHB1dDogSVN1bW1hcnlWYWx1ZVtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRyYW5zcG9zZUhlbHBlcihvdXRwdXQsIFtdLCBkYXRhW2ldLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bkZ1bmN0aW9uT25MZWFmKG5vZGU6IElDaGVja2JveFRyZWVOb2RlLFxuICAgIGZ1bmM6IChsZWFmTm9kZTogSUNoZWNrYm94VHJlZU5vZGUpID0+IHZvaWRcbikge1xuICAgIGlmIChub2RlICYmIG5vZGUuY2hpbGRyZW4gJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcnVuRnVuY3Rpb25PbkxlYWYobm9kZS5jaGlsZHJlbltpXSwgZnVuYyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmdW5jKG5vZGUpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT3ZlcmxhcHBpbmcocmVjdDE6IElSZWN0LCByZWN0MjogSVJlY3QpIHtcbiAgICByZXR1cm4gcmVjdDEueCA8PSByZWN0Mi5yaWdodCAmJiByZWN0MS5yaWdodCA+PSByZWN0Mi54ICYmXG4gICAgICAgIHJlY3QxLnkgPD0gcmVjdDIuYm90dG9tICYmIHJlY3QxLmJvdHRvbSA+PSByZWN0Mi55O1xufVxuIl0sIm1hcHBpbmdzIjoiOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpCQTtBQTJCQTtBQUNBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFqQ0E7QUFtQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBdkNBO0FBeUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBO0FBNEJBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRFQTtBQXdFQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekJBO0FBNEJBO0FBRUE7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbERBO0FBb0RBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUhBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/utilities.ts\n");

/***/ }),

/***/ "./src/core/web-utilities.ts":
/*!***********************************!*\
  !*** ./src/core/web-utilities.ts ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst es6_promise_1 = __webpack_require__(/*! es6-promise */ \"es6-promise\");\n/**\n* detect IE\n* returns version of IE or false, if browser is not Internet Explorer\n*/\n// from https://codepen.io/gapcode/pen/vEJNZN\nfunction detectIE() {\n    let ua = window.navigator.userAgent;\n    // Test values; Uncomment to check result \n    // IE 10\n    // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n    // IE 11\n    // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n    // Edge 12 (Spartan)\n    // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n    // Edge 13\n    // ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586';\n    let msie = ua.indexOf('MSIE ');\n    if (msie > 0) {\n        es6_promise_1.polyfill();\n        if (!String.prototype.startsWith) {\n            String.prototype.startsWith = function (searchString, position) {\n                position = position || 0;\n                return this.substr(position, searchString.length) === searchString;\n            };\n        }\n        // IE 10 or older => return version number\n        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n    }\n    let trident = ua.indexOf('Trident/');\n    if (trident > 0) {\n        es6_promise_1.polyfill();\n        if (!String.prototype.startsWith) {\n            String.prototype.startsWith = function (searchString, position) {\n                position = position || 0;\n                return this.substr(position, searchString.length) === searchString;\n            };\n        }\n        // IE 11 => return version number\n        let rv = ua.indexOf('rv:');\n        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n    }\n    let edge = ua.indexOf('Edge/');\n    if (edge > 0) {\n        // Edge (IE 12+) => return version number\n        return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n    }\n    // other browser\n    return false;\n}\nexports.detectIE = detectIE;\ndocument.addEventListener('DOMContentLoaded', function () {\n    0;\n    detectIE();\n}, false);\n// from https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/MouseEvent\n// polyfill for old version of IE\nfunction useIEPolyfill(window) {\n    try {\n        new CustomEvent('test'); // No need to polyfill\n    }\n    catch (e) {\n        // Polyfills DOM4 CustomEvent\n        let MouseEvent = function (eventType, params) {\n            params = params || { bubbles: false, cancelable: false };\n            var mouseEvent = document.createEvent('MouseEvent');\n            mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n            return mouseEvent;\n        };\n        MouseEvent.prototype = Event.prototype;\n        window.MouseEvent = MouseEvent;\n    }\n}\nexports.useIEPolyfill = useIEPolyfill;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS93ZWItdXRpbGl0aWVzLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVVdULy4vc3JjL2NvcmUvd2ViLXV0aWxpdGllcy50cz9jYzRiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBvbHlmaWxsIH0gZnJvbSAnZXM2LXByb21pc2UnO1xuXG4vKipcbiogZGV0ZWN0IElFXG4qIHJldHVybnMgdmVyc2lvbiBvZiBJRSBvciBmYWxzZSwgaWYgYnJvd3NlciBpcyBub3QgSW50ZXJuZXQgRXhwbG9yZXJcbiovXG4vLyBmcm9tIGh0dHBzOi8vY29kZXBlbi5pby9nYXBjb2RlL3Blbi92RUpOWk5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RJRSgpIHtcbiAgICBsZXQgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICAgIC8vIFRlc3QgdmFsdWVzOyBVbmNvbW1lbnQgdG8gY2hlY2sgcmVzdWx0IOKAplxuXG4gICAgLy8gSUUgMTBcbiAgICAvLyB1YSA9ICdNb3ppbGxhLzUuMCAoY29tcGF0aWJsZTsgTVNJRSAxMC4wOyBXaW5kb3dzIE5UIDYuMjsgVHJpZGVudC82LjApJztcblxuICAgIC8vIElFIDExXG4gICAgLy8gdWEgPSAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgNi4zOyBUcmlkZW50LzcuMDsgcnY6MTEuMCkgbGlrZSBHZWNrbyc7XG5cbiAgICAvLyBFZGdlIDEyIChTcGFydGFuKVxuICAgIC8vIHVhID0gJ01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDEwLjA7IFdPVzY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvMzkuMC4yMTcxLjcxIFNhZmFyaS81MzcuMzYgRWRnZS8xMi4wJztcblxuICAgIC8vIEVkZ2UgMTNcbiAgICAvLyB1YSA9ICdNb3ppbGxhLzUuMCAoV2luZG93cyBOVCAxMC4wOyBXaW42NDsgeDY0KSBBcHBsZVdlYktpdC81MzcuMzYgKEtIVE1MLCBsaWtlIEdlY2tvKSBDaHJvbWUvNDYuMC4yNDg2LjAgU2FmYXJpLzUzNy4zNiBFZGdlLzEzLjEwNTg2JztcbiAgICBsZXQgbXNpZSA9IHVhLmluZGV4T2YoJ01TSUUgJyk7XG4gICAgaWYgKG1zaWUgPiAwKSB7XG4gICAgICAgIHBvbHlmaWxsKCk7XG4gICAgICAgIGlmICghU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKSB7XG4gICAgICAgICAgICBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiAoc2VhcmNoU3RyaW5nOiBzdHJpbmcsIHBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIHx8IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3Vic3RyKHBvc2l0aW9uLCBzZWFyY2hTdHJpbmcubGVuZ3RoKSA9PT0gc2VhcmNoU3RyaW5nO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJRSAxMCBvciBvbGRlciA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhtc2llICsgNSwgdWEuaW5kZXhPZignLicsIG1zaWUpKSwgMTApO1xuICAgIH1cblxuICAgIGxldCB0cmlkZW50ID0gdWEuaW5kZXhPZignVHJpZGVudC8nKTtcbiAgICBpZiAodHJpZGVudCA+IDApIHtcbiAgICAgICAgcG9seWZpbGwoKTtcbiAgICAgICAgaWYgKCFTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgpIHtcbiAgICAgICAgICAgIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChzZWFyY2hTdHJpbmc6IHN0cmluZywgcG9zaXRpb246IG51bWJlcikge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gfHwgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJzdHIocG9zaXRpb24sIHNlYXJjaFN0cmluZy5sZW5ndGgpID09PSBzZWFyY2hTdHJpbmc7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSUUgMTEgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgIGxldCBydiA9IHVhLmluZGV4T2YoJ3J2OicpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodWEuc3Vic3RyaW5nKHJ2ICsgMywgdWEuaW5kZXhPZignLicsIHJ2KSksIDEwKTtcbiAgICB9XG5cbiAgICBsZXQgZWRnZSA9IHVhLmluZGV4T2YoJ0VkZ2UvJyk7XG4gICAgaWYgKGVkZ2UgPiAwKSB7XG4gICAgICAgIC8vIEVkZ2UgKElFIDEyKykgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgIHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcoZWRnZSArIDUsIHVhLmluZGV4T2YoJy4nLCBlZGdlKSksIDEwKTtcbiAgICB9XG5cbiAgICAvLyBvdGhlciBicm93c2VyXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAgIDBcbiAgICBkZXRlY3RJRSgpO1xufSwgZmFsc2UpO1xuXG4vLyBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L01vdXNlRXZlbnRcbi8vIHBvbHlmaWxsIGZvciBvbGQgdmVyc2lvbiBvZiBJRVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUlFUG9seWZpbGwod2luZG93OiBhbnkpIHtcbiAgICB0cnkge1xuICAgICAgICBuZXcgQ3VzdG9tRXZlbnQoJ3Rlc3QnKTsgLy8gTm8gbmVlZCB0byBwb2x5ZmlsbFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gUG9seWZpbGxzIERPTTQgQ3VzdG9tRXZlbnRcbiAgICAgICAgbGV0IE1vdXNlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRUeXBlOiBhbnksIHBhcmFtczogYW55KSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UgfTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ01vdXNlRXZlbnQnKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQuaW5pdE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHdpbmRvdywgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXG4gICAgICAgICAgICByZXR1cm4gbW91c2VFdmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIE1vdXNlRXZlbnQucHJvdG90eXBlID0gRXZlbnQucHJvdG90eXBlO1xuICAgICAgICB3aW5kb3cuTW91c2VFdmVudCA9IE1vdXNlRXZlbnQ7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBcERBO0FBc0RBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/core/web-utilities.ts\n");

/***/ }),

/***/ "./src/interface/grid.ts":
/*!*******************************!*\
  !*** ./src/interface/grid.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Column {\n    constructor(headerName, field) {\n        this.headerName = headerName;\n        if (!field) {\n            this.field = headerName;\n        }\n        else {\n            this.field = field;\n        }\n    }\n}\nexports.Column = Column;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW50ZXJmYWNlL2dyaWQudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9VV1QvLi9zcmMvaW50ZXJmYWNlL2dyaWQudHM/YWZhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJQ29udGV4dE1lbnVJdGVtLCBJRXZlbnQsIFVJRWxlbWVudCwgVUlUeXBlIH0gZnJvbSAnLi91aS1iYXNlJztcblxuLy8gYmFzZWQgb2ZmIG9mIGFnLWdyaWQgc3RydWN0dXJlc1xuZXhwb3J0IGludGVyZmFjZSBBYnN0cmFjdENvbERlZiB7XG4gICAgLyoqIFRoZSBuYW1lIHRvIHJlbmRlciBpbiB0aGUgY29sdW1uIGhlYWRlciAqL1xuICAgIGhlYWRlck5hbWU6IHN0cmluZztcbiAgICAvKiogQ1NTIGNsYXNzIGZvciB0aGUgaGVhZGVyICovXG4gICAgaGVhZGVyQ2xhc3M/OiBzdHJpbmcgfCBzdHJpbmdbXSB8ICgocGFyYW1zOiBhbnkpID0+IHN0cmluZyB8IHN0cmluZ1tdKTtcbn1cbi8vIGJhc2VkIG9mZiBvZiBhZy1ncmlkIHN0cnVjdHVyZXNcbmV4cG9ydCBpbnRlcmZhY2UgSUNvbEdyb3VwRGVmIGV4dGVuZHMgQWJzdHJhY3RDb2xEZWYge1xuICAgIC8qKiBDb2x1bW5zIGluIHRoaXMgZ3JvdXAgKi9cbiAgICBjaGlsZHJlbjogKElDb2xEZWYgfCBJQ29sR3JvdXBEZWYpW107XG59XG4vLyBiYXNlZCBvZmYgb2YgYWctZ3JpZCBzdHJ1Y3R1cmVzXG5leHBvcnQgaW50ZXJmYWNlIElDb2xEZWYgZXh0ZW5kcyBBYnN0cmFjdENvbERlZiB7XG4gICAgLyoqIFRoZSBmaWVsZCBvZiB0aGUgcm93IHRvIGdldCB0aGUgY2VsbHMgZGF0YSBmcm9tICovXG4gICAgZmllbGQ/OiBzdHJpbmc7XG4gICAgLyoqIElmIHNvcnRpbmcgYnkgZGVmYXVsdCwgc2V0IGl0IGhlcmUuIFNldCB0byAnYXNjJyBvciAnZGVzYycgKi9cbiAgICBzb3J0Pzogc3RyaW5nO1xuICAgIC8qKiBXaGV0aGVyIHRoaXMgY29sdW1uIGlzIHBpbm5lZCBvciBub3QuICovXG4gICAgcGlubmVkPzogYm9vbGVhbiB8IHN0cmluZztcbiAgICAvKiogVGhlIGZpZWxkIHdoZXJlIHdlIGdldCB0aGUgdG9vbHRpcCBvbiB0aGUgb2JqZWN0ICovXG4gICAgdG9vbHRpcEZpZWxkPzogc3RyaW5nO1xuICAgIC8qKiBUb29sdGlwIGZvciB0aGUgY29sdW1uIGhlYWRlciAqL1xuICAgIGhlYWRlclRvb2x0aXA/OiBzdHJpbmc7XG4gICAgLyoqIEluaXRpYWwgd2lkdGgsIGluIHBpeGVscywgb2YgdGhlIGNlbGwgKi9cbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICAvKiogTWluIHdpZHRoLCBpbiBwaXhlbHMsIG9mIHRoZSBjZWxsICovXG4gICAgbWluV2lkdGg/OiBudW1iZXI7XG4gICAgLyoqIE1heCB3aWR0aCwgaW4gcGl4ZWxzLCBvZiB0aGUgY2VsbCAqL1xuICAgIG1heFdpZHRoPzogbnVtYmVyO1xuICAgIC8qKiBDbGFzcyB0byB1c2UgZm9yIHRoZSBjZWxsLiBDYW4gYmUgc3RyaW5nLCBhcnJheSBvZiBzdHJpbmdzLCBvciBmdW5jdGlvbi4gKi9cbiAgICBjZWxsQ2xhc3M/OiBzdHJpbmcgfCBzdHJpbmdbXSB8ICgoY2VsbENsYXNzUGFyYW1zOiBhbnkpID0+IHN0cmluZyB8IHN0cmluZ1tdKTtcbiAgICAvKiogQW4gb2JqZWN0IG9mIGNzcyB2YWx1ZXMuIE9yIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGFuIG9iamVjdCBvZiBjc3MgdmFsdWVzLiAqL1xuICAgIGNlbGxTdHlsZT86IHt9IHwgKChwYXJhbXM6IGFueSkgPT4ge30pO1xuICAgIC8qKiByZW5kZXJlciB1c2VkIHRvIHJlbmRlciB0aGUgY2VsbCBpbmZvcm1hdGlvbiAqL1xuICAgIGNlbGxSZW5kZXJlcj86IChwYXJhbXM6IGFueSkgPT4gKEhUTUxFbGVtZW50IHwgc3RyaW5nKTtcbiAgICAvKiogY2FsbGVkIHdoZW4gYSBjZWxsIGlzIGNsaWNrZWQgKi9cbiAgICBvbkNlbGxDbGlja2VkPzogKGV2ZW50OiBJRXZlbnQpID0+IHZvaWQ7XG4gICAgLyoqIGNhbGxlZCB3aGVuIGEgY2VsbCBpcyBkb3VibGUgY2xpY2tlZCAqL1xuICAgIG9uQ2VsbERvdWJsZUNsaWNrZWQ/OiAoZXZlbnQ6IElFdmVudCkgPT4gdm9pZDtcbiAgICAvKiogdXNlZCB0byB0cmFuc2xhdGUgdGhlIGRhdGEgaW4gdGhlIGRhdGEgc2V0IGludG8gdGhlIHZhbHVlIHNob3duIHRvIHRoZSB1c2VyICovXG4gICAgdmFsdWVHZXR0ZXI/OiAocm93RGF0YTogYW55KSA9PiB2b2lkO1xuICAgIC8qKiB0aGUgY29udGV4dCBtZW51IGRlZmluaXRpb25zIGZvciB3aGVuIHRoZSB1c2VyIHJpZ2h0IGNsaWNrcyAqL1xuICAgIGNvbnRleHRNZW51SXRlbXM/OiBJQ29udGV4dE1lbnVJdGVtW107XG4gICAgLyoqIHdoZXRoZXIgdGhlIHZhbHVlIGlzIG51bWVyaWNhbCBhbmQgY2FuIGJlIHNob3duIGFzIGEgcGVyY2VudGFnZSAqL1xuICAgIGNhblNob3dQZXJjZW50YWdlPzogYm9vbGVhbjtcbiAgICAvKiogdGhlIHZhbHVlIGlzIG51bWVyaWNhbCBhbmQgc2hvdWxkIGJlIHNob3duIGFzIGEgcGVyY2VudGFnZSBieSBkZWZhdWx0ICovXG4gICAgc2hvd0FzUGVyY2VudGFnZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUdyaWRPcHRpb25zIHtcbiAgICByb3dEYXRhPzogYW55W107XG4gICAgY29sdW1uRGVmcz86IChJQ29sRGVmIHwgSUNvbEdyb3VwRGVmKVtdO1xuICAgIGdyaWRDbGFzcz86IHN0cmluZztcbiAgICBkZWZhdWx0Q29sRGVmPzoge1xuICAgICAgICBzb3J0YWJsZT86IGJvb2xlYW47XG4gICAgfTtcbiAgICBlbmFibGVTaW5nbGVLZXlib2FyZFNlbGVjdGlvbj86IGJvb2xlYW47XG4gICAgYW5pbWF0ZVJvd3M/OiBib29sZWFuO1xuICAgIGFwaT86IGFueTtcbiAgICAvKiogY2FsbGVkIHdoZW4gYSByb3cgaXMgc2VsZWN0ZWQgKi9cbiAgICBvblJvd1NlbGVjdGVkPzogKGV2ZW50OiBJRXZlbnQpID0+IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBjYWxsZWQgd2hlbiBhIHJvdyBpcyBjbGlja2VkXG4gICAgICovXG4gICAgb25Sb3dDbGlja2VkPzogKGV2ZW50OiBJRXZlbnQpID0+IHZvaWQ7XG5cbiAgICAvKiogXG4gICAgICogY2FsbGVkIHdoZW4gYSByb3cgaXMgZG91YmxlIGNsaWNrZWRcbiAgICAgKi9cbiAgICBvblJvd0RvdWJsZUNsaWNrZWQ/OiAoZXZlbnQ6IElFdmVudCkgPT4gdm9pZDtcblxuICAgIC8qKiB1c2VkIHdoZW4gdGhlcmUgaXMgYSBwZXJpb2QgaW4gZmllbGQgZGF0YSB0byBpZ25vcmUgdGhlIGRvdCAqL1xuICAgIHN1cHByZXNzRmllbGREb3ROb3RhdGlvbj86IGJvb2xlYW4sXG4gICAgLyoqIHRoZSBjb250ZXh0IG1lbnUgZGVmaW5pdGlvbnMgZm9yIHdoZW4gdGhlIHVzZXIgcmlnaHQgY2xpY2tzICovXG4gICAgY29udGV4dE1lbnVJdGVtcz86IElDb250ZXh0TWVudUl0ZW1bXTtcbiAgICAvKiogY2FsbGVkIGFmdGVyIHRoZSBncmlkIGlzIHJlbmRlcmVkICovXG4gICAgb25HcmlkUmVhZHk/OiAoZXZlbnQ6IGFueSkgPT4gdm9pZDtcbiAgICAvKiogdGhlIGZpZWxkIHRvIHVzZSBmb3IgYSBzZWxlY3Rpb24gKi9cbiAgICBzZWxlY3Rpb25LZXk/OiBhbnk7XG4gICAgLyoqIGF1dG8gc2Nyb2xsIHRvIG1ha2UgdGhlIHJvdyB2aXNpYmxlIHdoZW4gYSBzZWxlY3Rpb24gaGFwcGVucyAqL1xuICAgIGF1dG9TY3JvbGxUb1NlbGVjdGlvbj86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUdyaWQgZXh0ZW5kcyBVSUVsZW1lbnQge1xuICAgIHR5cGU6IFVJVHlwZTtcbiAgICBncmlkT3B0aW9uczogSUdyaWRPcHRpb25zO1xuICAgIGFwaT86IHtcbiAgICAgICAgc2VsZWN0OiAoZXZlbnQ6IElFdmVudCkgPT4gdm9pZCxcbiAgICAgICAgaG92ZXI6IChldmVudDogSUV2ZW50KSA9PiB2b2lkXG4gICAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIENvbHVtbiBpbXBsZW1lbnRzIElDb2xEZWYge1xuICAgIHB1YmxpYyBoZWFkZXJOYW1lOiBzdHJpbmc7XG4gICAgcHVibGljIGZpZWxkOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihoZWFkZXJOYW1lOiBzdHJpbmcsIGZpZWxkOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJOYW1lID0gaGVhZGVyTmFtZTtcbiAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgICAgdGhpcy5maWVsZCA9IGhlYWRlck5hbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiI7O0FBZ0dBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/interface/grid.ts\n");

/***/ }),

/***/ "./src/interface/ui-base.ts":
/*!**********************************!*\
  !*** ./src/interface/ui-base.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n;\n/**\n * Represents a relative alignment\n*/\nvar Alignment;\n(function (Alignment) {\n    Alignment[Alignment[\"Left\"] = 1] = \"Left\";\n    Alignment[Alignment[\"Right\"] = 2] = \"Right\";\n    Alignment[Alignment[\"Top\"] = 4] = \"Top\";\n    Alignment[Alignment[\"Bottom\"] = 8] = \"Bottom\";\n    Alignment[Alignment[\"None\"] = 0] = \"None\";\n})(Alignment = exports.Alignment || (exports.Alignment = {}));\n; // bitmask Position\nvar EventType;\n(function (EventType) {\n    EventType[EventType[\"CursorStart\"] = 0] = \"CursorStart\";\n    EventType[EventType[\"CursorMove\"] = 1] = \"CursorMove\";\n    EventType[EventType[\"CursorEnd\"] = 2] = \"CursorEnd\";\n    EventType[EventType[\"BrushStart\"] = 3] = \"BrushStart\";\n    EventType[EventType[\"BrushMove\"] = 4] = \"BrushMove\";\n    EventType[EventType[\"BrushEnd\"] = 5] = \"BrushEnd\";\n    EventType[EventType[\"HoverStart\"] = 6] = \"HoverStart\";\n    EventType[EventType[\"HoverEnd\"] = 7] = \"HoverEnd\";\n    EventType[EventType[\"HoverClear\"] = 8] = \"HoverClear\";\n    EventType[EventType[\"FocusStart\"] = 6] = \"FocusStart\";\n    EventType[EventType[\"FocusEnd\"] = 7] = \"FocusEnd\";\n    EventType[EventType[\"FocusClear\"] = 8] = \"FocusClear\";\n    EventType[EventType[\"SelectAdd\"] = 9] = \"SelectAdd\";\n    EventType[EventType[\"SelectRemove\"] = 10] = \"SelectRemove\";\n    EventType[EventType[\"SelectStart\"] = 9] = \"SelectStart\";\n    EventType[EventType[\"SelectEnd\"] = 10] = \"SelectEnd\";\n    EventType[EventType[\"SelectClear\"] = 11] = \"SelectClear\";\n    EventType[EventType[\"Zoom\"] = 12] = \"Zoom\";\n    EventType[EventType[\"Click\"] = 13] = \"Click\";\n    EventType[EventType[\"DoubleClick\"] = 14] = \"DoubleClick\";\n    EventType[EventType[\"RangeUpdate\"] = 15] = \"RangeUpdate\";\n})(EventType = exports.EventType || (exports.EventType = {}));\nvar UIType;\n(function (UIType) {\n    UIType[UIType[\"Unrendered\"] = 0] = \"Unrendered\";\n    UIType[UIType[\"Cartesian\"] = 1] = \"Cartesian\";\n    UIType[UIType[\"Pie\"] = 2] = \"Pie\";\n    UIType[UIType[\"Grid\"] = 3] = \"Grid\";\n    UIType[UIType[\"FlowDiagram\"] = 4] = \"FlowDiagram\";\n    UIType[UIType[\"ForceDirectedGraph\"] = 5] = \"ForceDirectedGraph\";\n    UIType[UIType[\"Sunburst\"] = 6] = \"Sunburst\";\n    UIType[UIType[\"HierarchyGraph\"] = 7] = \"HierarchyGraph\";\n    UIType[UIType[\"PortDiagram\"] = 8] = \"PortDiagram\";\n    UIType[UIType[\"SimpleGraph\"] = 9] = \"SimpleGraph\";\n    UIType[UIType[\"TreeMap\"] = 10] = \"TreeMap\";\n    UIType[UIType[\"Axis\"] = 11] = \"Axis\";\n    UIType[UIType[\"Radar\"] = 12] = \"Radar\";\n})(UIType = exports.UIType || (exports.UIType = {}));\nvar LegendType;\n(function (LegendType) {\n    LegendType[LegendType[\"Discrete\"] = 0] = \"Discrete\";\n    LegendType[LegendType[\"Gradient\"] = 1] = \"Gradient\";\n})(LegendType = exports.LegendType || (exports.LegendType = {}));\nvar LegendOrientation;\n(function (LegendOrientation) {\n    LegendOrientation[LegendOrientation[\"Vertical\"] = 0] = \"Vertical\";\n    LegendOrientation[LegendOrientation[\"Horizontal\"] = 1] = \"Horizontal\";\n})(LegendOrientation = exports.LegendOrientation || (exports.LegendOrientation = {}));\nvar LegendItemShape;\n(function (LegendItemShape) {\n    LegendItemShape[LegendItemShape[\"Rectangle\"] = 0] = \"Rectangle\";\n    LegendItemShape[LegendItemShape[\"Line\"] = 1] = \"Line\";\n    LegendItemShape[LegendItemShape[\"Circle\"] = 2] = \"Circle\";\n})(LegendItemShape = exports.LegendItemShape || (exports.LegendItemShape = {}));\n// Represents a rectangular area.\nclass Rect {\n    constructor(x, y, width, height) {\n        this.x = 0;\n        this.y = 0;\n        this.width = 0;\n        this.height = 0;\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    // Returns true if the rectangle contains (x,y).\n    contains(x, y) {\n        return (x >= this.x && x <= this.x + this.width &&\n            y >= this.y && y <= this.y + this.height);\n    }\n}\nexports.Rect = Rect;\n/**\n * Used to manipulate CSS class and style information\n */\nclass Css {\n    constructor(classes, style) {\n        if (classes) {\n            this.addClasses(classes);\n        }\n        else {\n            this.classes = {};\n        }\n        if (style) {\n            this.style = style;\n        }\n        else {\n            this.style = {};\n        }\n    }\n    /**\n     * add a class to the class list\n     * @param classes to add, can be strings separated by spaces\n     *\n     * @return the manager instance\n     */\n    addClasses(classesStr) {\n        let classes = classesStr.split(' ');\n        for (let i = 0; i < classes.length; ++i) {\n            this.classes[classes[i]] = true;\n        }\n        return this;\n    }\n    /**\n     * add a set of styles to the style object\n     * @param style a style object\n     *\n     * @return the manager instance\n     */\n    addStyles(style) {\n        for (let key in style) {\n            this.style[key] = style[key];\n        }\n        return this;\n    }\n    /** set the color value\n     *\n     * @param color a string representing the color to use\n     */\n    setColor(color) {\n        this.addStyles({ color: color });\n        return this;\n    }\n    /** set the opcaity value\n     *\n     * @param opcaity a string representing the color to use\n     */\n    setOpacity(opacity) {\n        this.addStyles({ opacity: opacity });\n        return this;\n    }\n    /**\n     * remove a class from the class list\n     * @param className the class to remove\n     *\n     * @return the manager instance\n     */\n    removeClass(className) {\n        delete this.classes[className];\n        return this;\n    }\n    /**\n     * remove a style from the style map\n     * @param key the name of the style to remove\n     *\n     * @return the manager instance\n     */\n    removeStyle(key) {\n        delete this.style[key];\n        return this;\n    }\n    /**\n     * get the list of classes\n     *\n     * @return a list of classes for this manager\n     */\n    getClasses() {\n        return Object.keys(this.classes);\n    }\n    /**\n     * helper to get a space separated list of classes\n     *\n     * @return a string list of classes for this manager\n     */\n    getClassString() {\n        let ret = '';\n        for (let className in this.classes) {\n            ret += className + ' ';\n        }\n        return ret;\n    }\n    /**\n     * get the style map\n     *\n     * @return an object that contains key/value style pairs\n     */\n    getStyles() {\n        return this.style;\n    }\n    /**\n     * helper to get a json representation of the style map\n     *\n     * @return the json string of the style map\n     */\n    getStyleString() {\n        return JSON.stringify(this.style);\n    }\n}\nexports.Css = Css;\n;\n/**\n * implemented a basic API on top of the IRange object\n */\nclass Range {\n    constructor(min, max) {\n        this.min = min;\n        this.max = max;\n    }\n    /**\n     * set the min value for the range\n     *\n     * @return the min range value\n     */\n    setMin(min) {\n        this.min = min;\n        return this;\n    }\n    /**\n     * get the min value for the range\n     *\n     * @return the min range value\n     */\n    getMin() {\n        return this.min;\n    }\n    /**\n     * set the max value for the range\n     *\n     * @return the max range value\n     */\n    setMax(max) {\n        this.max = max;\n        return this;\n    }\n    /**\n     * get the max value for the range\n     *\n     * @return the max range value\n     */\n    getMax() {\n        return this.max;\n    }\n}\nexports.Range = Range;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW50ZXJmYWNlL3VpLWJhc2UudHMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9VV1QvLi9zcmMvaW50ZXJmYWNlL3VpLWJhc2UudHM/YjgzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb2xvck1hbmFnZXIgfSBmcm9tIFwiLi4vY29yZS9jb2xvci1tYW5hZ2VyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRvb2x0aXBEYXRhIHtcbiAgICAvKiogdGhlIGVsZW1lbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyB0b29sdGlwICovXG4gICAgc291cmNlOiBVSUVsZW1lbnQsXG4gICAgLyoqIHRoZSBuYW1lIG9mIHRoZSBncm91cCBmb3IgdGhpcyB0b29sdGlwICovXG4gICAgZ3JvdXA6IHN0cmluZyxcbiAgICAvKiogYSBsaXN0IG9mIGRhdGEgdG8gYmUgc2hvd24gaW4gdGhlIHRvb2x0aXAgKi9cbiAgICBtZXRyaWNzOiB7IFtpbmRleDogc3RyaW5nXTogc3RyaW5nIH1cbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUV2ZW50IHtcbiAgICAvKiogc3BlY2lmaWVzIHRoZSB0eXBlIG9mIGV2ZW50IGZyb21cbiAgICAgKiBbW0V2ZW50VHlwZV1dXG4gICAgICovXG4gICAgZXZlbnQ/OiBFdmVudFR5cGUsXG4gICAgc2VsZWN0aW9uPzogc3RyaW5nLFxuICAgIHNlbGVjdGlvbktleT86IHN0cmluZyxcbiAgICAvKiogZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50ICovXG4gICAgZGF0YT86IGFueSxcbiAgICAvKiogdG9vbHRpcCB1c2VkIHRvIGRpc3BsYXkgaW5mb3JtYXRpb24gYWJvdXQgZGF0YSAqL1xuICAgIHRvb2x0aXA/OiBhbnlcbiAgICAvKiogdGhlIG9yaWdpbmFsIGNhbGxlciB3aG8gY2F1c2VkIHRoaXMgZXZlbnQgdG8gYmUgZmlyZWQqL1xuICAgIGNhbGxlcj86IFVJRWxlbWVudCxcbiAgICAvKiogeFN0YXJ0IGJvdW5kcyBvZiBhc3NvY2lhdGVkIHdpdGggdGhpcyBldmVudCAqL1xuICAgIHhTdGFydD86IG51bWJlcixcbiAgICAvKiogeEVuZCBib3VuZHMgb2YgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZXZlbnQgKi9cbiAgICB4RW5kPzogbnVtYmVyLFxuICAgIC8qKiB5U3RhcnQgYm91bmRzIG9mIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGV2ZW50ICovXG4gICAgeVN0YXJ0PzogbnVtYmVyLFxuICAgIC8qKiB5RW5kIGJvdW5kcyBvZiBhc3NvY2lhdGVkIHdpdGggdGhpcyBldmVudCAqL1xuICAgIHlFbmQ/OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJT3B0aW9ucyB7XG4gICAgLyoqIGF0dGVtcHQgdG8gZml0IGEgZ3JhcGggaW50byB0aGUgdmlldyBzcGVjaWZpZWQgYnkgdGhlXG4gICAgICogW1tJT3B0aW9uc11dXG4gICAgICovXG4gICAgZml0VG9XaW5kb3c/OiBib29sZWFuLFxuICAgIC8qKiBibGluayBhc3NvY2FpdGVkIGRhdGEgd2hlbiBhIHNlbGVjdGlvbiBpcyBkb25lICovXG4gICAgZGlzYWJsZVNlbGVjdGlvbj86IGJvb2xlYW4sXG4gICAgc2VsZWN0aW9uQmxpbms/OiBib29sZWFuLFxuICAgIGRpc2FibGVCYWNrZ3JvdW5kPzogYm9vbGVhbixcbiAgICAvKiogdGVsbCBhIHdpZGdldCB0byBpZ25vcmUgdGhlIGhvdmVyIGV2ZW50cyAqL1xuICAgIGRpc2FibGVIb3Zlcj86IGJvb2xlYW4sXG4gICAgZGlzYWJsZUF1dG9SZXNpemVXaWR0aD86IGJvb2xlYW4sXG4gICAgZGlzYWJsZUF1dG9SZXNpemVIZWlnaHQ/OiBib29sZWFuLFxuICAgIGhpZGVSb3dUaXRsZT86IGJvb2xlYW4sXG5cbiAgICAvKiogQGRlcHJlY2F0ZWQgZGVwcmVjYXRlZCBmb3IgZm9jdXNSYWRpdXNEZWx0YSAqL1xuICAgIGhvdmVyUmFkaXVzRGVsdGE/OiBudW1iZXIsXG4gICAgZm9jdXNSYWRpdXNEZWx0YT86IG51bWJlcixcblxuICAgIC8vIHNhdmUgcmVuZGVyZWQgdmlld3MgYXMgaW1hZ2UgaWYgcG9zc2libGVcbiAgICBlbmFibGVTYXZlQXNJbWFnZT86IGJvb2xlYW4sXG5cbiAgICAvLyBhdXRvIHBpY2sgYSBkZWZhdWx0IHJlbmRlcmVyIHVubGVzcyBmb3JjZWQgYnkgdGhlc2UgZmxhZ3NcbiAgICBmb3JjZVN2Z1JlbmRlcmVyPzogYm9vbGVhbixcbiAgICBmb3JjZUNhbnZhc1JlbmRlcmVyPzogYm9vbGVhbixcblxuICAgIC8qKiBAZGVwcmVjYXRlZCBXZWJHTCBpcyBub3cgdGhlIGRlZmF1bHQgaW4gUElYSSBzbyB3ZSBoYXZlIHRvIGZvcmNlIHRoZSBjYW52YXMgcmVuZGVyZXIgKi9cbiAgICBmb3JjZVdlYkdMUmVuZGVyZXI/OiBib29sZWFuLFxuXG4gICAgLyoqIGJydXNoIG9wdGlvbnMgKi9cbiAgICBkaXNhYmxlQnJ1c2g/OiBib29sZWFuLFxuICAgIGZvcmNlQnJ1c2hUb0Zyb250PzogYm9vbGVhbixcblxuICAgIC8qKiBhbmltYXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMsIGRlZmF1bHRzIHRvIDEwMDAgKiovXG4gICAgYW5pbWF0ZUR1cmF0aW9uPzogbnVtYmVyLFxuICAgIGVuYWJsZVhZWm9vbT86IGJvb2xlYW4sXG4gICAgZGlzYWJsZVpvb21WaWV3VXBkYXRlPzogYm9vbGVhbixcbiAgICBkaXNhYmxlWm9vbU1vdXNlV2hlZWw/OiBib29sZWFuO1xuICAgIHNob3dTZWxlY3Rpb25Bc092ZXJsYXk/OiBib29sZWFuLFxuXG4gICAgLyoqIGhhbmRsZSByZXNpemUgY29udHJvbHMgKi9cbiAgICBkaXNhYmxlUmVzaXplPzogYm9vbGVhbixcbiAgICBkaXNhYmxlUmVzaXplUmlnaHQ/OiBib29sZWFuLFxuICAgIGRpc2FibGVSZXNpemVCb3R0b20/OiBib29sZWFuLFxuICAgIGRpc2FibGVSZXNpemVMZWZ0PzogYm9vbGVhbixcblxuICAgIC8qKiB0b29sdGlwIGJlaGF2aW9yICovXG4gICAgZGlzYWJsZUhvdmVyVG9vbHRpcD86IGJvb2xlYW4sIC8vIERFUFJFQ0FURUQgZm9yIGRpc2FibGVUb29sdGlwXG4gICAgZGlzYWJsZVRvb2x0aXA/OiBib29sZWFuLFxuICAgIHRvb2x0aXBEZWxheT86IG51bWJlcjtcblxuICAgIC8qKiBhc3luYyBkaXNwbGF5IGJlaGF2aW9yICovXG4gICAgZW5hYmxlV2ViV29ya2Vycz86IGJvb2xlYW47XG4gICAgLyoqIERFUFJFQ0FURUQgKi9cbiAgICBkaXNhYmxlV2ViV29ya2Vycz86IGJvb2xlYW47XG4gICAgZGlzYWJsZVByb2dyZXNzU3Bpbm5lcj86IGJvb2xlYW47XG5cbiAgICBoZWlnaHQ/OiBhbnksXG4gICAgd2lkdGg/OiBhbnksXG5cbiAgICB4U3RhcnQ/OiBudW1iZXIsXG4gICAgeEVuZD86IG51bWJlcixcbiAgICB5U3RhcnQ/OiBudW1iZXIsXG4gICAgeUVuZD86IG51bWJlcixcbiAgICB0b3BNYXJnaW4/OiBudW1iZXIsXG4gICAgYm90dG9tTWFyZ2luPzogbnVtYmVyLFxuICAgIGxlZnRNYXJnaW4/OiBudW1iZXIsXG4gICAgcmlnaHRNYXJnaW4/OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQnVmZmVyPERhdGFUeXBlPiB7XG4gICAgcHVzaChkOiBEYXRhVHlwZSk6IHZvaWQ7XG4gICAgZ2V0KGluZGV4OiBudW1iZXIpOiBEYXRhVHlwZTtcbiAgICBsZW5ndGgoKTogbnVtYmVyO1xuICAgIGdldERhdGEoKTogRGF0YVR5cGVbXTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcmVsYXRpdmUgYWxpZ25tZW50XG4qL1xuZXhwb3J0IGVudW0gQWxpZ25tZW50IHtcbiAgICBMZWZ0ID0gMSxcbiAgICBSaWdodCA9IDIsXG4gICAgVG9wID0gNCxcbiAgICBCb3R0b20gPSA4LFxuICAgIE5vbmUgPSAwXG59OyAgIC8vIGJpdG1hc2sgUG9zaXRpb25cblxuZXhwb3J0IGVudW0gRXZlbnRUeXBlIHtcbiAgICBDdXJzb3JTdGFydCxcbiAgICBDdXJzb3JNb3ZlLFxuICAgIEN1cnNvckVuZCxcbiAgICBCcnVzaFN0YXJ0LFxuICAgIEJydXNoTW92ZSxcbiAgICBCcnVzaEVuZCxcbiAgICBIb3ZlclN0YXJ0LFxuICAgIEhvdmVyRW5kLFxuICAgIEhvdmVyQ2xlYXIsXG4gICAgRm9jdXNTdGFydCA9IEhvdmVyU3RhcnQsXG4gICAgRm9jdXNFbmQgPSBIb3ZlckVuZCxcbiAgICBGb2N1c0NsZWFyID0gSG92ZXJDbGVhcixcbiAgICBTZWxlY3RBZGQsXG4gICAgU2VsZWN0UmVtb3ZlLFxuICAgIFNlbGVjdFN0YXJ0ID0gU2VsZWN0QWRkLFxuICAgIFNlbGVjdEVuZCA9IFNlbGVjdFJlbW92ZSxcbiAgICBTZWxlY3RDbGVhcixcbiAgICBab29tLFxuICAgIENsaWNrLFxuICAgIERvdWJsZUNsaWNrLFxuICAgIFJhbmdlVXBkYXRlXG59XG5cbmV4cG9ydCBlbnVtIFVJVHlwZSB7XG4gICAgVW5yZW5kZXJlZCxcbiAgICBDYXJ0ZXNpYW4sXG4gICAgUGllLFxuICAgIEdyaWQsXG4gICAgRmxvd0RpYWdyYW0sXG4gICAgRm9yY2VEaXJlY3RlZEdyYXBoLFxuICAgIFN1bmJ1cnN0LFxuICAgIEhpZXJhcmNoeUdyYXBoLFxuICAgIFBvcnREaWFncmFtLFxuICAgIFNpbXBsZUdyYXBoLFxuICAgIFRyZWVNYXAsXG4gICAgQXhpcyxcbiAgICBSYWRhclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElDb250ZXh0TWVudUl0ZW0ge1xuICAgIC8qKiBhZGQgYSBjbGlja2FibGUgaXRlbSB0aXRsZSAqL1xuICAgIHRpdGxlPzogc3RyaW5nLFxuXG4gICAgLyoqIGFkZCBhIGNsaWNrYWJsZSBpdGVtIGNhbGxiYWNrICovXG4gICAgYWN0aW9uPzogKGVsZW06IGFueSwgZGF0YTogYW55LCBpbmRleDogYW55KSA9PiB2b2lkO1xuXG4gICAgLyoqIGRpc2FibGUgdGhpcyBjbGlja2FibGUgaXRlbSAqL1xuICAgIGRpc2FibGVkPzogYm9vbGVhbjtcblxuICAgIC8qKiB1c2VkIHRvIGFkZCBhIGRpdmlkZXIgKi9cbiAgICBkaXZpZGVyPzogYm9vbGVhbjtcblxuICAgIHN1Ym1lbnU/OiBJQ29udGV4dE1lbnVJdGVtW107XG4gICAgc3VibWVudURpdj86IEhUTUxEaXZFbGVtZW50O1xufVxuXG5leHBvcnQgZW51bSBMZWdlbmRUeXBlIHtcbiAgICBEaXNjcmV0ZSxcbiAgICBHcmFkaWVudFxufVxuXG5leHBvcnQgZW51bSBMZWdlbmRPcmllbnRhdGlvbiB7XG4gICAgVmVydGljYWwsXG4gICAgSG9yaXpvbnRhbFxufVxuXG5leHBvcnQgZW51bSBMZWdlbmRJdGVtU2hhcGUge1xuICAgIFJlY3RhbmdsZSxcbiAgICBMaW5lLFxuICAgIENpcmNsZVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElMZWdlbmRJdGVtIHtcbiAgICBrZXk6IGFueSxcbiAgICBuYW1lPzogc3RyaW5nLFxuICAgIGNvbG9yPzogc3RyaW5nLFxuICAgIG9wYWNpdHk/OiBzdHJpbmcsXG4gICAgc2hhcGU/OiBzdHJpbmcgfCBMZWdlbmRJdGVtU2hhcGUsXG4gICAgdmFsdWU/OiBhbnksXG4gICAgdW5pdHM/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJTGVnZW5kRGVmaW5pdGlvbiB7XG4gICAgaXRlbXM6IElMZWdlbmRJdGVtW107XG4gICAgdHlwZT86IExlZ2VuZFR5cGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUxlZ2VuZCB7XG4gICAgYWxpZ25tZW50OiBBbGlnbm1lbnQ7XG4gICAgb3JpZW50YXRpb24/OiBMZWdlbmRPcmllbnRhdGlvbjtcbiAgICBzaG93VmFsdWU/OiBib29sZWFuO1xuICAgIGRlZmluaXRpb24/OiBJTGVnZW5kRGVmaW5pdGlvbjtcblxuICAgIC8qKiBicnVzaCBzZWxlY3RvaW4gcmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nIGNvbnRleHQgbWVudSAqL1xuICAgIGNvbnRleHRNZW51SXRlbXM/OiBJQ29udGV4dE1lbnVJdGVtW107XG5cbiAgICAvKiogY2FsbGJhY2sgd2hlbiB1c2VyIGNsaWNrcyBvbiBhbiBpdGVtICovXG4gICAgb25DbGljaz86IChldmVudDogSUV2ZW50KSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElDaGVja2JveFRyZWVOb2RlIHtcbiAgICBpZDogYW55O1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBjaGlsZHJlbjogSUNoZWNrYm94VHJlZU5vZGVbXTtcbiAgICBwYXJlbnQ/OiBJQ2hlY2tib3hUcmVlTm9kZTtcbiAgICBvcGVuPzogYm9vbGVhbjtcbiAgICBjaGVja2VkPzogYm9vbGVhbjtcbiAgICBpbmRldGVybWluYXRlPzogYm9vbGVhbjtcbiAgICBwcm9wb2dhdGVDaGFuZ2U/OiBib29sZWFuO1xuICAgIG5vdENoZWNrYWJsZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVUlSZW5kZXJlciB7XG4gICAgLyoqIGZyZWUgcmVzb3VyY2VzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudCAqL1xuICAgIGRlc3Ryb3k/OiAoY2FsbGVyOiBVSUVsZW1lbnQpID0+IHZvaWQ7XG5cbiAgICBzZXREaXY/OiBhbnk7XG5cbiAgICBzZXRPblJlbmRlckNhbGxiYWNrPzogKGNhbGxiYWNrOiAoZWxlbTogVUlFbGVtZW50LCBvcHRpb25zOiBJT3B0aW9ucykgPT4gdm9pZCkgPT4gdm9pZDtcblxuICAgIC8qKiBjYWxsYmFja3MgZm9yIHdoZW4gdGhpcyBlbGVtZW50IGhhcyBiZWVuIHVwZGF0ZWQsIHVzZWQgc28gdGhlIHJlbmRlciBvd25lclxuICAgICAqIGNhbiBtYWludGFpbiBzdGF0ZSBpZiB0aGV5IHdhbnQgb2YgZWFjaCBlbGVtZW50XG4gICAgICovXG4gICAgb25SZW5kZXI/OiAoY2FsbGVyOiBVSUVsZW1lbnQsIG9wdGlvbnM6IElPcHRpb25zKSA9PiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgKCdEZXByZWNhdGVkIHNpbmNlIDEuMTQuMCBpbiBmYXZvciBvZiBmb2N1cy4gIFdpbGwgYmUgcmVtb3ZlZCBpbiAyLngnKVxuICAgICAqIGhvdmVyIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCB0byBmaXJlIHRoZSBob3ZlciBldmVudCBvblxuICAgICAqIEBwYXJhbSBldmVudCBhbnkgZXZlbnQgdG8gcGFzcyB0byB0aGUgcmVuZGVyZXJcbiAgICAgKi9cbiAgICBob3Zlcj8oZWxlbWVudDogVUlFbGVtZW50LCBldmVudDogSUV2ZW50KTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIGZvY3VzIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCB0byBmaXJlIHRoZSBmb2N1cyBldmVudCBvblxuICAgICAqIEBwYXJhbSBldmVudCBhbnkgZXZlbnQgdG8gcGFzcyB0byB0aGUgcmVuZGVyZXJcbiAgICAgKi9cbiAgICBmb2N1cz8oZWxlbWVudDogVUlFbGVtZW50LCBldmVudDogSUV2ZW50KTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIHNlbGVjdCBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgdG8gZmlyZSB0aGUgY2xpY2sgZXZlbnQgb25cbiAgICAgKiBAcGFyYW0gZXZlbnQgYW55IGV2ZW50IHRvIHBhc3MgdG8gdGhlIHJlbmRlcmVyXG4gICAgICovXG4gICAgc2VsZWN0PyhlbGVtZW50OiBVSUVsZW1lbnQsIGV2ZW50OiBJRXZlbnQpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogem9vbSBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgdG8gZmlyZSB0aGUgem9vbSBldmVudCBvblxuICAgICAqIEBwYXJhbSBldmVudCBhbnkgZXZlbnQgdG8gcGFzcyB0byB0aGUgcmVuZGVyZXJcbiAgICAgKi9cbiAgICB6b29tPyhlbGVtZW50OiBVSUVsZW1lbnQsIGV2ZW50OiBJRXZlbnQpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogYnJ1c2ggZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IHRvIGZpcmUgdGhlIGJydXNoIGV2ZW50IG9uXG4gICAgICogQHBhcmFtIGV2ZW50IGFueSBldmVudCB0byBwYXNzIHRvIHRoZSByZW5kZXJlclxuICAgICAqL1xuICAgIGJydXNoPyhlbGVtZW50OiBVSUVsZW1lbnQsIGV2ZW50OiBJRXZlbnQpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogY3Vyc29yIG1vdmVkIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbWVudCB0byBmaXJlIHRoZSBtb3ZlIGV2ZW50IG9uXG4gICAgICogQHBhcmFtIGV2ZW50IGFueSBldmVudCB0byBwYXNzIHRvIHRoZSByZW5kZXJlclxuICAgICAqL1xuICAgIGN1cnNvckNoYW5nZT8oZWxlbWVudDogVUlFbGVtZW50LCBldmVudDogSUV2ZW50KTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHRoZSBlbGVtZW50IHRvIHJlbmRlclxuICAgICAqL1xuICAgIHJlbmRlcihlbGVtZW50OiBVSUVsZW1lbnQsIG9wdGlvbnM/OiBJT3B0aW9ucyk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlIHRoZSBnaXZlbiBlbGVtZW50LiAgVGhpcyBpcyBkaWZmZXJlbnQgZnJvbVxuICAgICAqIHJlbmRlciBpbiB0aGF0IGl0IGNvbXBsZXRlbHkgcmVkcmF3cyB0aGUgZWxlbWVudCBpbnN0ZWFkIG9mXG4gICAgICoganVzdCByZS1yZW5kZXJpbmcgaXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aGUgZWxlbWVudCB0byBpbnZhbGlkYXRlXG4gICAgICovXG4gICAgaW52YWxpZGF0ZShlbGVtZW50OiBVSUVsZW1lbnQsIG9wdGlvbnM/OiBJT3B0aW9ucyk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNzcyBhY3R1YWxseSByZW5kZXJlZC4gVGhpcyBpcyB1c2VmdWwgZm9yIGxlZ2VuZCBzd2F0Y2hlc1xuICAgICAqIGFuZCB0aGUgbGlrZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aGUgZWxlbWVudCB0byBnZXQgdGhlIHJlbmRlcmVkIENTUyBpbmZvcm1hdGlvbiBmb3JcbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGhlIGNzcyByZW5kZXJlZCwgb3IgdW5kZWZpbmVkIGlmIGNhbGxlZCBiZWZvcmUgdGhlIGNoYXJ0IGlzXG4gICAgICogICByZW5kZXJlZFxuICAgICAqL1xuICAgIGdldFJlbmRlcmVkQ3NzPyhlbGVtZW50OiBVSUVsZW1lbnQpOiBDc3M7XG5cbiAgICAvKipcbiAgICAgKiB0b29sdGlwIHRoZSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbmRlcmVyIGFuIElSZW5kZXJlciBvYmplY3QgdGhhdCBoYXMgdGhlIHRvb2x0aXBcbiAgICAgKiBAcGFyYW0gZXZlbnQgYW55IGV2ZW50IHRvIHBhc3MgdG8gdGhlIHJlbmRlcmVyXG4gICAgICovXG4gICAgZ2V0VG9vbHRpcERhdGE/KGVsZW1lbnQ6IFVJRWxlbWVudCwgZXZlbnQ6IElFdmVudCk6IElUb29sdGlwRGF0YVtdO1xuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBvcHRpb25zIHRoZSByZW5kZXJlciBpcyB1c2luZyBmb3IgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aGUgZWxlbWVudCB0byBpbnZhbGlkYXRlXG4gICAgICovXG4gICAgZ2V0T3B0aW9ucyhlbGVtZW50OiBVSUVsZW1lbnQpOiBJT3B0aW9ucztcblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgY29sb3JzIHRoZSByZW5kZXJlciBpcyB1c2luZyBmb3IgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aGUgZWxlbWVudCB0byBpbnZhbGlkYXRlXG4gICAgICovXG4gICAgZ2V0Q29sb3JNYW5hZ2VyKCk6IENvbG9yTWFuYWdlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVSUVsZW1lbnQge1xuICAgIHR5cGU/OiBVSVR5cGU7XG4gICAgb3B0aW9ucz86IElPcHRpb25zO1xuICAgIHJlbmRlcmVyPzogVUlSZW5kZXJlcjtcbiAgICBtYW5hZ2VyPzogVUlFbGVtZW50TWFuYWdlcjtcblxuICAgIGFwaT86IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkICgnRGVwcmVjYXRlZCBzaW5jZSAxLjE0LjAgaW4gZmF2b3Igb2YgZm9jdXMuICBXaWxsIGJlIHJlbW92ZWQgaW4gMi54JylcbiAgICAgICAgICogZmlyZSBhIGhvdmVyIGV2ZW50IGZvciB0aGlzIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGV2ZW50IGFueSBldmVudCB0byBwYXNzIHRvIHRoZSByZW5kZXJlclxuICAgICAgICAgKi9cbiAgICAgICAgaG92ZXI/OiAoZXZlbnQ/OiBJRXZlbnQpID0+IHZvaWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZpcmUgYSBmb2N1cyBldmVudCBmb3IgdGhpcyBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBldmVudCBhbnkgZXZlbnQgdG8gcGFzcyB0byB0aGUgcmVuZGVyZXJcbiAgICAgICAgICovXG4gICAgICAgIGZvY3VzPzogKGV2ZW50PzogSUV2ZW50KSA9PiB2b2lkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmaXJlIGEgc2VsZWN0IGV2ZW50IGZvciB0aGlzIGVsZW1lbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGV2ZW50IGFueSBldmVudCB0byBwYXNzIHRvIHRoZSByZW5kZXJlclxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0PzogKGV2ZW50PzogSUV2ZW50KSA9PiB2b2lkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmaXJlIGEgem9vbSBldmVudCBmb3IgdGhpcyBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBldmVudCBhbnkgZXZlbnQgdG8gcGFzcyB0byB0aGUgcmVuZGVyZXJcbiAgICAgICAgICovXG4gICAgICAgIHpvb20/OiAoZXZlbnQ/OiBJRXZlbnQpID0+IHZvaWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZpcmUgYSBtb3VzZS90b3VjaCBjaGFuZ2UgZXZlbnQgZm9yIHRoaXMgZWxlbWVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZXZlbnQgYW55IGV2ZW50IHRvIHBhc3MgdG8gdGhlIHJlbmRlcmVyXG4gICAgICAgICAqL1xuICAgICAgICBjdXJzb3JDaGFuZ2U/OiAoZXZlbnQ/OiBJRXZlbnQpID0+IHZvaWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZpcmUgYSBicnVzaCBldmVudCBmb3IgdGhpcyBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBldmVudCBhbnkgZXZlbnQgdG8gcGFzcyB0byB0aGUgcmVuZGVyZXJcbiAgICAgICAgICovXG4gICAgICAgIGJydXNoPzogKGV2ZW50PzogSUV2ZW50KSA9PiB2b2lkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwYW4gdG8gYSBnaXZlbiBldmVudCBsb2NhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgcGFuPzogKGV2ZW50PzogSUV2ZW50KSA9PiB2b2lkO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIGVsZW1lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByZW5kZXJlciBhbiBJUmVuZGVyZXIgb2JqZWN0IHRoYXQgY2FuIHJlbmRlciB0aGlzIGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgYW55IG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgcmVuZGVyZXJcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcj86IChyZW5kZXJlcj86IFVJUmVuZGVyZXIsIG9wdGlvbnM/OiBJT3B0aW9ucykgPT4gUHJvbWlzZTxhbnk+O1xuXG4gICAgICAgIGdldE9wdGlvbnM/OiAoKSA9PiBJT3B0aW9ucztcbiAgICAgICAgc2F2ZUltYWdlPzogKCkgPT4gdm9pZDtcbiAgICAgICAgY3JlYXRlSW1hZ2U/OiAoKSA9PiB2b2lkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0b29sdGlwIGRhdGEgZm9yIHRoZSBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgYW55IGV2ZW50IHRvIHBhc3MgdG8gdGhlIHJlbmRlcmVyXG4gICAgICovXG4gICAgZ2V0VG9vbHRpcD86IChldmVudD86IElFdmVudCkgPT4gSVRvb2x0aXBEYXRhW107XG5cbiAgICAvKipcbiAgICAgKiBjYWxsYmFjayB3aGVuIGEgdG9vbHRpcCBvY2N1cnMgaW4gdGhpcyBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGV2ZW50IHJlbGF0ZWQgdG8gdGhpcyBjYWxsYmFja1xuICAgICAqL1xuICAgIG9uVG9vbHRpcD86IChldmVudDogSUV2ZW50KSA9PiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBjYWxsYmFjayB3aGVuIGEgaG92ZXIgb2NjdXJzIGluIHRoaXMgZWxlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IHRoZSBldmVudCByZWxhdGVkIHRvIHRoaXMgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBvbkhvdmVyPzogKGV2ZW50OiBJRXZlbnQpID0+IHZvaWQ7XG5cbiAgICAvKiogY2FsbGJhY2sgd2hlbiB1c2VyIGNsaWNrcyBvbiBhbiBpdGVtICovXG4gICAgb25DbGljaz86IChldmVudDogSUV2ZW50KSA9PiB2b2lkO1xuXG4gICAgLyoqIHRoZSBjYWxsYmFjayB3aGVuIGFuIGl0ZW0gaW4gdGhpcyBkYXRhIGlzIGRvdWJsZSBjbGlja2VkXG4gICAgICogQHBhcmFtIGV2ZW50IGNvbnRhaW5zIHRoZSBkYXRhIGZvciB0aGUgaXRlbSB0aGF0IHdhcyBjbGlja2VkXG4gICAgICovXG4gICAgb25Eb3VibGVDbGljaz86IChldmVudDogSUV2ZW50KSA9PiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogY2FsbGJhY2sgd2hlbiBhIHpvb20gYWN0aW9uIG9jY3VycyBpbiB0aGlzIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgZXZlbnQgcmVsYXRlZCB0byB0aGlzIGNhbGxiYWNrXG4gICAgICovXG4gICAgb25ab29tPzogKGV2ZW50OiBJRXZlbnQpID0+IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBjYWxsYmFjayB3aGVuIGEgYnJ1c2ggYWN0aW9uIG9jY3VycyBpbiB0aGlzIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgZXZlbnQgcmVsYXRlZCB0byB0aGlzIGNhbGxiYWNrXG4gICAgICovXG4gICAgb25CcnVzaD86IChldmVudDogSUV2ZW50KSA9PiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogY2FsbGJhY2sgd2hlbiB0aGUgY3Vyc29yIGNoYW5nZSBvY2N1cnMgaW4gdGhpcyBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgdGhlIGV2ZW50IHJlbGF0ZWQgdG8gdGhpcyBjYWxsYmFja1xuICAgICAqL1xuICAgIG9uQ3Vyc29yQ2hhbmdlZD86IChldmVudDogSUV2ZW50KSA9PiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogY2FsbGJhY2sgd2hlbiBhIHJlLXJlbmRlciBvY2N1cnMgaW4gdGhpcyBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHdoZW4gcmVuZGVyIHdhcyBjYWxsZWRcbiAgICAgKi9cbiAgICBvblJlbmRlcj86IChvcHRpb25zOiBJT3B0aW9ucykgPT4gdm9pZDtcblxuICAgIGhhbmRsZVVwZGF0ZT86IChjYWxsZXI6IFVJRWxlbWVudCwgb3B0aW9uczogSU9wdGlvbnMpID0+IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBnZXQgYWxsIGVsZW1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVuZGVyIGNhbGwgb2YgdGhpcyBVSUVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRFbGVtZW50cz86ICgpID0+IFVJRWxlbWVudFtdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElSZWN0IHtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgcmlnaHQ/OiBudW1iZXI7XG4gICAgYm90dG9tPzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElDc3Mge1xuICAgIGNsYXNzZXM/OiB7IFtpbmRleDogc3RyaW5nXTogYm9vbGVhbiB9O1xuICAgIHN0eWxlPzogeyBbaW5kZXg6IHN0cmluZ106IGFueSB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElSYW5nZSB7XG4gICAgbWluOiBudW1iZXI7XG4gICAgbWF4OiBudW1iZXI7XG59XG5cbi8vIFJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhLlxuZXhwb3J0IGNsYXNzIFJlY3QgaW1wbGVtZW50cyBJUmVjdCB7XG4gICAgcHVibGljIHg6IG51bWJlciA9IDA7XG4gICAgcHVibGljIHk6IG51bWJlciA9IDA7XG4gICAgcHVibGljIHdpZHRoOiBudW1iZXIgPSAwO1xuICAgIHB1YmxpYyBoZWlnaHQ6IG51bWJlciA9IDA7XG5cbiAgICBjb25zdHJ1Y3Rvcih4PzogbnVtYmVyLCB5PzogbnVtYmVyLCB3aWR0aD86IG51bWJlciwgaGVpZ2h0PzogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSByZWN0YW5nbGUgY29udGFpbnMgKHgseSkuXG4gICAgcHVibGljIGNvbnRhaW5zKHg6IG51bWJlciwgeTogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiAoeCA+PSB0aGlzLnggJiYgeCA8PSB0aGlzLnggKyB0aGlzLndpZHRoICYmXG4gICAgICAgICAgICB5ID49IHRoaXMueSAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0KTtcbiAgICB9XG59XG5cbi8qKlxuICogVXNlZCB0byBtYW5pcHVsYXRlIENTUyBjbGFzcyBhbmQgc3R5bGUgaW5mb3JtYXRpb25cbiAqL1xuZXhwb3J0IGNsYXNzIENzcyBpbXBsZW1lbnRzIElDc3Mge1xuICAgIHB1YmxpYyBjbGFzc2VzOiB7IFtpbmRleDogc3RyaW5nXTogYm9vbGVhbiB9O1xuICAgIHB1YmxpYyBzdHlsZTogeyBbaW5kZXg6IHN0cmluZ106IGFueSB9O1xuXG4gICAgY29uc3RydWN0b3IoY2xhc3Nlcz86IHN0cmluZywgc3R5bGU/OiB7IFtpbmRleDogc3RyaW5nXTogYW55IH0pIHtcbiAgICAgICAgaWYgKGNsYXNzZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3NlcyhjbGFzc2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NlcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlID0ge307XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSBjbGFzcyB0byB0aGUgY2xhc3MgbGlzdFxuICAgICAqIEBwYXJhbSBjbGFzc2VzIHRvIGFkZCwgY2FuIGJlIHN0cmluZ3Mgc2VwYXJhdGVkIGJ5IHNwYWNlc1xuICAgICAqXG4gICAgICogQHJldHVybiB0aGUgbWFuYWdlciBpbnN0YW5jZVxuICAgICAqL1xuICAgIHB1YmxpYyBhZGRDbGFzc2VzKGNsYXNzZXNTdHI6IHN0cmluZyk6IENzcyB7XG4gICAgICAgIGxldCBjbGFzc2VzID0gY2xhc3Nlc1N0ci5zcGxpdCgnICcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3Nlc1tjbGFzc2VzW2ldXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGEgc2V0IG9mIHN0eWxlcyB0byB0aGUgc3R5bGUgb2JqZWN0XG4gICAgICogQHBhcmFtIHN0eWxlIGEgc3R5bGUgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoZSBtYW5hZ2VyIGluc3RhbmNlXG4gICAgICovXG4gICAgcHVibGljIGFkZFN0eWxlcyhzdHlsZTogeyBbaW5kZXg6IHN0cmluZ106IGFueSB9KTogQ3NzIHtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIHN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlW2tleV0gPSBzdHlsZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKiBzZXQgdGhlIGNvbG9yIHZhbHVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sb3IgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb2xvciB0byB1c2VcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0Q29sb3IoY29sb3I6IHN0cmluZyk6IENzcyB7XG4gICAgICAgIHRoaXMuYWRkU3R5bGVzKHsgY29sb3I6IGNvbG9yIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKiogc2V0IHRoZSBvcGNhaXR5IHZhbHVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3BjYWl0eSBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGNvbG9yIHRvIHVzZVxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRPcGFjaXR5KG9wYWNpdHk6IG51bWJlcik6IENzcyB7XG4gICAgICAgIHRoaXMuYWRkU3R5bGVzKHsgb3BhY2l0eTogb3BhY2l0eSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGEgY2xhc3MgZnJvbSB0aGUgY2xhc3MgbGlzdFxuICAgICAqIEBwYXJhbSBjbGFzc05hbWUgdGhlIGNsYXNzIHRvIHJlbW92ZVxuICAgICAqXG4gICAgICogQHJldHVybiB0aGUgbWFuYWdlciBpbnN0YW5jZVxuICAgICAqL1xuICAgIHB1YmxpYyByZW1vdmVDbGFzcyhjbGFzc05hbWU6IHN0cmluZyk6IENzcyB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNsYXNzZXNbY2xhc3NOYW1lXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGEgc3R5bGUgZnJvbSB0aGUgc3R5bGUgbWFwXG4gICAgICogQHBhcmFtIGtleSB0aGUgbmFtZSBvZiB0aGUgc3R5bGUgdG8gcmVtb3ZlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoZSBtYW5hZ2VyIGluc3RhbmNlXG4gICAgICovXG4gICAgcHVibGljIHJlbW92ZVN0eWxlKGtleTogc3RyaW5nKTogQ3NzIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3R5bGVba2V5XTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBsaXN0IG9mIGNsYXNzZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBsaXN0IG9mIGNsYXNzZXMgZm9yIHRoaXMgbWFuYWdlclxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDbGFzc2VzKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuY2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGVscGVyIHRvIGdldCBhIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGNsYXNzZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBzdHJpbmcgbGlzdCBvZiBjbGFzc2VzIGZvciB0aGlzIG1hbmFnZXJcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0Q2xhc3NTdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgY2xhc3NOYW1lIGluIHRoaXMuY2xhc3Nlcykge1xuICAgICAgICAgICAgcmV0ICs9IGNsYXNzTmFtZSArICcgJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgc3R5bGUgbWFwXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGtleS92YWx1ZSBzdHlsZSBwYWlyc1xuICAgICAqL1xuICAgIHB1YmxpYyBnZXRTdHlsZXMoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGVscGVyIHRvIGdldCBhIGpzb24gcmVwcmVzZW50YXRpb24gb2YgdGhlIHN0eWxlIG1hcFxuICAgICAqXG4gICAgICogQHJldHVybiB0aGUganNvbiBzdHJpbmcgb2YgdGhlIHN0eWxlIG1hcFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRTdHlsZVN0cmluZygpOiBhbnkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5zdHlsZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBpbXBsZW1lbnRlZCBhIGJhc2ljIEFQSSBvbiB0b3Agb2YgdGhlIElSYW5nZSBvYmplY3RcbiAqL1xuZXhwb3J0IGNsYXNzIFJhbmdlIGltcGxlbWVudHMgSVJhbmdlIHtcbiAgICBwdWJsaWMgbWluOiBudW1iZXI7XG4gICAgcHVibGljIG1heDogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IobWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMubWluID0gbWluO1xuICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIG1pbiB2YWx1ZSBmb3IgdGhlIHJhbmdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoZSBtaW4gcmFuZ2UgdmFsdWVcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0TWluKG1pbjogbnVtYmVyKTogUmFuZ2Uge1xuICAgICAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBtaW4gdmFsdWUgZm9yIHRoZSByYW5nZVxuICAgICAqXG4gICAgICogQHJldHVybiB0aGUgbWluIHJhbmdlIHZhbHVlXG4gICAgICovXG4gICAgcHVibGljIGdldE1pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgbWF4IHZhbHVlIGZvciB0aGUgcmFuZ2VcbiAgICAgKlxuICAgICAqIEByZXR1cm4gdGhlIG1heCByYW5nZSB2YWx1ZVxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRNYXgobWF4OiBudW1iZXIpOiBSYW5nZSB7XG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIG1heCB2YWx1ZSBmb3IgdGhlIHJhbmdlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoZSBtYXggcmFuZ2UgdmFsdWVcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0TWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXg7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVJRWxlbWVudE1hbmFnZXIge1xuICAgIC8qKlxuICAgICAqIGFkZCBhIGVsZW0gdG8gdGhlIG1hbmFnZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtIC0gdGhlIGVsZW0gdGhhdCBzaG91bGQgc2hvdWxkIGJlIGFkZGVkXG4gICAgICogQHBhcmFtIHRvb2x0aXBHcm91cE5hbWUgLSBOYW1lIG9mIHRoZSBncm91cCB0aGF0IHRoaXMgZWxlbSBzaG91bGQgYmUgXCJnYW5nZWRcIlxuICAgICAqICAgd2l0aCB3aGVuIHNob3dpbmcgdG9vbHRpcHMuICBJZiBub3Qgc3BlY2lmaWVkLCB0aGlzIGVsZW0gd2lsbCBub3QgYmUgXCJnYW5nZWRcIiB3aXRoIGFueVxuICAgICAqICAgb3RoZXIgZWxlbS5cbiAgICAgKiBAcGFyYW0gaGlnaGxpZ2h0R3JvdXBOYW1lIC0gTmFtZSBvZiB0aGUgZ3JvdXAgdGhhdCB0aGlzIGVsZW0gc2hvdWxkIGJlIFwiZ2FuZ2VkXCJcbiAgICAgKiAgIHdpdGggd2hlbiBkb2luZyBoaWdobGlnaHRpbmcuICBJZiBub3Qgc3BlY2lmaWVkLCB0aGlzIGVsZW0gd2lsbCBub3QgYmUgXCJnYW5nZWRcIiB3aXRoIGFueVxuICAgICAqICAgb3RoZXIgZWxlbS5cbiAgICAgKiBAcGFyYW0gcmVuZGVyR3JvdXBOYW1lIC0gTmFtZSBvZiB0aGUgZ3JvdXAgdGhhdCB0aGlzIGVsZW0gc2hvdWxkIGJlIFwiZ2FuZ2VkXCJcbiAgICAgKiAgIHdpdGggd2hlbiByZXJlbmRlcmluZy4gIElmIG5vdCBzcGVjaWZpZWQsIHRoaXMgZWxlbSB3aWxsIG5vdCBiZSBcImdhbmdlZFwiIHdpdGggYW55XG4gICAgICogICBvdGhlciBlbGVtLlxuICAgICAqIEByZXR1cm4gLSBUaGUgZWxlbSBtYW5hZ2VyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFkZEVsZW1lbnQoZWxlbTogVUlFbGVtZW50LCB0b29sdGlwR3JvdXBOYW1lPzogc3RyaW5nLFxuICAgICAgICBoaWdobGlnaHRHcm91cE5hbWU/OiBzdHJpbmcsIHJlbmRlckdyb3VwTmFtZT86IHN0cmluZyk6IFVJRWxlbWVudE1hbmFnZXI7XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYSBlbGVtIGZyb20gdGhlIG1hbmFnZXIsIHJlbW92ZXMgaXQgZnJvbSBhbGwgZ3JvdXBzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbSAtIHRoZSBlbGVtIHRoYXQgc2hvdWxkIHNob3VsZCBiZSByZW1vdmVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIC0gVGhlIGVsZW0gbWFuYWdlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICByZW1vdmVFbGVtZW50KGVsZW06IFVJRWxlbWVudCk6IFVJRWxlbWVudE1hbmFnZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYWxsIHRoZSBlbGVtcyBpbiB0aGlzIGxpc3RcbiAgICAgKiBAcmV0dXJuIHRoZSBsaXN0IG9mIGVsZW1zXG4gICAgICovXG4gICAgZ2V0RWxlbWVudHMoKTogVUlFbGVtZW50W107XG5cbiAgICAvKipcbiAgICAgKiB1c2VyIGNhbGxiYWNrIGNhbGxlZCB3aGVuIGEgaG92ZXIgZXZlbnQgaGFwcGVuc1xuICAgICAqXG4gICAgICogQHBhcmFtIHRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKi9cbiAgICBzZXRIb3ZlckNhbGxiYWNrKGNhbGxiYWNrOiAoZ3JvdXA6IFVJRWxlbWVudFtdLCBldmVudDogSUV2ZW50KSA9PiB2b2lkKTogVUlFbGVtZW50TWFuYWdlcjtcblxuICAgIC8qKlxuICAgICAqIHVzZXIgY2FsbGJhY2sgY2FsbGVkIHdoZW4gYSB0b29sdGlwIGlzIGNyZWF0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aGUgZnVuY3Rpb3RuIHRvIGJlIGNhbGxlZFxuICAgICAqL1xuICAgIHNldFRvb2x0aXBDYWxsYmFjayhjYWxsYmFjazogKGdyb3VwOiBVSUVsZW1lbnRbXSwgZXZlbnQ6IElFdmVudCkgPT4gSVRvb2x0aXBEYXRhKTogVUlFbGVtZW50TWFuYWdlcjtcblxuICAgIC8qKlxuICAgICAqIHVzZXIgY2FsbGJhY2sgY2FsbGVkIHdoZW4gYSBzZWxlY3Rpb24gZXZlbnQgaGFwcGVuc1xuICAgICAqXG4gICAgICogQHBhcmFtIHRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKi9cbiAgICBzZXRCcnVzaENhbGxiYWNrKGNhbGxiYWNrOiAoZ3JvdXA6IFVJRWxlbWVudFtdLCBldmVudDogSUV2ZW50KSA9PiB2b2lkKTogVUlFbGVtZW50TWFuYWdlcjtcblxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgZ3JvdXAgdGhpcyB0b29sdGlwIGlzIGFzc29jaWF0ZWQgd2l0aFxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW0gLSB0aGUgZWxlbSB0aGF0IHNob3VsZCBzaG91bGQgYmUgXCJnYW5nZWRcIlxuICAgICAqIEBwYXJhbSBncm91cE5hbWUgLSBOYW1lIG9mIHRoZSBncm91cCB0aGF0IHRoaXMgZWxlbSBzaG91bGQgYmUgXCJnYW5nZWRcIlxuICAgICAqICAgd2l0aC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gLSBUaGUgZWxlbSBtYW5hZ2VyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFkZFRvVG9vbHRpcEdyb3VwKGVsZW06IFVJRWxlbWVudCwgZ3JvdXBOYW1lOiBzdHJpbmcpOiBVSUVsZW1lbnRNYW5hZ2VyO1xuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgZWxlbSBmcm9tIHRoZSB0b29sdGlwIGdyb3VwIGl0IGlzIGluXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbSAtIHRoZSBlbGVtIHRoYXQgc2hvdWxkIHNob3VsZCBiZSBcInVuZ2FuZ2VkXCJcbiAgICAgKlxuICAgICAqIEByZXR1cm4gLSBUaGUgZWxlbSBtYW5hZ2VyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHJlbW92ZUZyb21Ub29sdGlwR3JvdXAoZWxlbTogVUlFbGVtZW50KTogVUlFbGVtZW50TWFuYWdlcjtcblxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgZ3JvdXAgdG8gc2VsZWN0IHRoaXMgZWxlbSB3aXRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbSAtIHRoZSBlbGVtIHRoYXQgc2hvdWxkIHNob3VsZCBiZSBcImdhbmdlZFwiXG4gICAgICogQHBhcmFtIGdyb3VwTmFtZSAtIE5hbWUgb2YgdGhlIGdyb3VwIHRoYXQgdGhpcyBlbGVtIHNob3VsZCBiZSBcImdhbmdlZFwiXG4gICAgICogICB3aXRoLlxuICAgICAqXG4gICAgICogQHJldHVybiAtIFRoZSBlbGVtIG1hbmFnZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYWRkVG9IaWdobGlnaHRHcm91cChlbGVtOiBVSUVsZW1lbnQsIGdyb3VwTmFtZTogc3RyaW5nKTogVUlFbGVtZW50TWFuYWdlcjtcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgZWxlbSBmcm9tIHRoZSB6b29tIGdyb3VwIGl0IGlzIGluXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxlbSAtIHRoZSBlbGVtIHRoYXQgc2hvdWxkIHNob3VsZCBiZSBcInVuZ2FuZ2VkXCJcbiAgICAgKlxuICAgICAqIEByZXR1cm4gLSBUaGUgZWxlbSBtYW5hZ2VyIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHJlbW92ZUZyb21IaWdobGlnaHRHcm91cChlbGVtOiBVSUVsZW1lbnQpOiBVSUVsZW1lbnRNYW5hZ2VyO1xuXG4gICAgLyoqXG4gICAgICogc2V0IHRoZSBncm91cCB0byBzZWxlY3QgdGhpcyBlbGVtIHdpdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtIC0gdGhlIGVsZW0gdGhhdCBzaG91bGQgc2hvdWxkIGJlIFwiZ2FuZ2VkXCJcbiAgICAgKiBAcGFyYW0gZ3JvdXBOYW1lIC0gTmFtZSBvZiB0aGUgZ3JvdXAgdGhhdCB0aGlzIGVsZW0gc2hvdWxkIGJlIFwiZ2FuZ2VkXCJcbiAgICAgKiAgIHdpdGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIC0gVGhlIGVsZW0gbWFuYWdlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBhZGRUb1JlbmRlckdyb3VwKGVsZW06IFVJRWxlbWVudCwgZ3JvdXBOYW1lOiBzdHJpbmcpOiBVSUVsZW1lbnRNYW5hZ2VyO1xuXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIHRoZSBlbGVtIGZyb20gdGhlIHpvb20gZ3JvdXAgaXQgaXMgaW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtIC0gdGhlIGVsZW0gdGhhdCBzaG91bGQgc2hvdWxkIGJlIFwidW5nYW5nZWRcIlxuICAgICAqXG4gICAgICogQHJldHVybiAtIFRoZSBlbGVtIG1hbmFnZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcmVtb3ZlRnJvbVJlbmRlckdyb3VwKGVsZW06IFVJRWxlbWVudCk6IFVJRWxlbWVudE1hbmFnZXI7XG5cbiAgICAvKiogY2xlYXIgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGlzIGxpc3QgKi9cbiAgICBjbGVhcigpOiB2b2lkO1xufVxuIl0sIm1hcHBpbmdzIjoiOztBQVNBO0FBc0dBOztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFtQkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFrVEE7QUFDQTtBQU1BO0FBTEE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEJBO0FBb0JBOztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1SEE7QUE0SEE7QUFFQTs7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/interface/ui-base.ts\n");

/***/ }),

/***/ "ag-grid-community":
/*!***************************************************************************************************************************!*\
  !*** external {"root":"agGrid","commonjs2":"ag-grid-community","amd":"ag-grid-community","commonjs":"ag-grid-community"} ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_ag_grid_community__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWctZ3JpZC1jb21tdW5pdHkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9VV1QvZXh0ZXJuYWwge1wicm9vdFwiOlwiYWdHcmlkXCIsXCJjb21tb25qczJcIjpcImFnLWdyaWQtY29tbXVuaXR5XCIsXCJhbWRcIjpcImFnLWdyaWQtY29tbXVuaXR5XCIsXCJjb21tb25qc1wiOlwiYWctZ3JpZC1jb21tdW5pdHlcIn0/MmZmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfYWdfZ3JpZF9jb21tdW5pdHlfXzsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///ag-grid-community\n");

/***/ }),

/***/ "es6-promise":
/*!******************************!*\
  !*** external "es6-promise" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_es6_promise__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXM2LXByb21pc2UuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9VV1QvZXh0ZXJuYWwgXCJlczYtcHJvbWlzZVwiP2IyMDYiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2VzNl9wcm9taXNlX187Il0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///es6-promise\n");

/***/ })

/******/ });
});